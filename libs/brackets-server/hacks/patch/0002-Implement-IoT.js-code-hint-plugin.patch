From 9030a63e4e22a424200a96fa9c1d3d4adc150999 Mon Sep 17 00:00:00 2001
From: Hunseop Jeong <hs85.jeong@samsung.com>
Date: Tue, 26 Sep 2017 14:32:04 +0900
Subject: [PATCH] Implement IoT.js code hint plugin

 - Enable iotjs code hint if project type is iotjs.
 - Excluding third party js from the eslint

Signed-off-by: Hunseop Jeong <hs85.jeong@samsung.com>
---
 plugin/iotjs.js | 1082 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1082 insertions(+)
 create mode 100644 plugin/iotjs.js

diff --git a/plugin/iotjs.js b/plugin/iotjs.js
new file mode 100644
index 0000000..5939fd6
--- /dev/null
+++ b/plugin/iotjs.js
@@ -0,0 +1,1082 @@
+(function(mod) {
+    if (typeof exports == "object" && typeof module == "object") // CommonJS
+      return mod(require("../lib/infer"), require("../lib/tern"), require);
+    if (typeof define == "function" && define.amd) // AMD
+      return define(["../lib/infer", "../lib/tern"], mod);
+    mod(tern, tern);
+  })(function(infer, tern, require) {
+    "use strict";
+
+    function resolvePath(base, path) {
+      if (path[0] == "/") return path;
+      var slash = base.lastIndexOf("/"), m;
+      if (slash >= 0) path = base.slice(0, slash + 1) + path;
+      while (m = /[^\/]*[^\/\.][^\/]*\/\.\.\//.exec(path))
+        path = path.slice(0, m.index) + path.slice(m.index + m[0].length);
+      return path.replace(/(^|[^\.])\.\//g, "$1");
+    }
+
+    function relativePath(from, to) {
+      if (from[from.length - 1] != "/") from += "/";
+      if (to.indexOf(from) == 0) return to.slice(from.length);
+      else return to;
+    }
+
+    function getModule(data, name) {
+      return data.modules[name] || (data.modules[name] = new infer.AVal);
+    }
+
+    var WG_DEFAULT_EXPORT = 95;
+
+    function buildWrappingScope(parent, origin, node) {
+      var scope = new infer.Scope(parent);
+      scope.originNode = node;
+      infer.cx().definitions.node.require.propagate(scope.defProp("require"));
+      var module = new infer.Obj(infer.cx().definitions.node.Module.getProp("prototype").getType());
+      module.propagate(scope.defProp("module"));
+      var exports = new infer.Obj(true, "exports");
+      module.origin = exports.origin = origin;
+      exports.propagate(scope.defProp("exports"));
+      var moduleExports = scope.exports = module.defProp("exports");
+      exports.propagate(moduleExports, WG_DEFAULT_EXPORT);
+      return scope;
+    }
+
+    function resolveModule(server, name, _parent) {
+      server.addFile(name, null, server._node.currentOrigin);
+      return getModule(server._node, name);
+    }
+
+    // Assume node.js & access to local file system
+    if (require) (function() {
+      var fs = require("fs"), module_ = require("module"), path = require("path");
+
+      relativePath = path.relative;
+
+      resolveModule = function(server, name, parent) {
+        var data = server._node;
+        if (data.options.dontLoad == true ||
+            data.options.dontLoad && new RegExp(data.options.dontLoad).test(name) ||
+            data.options.load && !new RegExp(data.options.load).test(name))
+          return infer.ANull;
+
+        if (data.modules[name]) return data.modules[name];
+
+        var currentModule = {
+          id: parent,
+          paths: module_._nodeModulePaths(path.dirname(parent))
+        };
+        try {
+          var file = module_._resolveFilename(name, currentModule);
+        } catch(e) { return infer.ANull; }
+
+        var norm = normPath(file);
+        if (data.modules[norm]) return data.modules[norm];
+
+        if (fs.existsSync(file) && /^(\.js)?$/.test(path.extname(file)))
+          server.addFile(relativePath(server.options.projectDir, file), null, data.currentOrigin);
+        return data.modules[norm] = new infer.AVal;
+      };
+    })();
+
+    function normPath(name) { return name.replace(/\\/g, "/"); }
+
+    function resolveProjectPath(server, pth) {
+      return resolvePath(normPath(server.options.projectDir || "") + "/", normPath(pth));
+    }
+
+    infer.registerFunction("nodeRequire", function(_self, _args, argNodes) {
+      if (!argNodes || !argNodes.length || argNodes[0].type != "Literal" || typeof argNodes[0].value != "string")
+        return infer.ANull;
+      var cx = infer.cx(), server = cx.parent, data = server._node, name = argNodes[0].value;
+      var locals = cx.definitions.node;
+      if (locals[name] && /^[a-z_]*$/.test(name)) return locals[name];
+
+      if (name in data.modules) return data.modules[name];
+
+      var result;
+      if (data.options.modules && data.options.modules.hasOwnProperty(name)) {
+        var scope = buildWrappingScope(cx.topScope, name);
+        infer.def.load(data.options.modules[name], scope);
+        result = data.modules[name] = scope.exports;
+      } else {
+        // data.currentFile is only available while analyzing a file; at query
+        // time, determine the calling file from the caller's AST.
+        var currentFile = data.currentFile || resolveProjectPath(server, argNodes[0].sourceFile.name);
+
+        var relative = /^\.{0,2}\//.test(name);
+        if (relative) {
+          if (!currentFile) return argNodes[0].required || infer.ANull;
+          name = resolvePath(currentFile, name);
+        }
+        result = resolveModule(server, name, currentFile);
+      }
+      return argNodes[0].required = result;
+    });
+
+    function preCondenseReach(state) {
+      var mods = infer.cx().parent._node.modules;
+      var node = state.roots["!node"] = new infer.Obj(null);
+      for (var name in mods) {
+        var mod = mods[name];
+        var id = mod.origin || name;
+        var prop = node.defProp(id.replace(/\./g, "`"));
+        mod.propagate(prop);
+        prop.origin = mod.origin;
+      }
+    }
+
+    function postLoadDef(data) {
+      var cx = infer.cx(), mods = cx.definitions[data["!name"]]["!node"];
+      var data = cx.parent._node;
+      if (mods) for (var name in mods.props) {
+        var origin = name.replace(/`/g, ".");
+        var mod = getModule(data, origin);
+        mod.origin = origin;
+        mods.props[name].propagate(mod);
+      }
+    }
+
+    tern.registerPlugin("iotjs", function(server, options) {
+      server._node = {
+        modules: Object.create(null),
+        options: options || {},
+        currentFile: null,
+        currentRequires: [],
+        currentOrigin: null,
+        server: server
+      };
+
+      server.on("beforeLoad", function(file) {
+        this._node.currentFile = resolveProjectPath(server, file.name);
+        this._node.currentOrigin = file.name;
+        this._node.currentRequires = [];
+        file.scope = buildWrappingScope(file.scope, this._node.currentOrigin, file.ast);
+      });
+
+      server.on("afterLoad", function(file) {
+        var mod = getModule(this._node, this._node.currentFile);
+        mod.origin = this._node.currentOrigin;
+        file.scope.exports.propagate(mod);
+        this._node.currentFile = null;
+        this._node.currentOrigin = null;
+      });
+
+      server.on("reset", function() {
+        this._node.modules = Object.create(null);
+      });
+
+      return {defs: defs,
+              passes: {preCondenseReach: preCondenseReach,
+                       postLoadDef: postLoadDef,
+                       completion: findCompletions}};
+    });
+
+    // Completes CommonJS module names in strings passed to require
+    function findCompletions(file, query) {
+      var wordEnd = tern.resolvePos(file, query.end);
+      var callExpr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope, "CallExpression");
+      if (!callExpr) return;
+      var callNode = callExpr.node;
+      if (callNode.callee.type != "Identifier" || callNode.callee.name != "require" ||
+          callNode.arguments.length < 1) return;
+      var argNode = callNode.arguments[0];
+      if (argNode.type != "Literal" || typeof argNode.value != "string" ||
+          argNode.start > wordEnd || argNode.end < wordEnd) return;
+
+      var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0);
+      if (word && word.charAt(word.length - 1) == quote)
+        word = word.slice(0, word.length - 1);
+      var completions = completeModuleName(query, file, word);
+      if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
+        ++wordEnd;
+      return {
+        start: tern.outputPos(query, file, argNode.start),
+        end: tern.outputPos(query, file, wordEnd),
+        isProperty: false,
+        completions: completions.map(function(rec) {
+          var name = typeof rec == "string" ? rec : rec.name;
+          var string = JSON.stringify(name);
+          if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote;
+          if (typeof rec == "string") return string;
+          rec.displayName = name;
+          rec.name = string;
+          return rec;
+        })
+      };
+    }
+
+    function completeModuleName(query, file, word) {
+      var completions = [];
+      var cx = infer.cx(), server = cx.parent, data = server._node;
+      var currentFile = data.currentFile || resolveProjectPath(server, file.name);
+      var wrapAsObjs = query.types || query.depths || query.docs || query.urls || query.origins;
+
+      function gather(modules) {
+        for (var name in modules) {
+          if (name == currentFile) continue;
+
+          var moduleName = resolveModulePath(name, currentFile);
+          if (moduleName &&
+              !(query.filter !== false && word &&
+                (query.caseInsensitive ? moduleName.toLowerCase() : moduleName).indexOf(word) !== 0)) {
+            var rec = wrapAsObjs ? {name: moduleName} : moduleName;
+            completions.push(rec);
+
+            if (query.types || query.docs || query.urls || query.origins) {
+              var val = modules[name];
+              infer.resetGuessing();
+              var type = val.getType();
+              rec.guess = infer.didGuess();
+              if (query.types)
+                rec.type = infer.toString(val);
+              if (query.docs)
+                maybeSet(rec, "doc", val.doc || type && type.doc);
+              if (query.urls)
+                maybeSet(rec, "url", val.url || type && type.url);
+              if (query.origins)
+                maybeSet(rec, "origin", val.origin || type && type.origin);
+            }
+          }
+        }
+      }
+
+      if (query.caseInsensitive) word = word.toLowerCase();
+      gather(cx.definitions.node);
+      gather(data.modules);
+      return completions;
+    }
+
+    /**
+     * Resolve the module path of the given module name by using the current file.
+     */
+    function resolveModulePath(name, currentFile) {
+
+      function startsWith(str, prefix) {
+        return str.slice(0, prefix.length) == prefix;
+      }
+
+      function endsWith(str, suffix) {
+        return str.slice(-suffix.length) == suffix;
+      }
+
+      if (name.indexOf('/') == -1) return name;
+      // module name has '/', compute the module path
+      var modulePath = normPath(relativePath(currentFile + '/..', name));
+      if (startsWith(modulePath, 'node_modules')) {
+        // module name starts with node_modules, remove it
+        modulePath = modulePath.substring('node_modules'.length + 1, modulePath.length);
+        if (endsWith(modulePath, 'index.js')) {
+          // module name ends with index.js, remove it.
+         modulePath = modulePath.substring(0, modulePath.length - 'index.js'.length - 1);
+        }
+      } else if (!startsWith(modulePath, '../')) {
+        // module name is not inside node_modules and there is not ../, add ./
+        modulePath = './' + modulePath;
+      }
+      if (endsWith(modulePath, '.js')) {
+        // remove js extension
+        modulePath = modulePath.substring(0, modulePath.length - '.js'.length);
+      }
+      return modulePath;
+    }
+
+    function maybeSet(obj, prop, val) {
+      if (val != null) obj[prop] = val;
+    }
+
+    tern.defineQueryType("node_exports", {
+      takesFile: true,
+      run: function(server, query, file) {
+        function describe(aval) {
+          var target = {}, type = aval.getType(false);
+          target.type = infer.toString(type, 3);
+          var doc = aval.doc || (type && type.doc), url = aval.url || (type && type.url);
+          if (doc) target.doc = doc;
+          if (url) target.url = url;
+          var span = tern.getSpan(aval) || (type && tern.getSpan(type));
+          if (span) tern.storeSpan(server, query, span, target);
+          return target;
+        }
+
+        var known = server._node.modules[resolveProjectPath(server, file.name)];
+        if (!known) return {};
+        var type = known.getType(false);
+        var resp = describe(known);
+        if (type instanceof infer.Obj) {
+          var props = resp.props = {};
+          for (var prop in type.props)
+            props[prop] = describe(type.props[prop]);
+        }
+        return resp;
+      }
+    });
+
+    var defs = {
+      "!name": "node",
+      "!define": {
+        require: {
+          "!type": "fn(id: string) -> !custom:nodeRequire",
+          "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Module.md#requireid",
+          "!doc": "Loads the module named id."
+        },
+        Module: {
+          "!type": "fn()",
+          prototype: {
+            require: {
+              "!type": "require",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Module.md#requireid",
+              "!doc": "Loads the module named id."
+            }
+          }
+        },
+        events: {
+          EventEmitter: {
+            prototype: {
+              addListener: {
+                "!type": "fn(event: string, listener: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitteraddlistenerevent-listener",
+                "!doc": "Adds the listener callback function to the end of the listener's list for the given event."
+              },
+              on: {
+                "!type": "fn(event: string, listener: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitteronevent-listener",
+                "!doc": "Adds the listener callback function to the end of the listener's list for the given event."
+              },
+              emit: {
+                "!type": "fn(event: string)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitteremitevent-args",
+                "!doc": "Returns true if the event had listeners, false otherwise."
+              },
+              once: {
+                "!type": "fn(event: string, listener: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitteronceevent-listener",
+                "!doc": "Adds the listener as a one time listener for the event."
+              },
+              removeListener: {
+                "!type": "fn(event: string, listener: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitterremovelistenerevent-listener",
+                "!doc": "Removes listener from the list of event listeners."
+              },
+              removeAllListeners: {
+                "!type": "fn(event: string)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#emitterremovealllistenersevent",
+                "!doc": "Removes all listeners. If event was specified, it only removes the listeners for that event."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Events.md#class-eventemitter",
+            "!doc": "Returns with a new EventEmitter object."
+          }
+        },
+        stream: {
+          "!type": "fn()",
+          prototype: {
+            "!proto": "events.EventEmitter.prototype",
+          },
+          Readable: {
+            "!type": "fn(options: ?)",
+            prototype: {
+              "!proto": "stream.prototype",
+              isPaused: {
+                "!type": "fn() -> bool",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#readableispaused",
+                "!doc": "Returns true if the Readable stream is in paused mode. Otherwise the stream is in flowing mode. By default the stream starts in paused mode."
+              },
+              pause: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#readablepause",
+                "!doc": "Stops emitting 'data' events if the stream is in flowing mode and sets paused mode. No effect otherwise."
+              },
+              read: {
+                "!type": "fn(size?: number) -> +Buffer",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#readablereadsize",
+                "!doc": "The readable.read() method pulls some data out of the internal buffer and returns it. If no data is available null is returned instead."
+              },
+              resume: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#readableresume",
+                "!doc": "Starts emitting 'data' events if the stream is in paused mode and sets flowing mode. No effect otherwise."
+              },
+              push: {
+                "!type": "fn(chunk: +Buffer)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#readablepushchunk",
+                "!doc": "Push a chunk of data to the underlying Buffer of this stream. The data can be read by using either readable.read() method or 'data' event of this stream."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#new-readableoptions",
+            "!doc": "This function registers the common properties of Readable streams."
+          },
+          Writable: {
+            "!type": "fn(options?: ?)",
+            prototype: {
+              "!proto": "stream.prototype",
+              end: {
+                "!type": "fn(chunk: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#writableendchunk-callback",
+                "!doc": "Calling this function signals that no more data will be written to the Writable. The optional chunk argument allows writing a final chunk of data. If chunk is null no data is written."
+              },
+              write: {
+                "!type": "fn(chunk: +Buffer, callback?: fn()) -> bool",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#writablewritechunk-callback",
+                "!doc": "Converts chunk into a sequence of bytes and writes this data to the stream. An optional callback function is called when the data is flushed."
+              },
+              _readyToWrite: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#writable_readytowrite",
+                "!doc": "This method informs the Writable stream that the implementation is ready for receiving data."
+              },
+              _write: {
+                "!type": "fn(chunk: +Buffer, callback: fn(), onwrite: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#writable_writechunk-callback-onwrite",
+                "!doc": "This internal method is called by the Writable stream and the implementation must override it."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#new-streamwritableoptions",
+            "!doc": "This function registers the common properties of Writable streams."
+          },
+          "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Stream.md#class-stream",
+          "!doc": "This function registers the common properties of all streams."
+        },
+        assert: {
+          "!type": "fn(value: ?, message?: ?)",
+          doesNotThrow: {
+            "!type": "fn(block: fn(), messsage?: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#doesnotthrowblock-message",
+            "!doc": "Tests if the given block does not throw any exception. Otherwise throws an exception with the given optional message."
+          },
+          equal: {
+            "!type": "fn(actual: ?, expected: ?, message?: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#equalactual-expected-message",
+            "!doc": "Tests if actual == expected is evaluated to true. Otherwise throws an exception with the given optional message."
+          },
+          fail: {
+            "!type": "fn(actual: ?, expected: ?, message: ?, operator: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#failactual-expected-message-operator",
+            "!doc": "Throws an AssertionError exception with the given message."
+          },
+          notEqual: {
+            "!type": "fn(actual: ?, expected: ?, message?: ?)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#notequalactual-expected-message",
+            "!doc": "Tests shallow, coercive non-equality with the not equal comparison operator ( != )."
+          },
+          notStrictEqual: {
+            "!type": "fn(actual: ?, expected: ?, message?: ?)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#notstrictequalactual-expected-message",
+            "!doc": "Tests if actual !== expected is evaluated to true. Otherwise throws an exception with the given optional message."
+          },
+          strictEqual: {
+            "!type": "fn(actual: ?, expected: ?, message?: ?)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#strictequalactual-expected-message",
+            "!doc": "Tests if actual === expected is evaluated to true. Otherwise throws an exception with the given optional message."
+          },
+          "throws": {
+            "!type": "fn(block: fn(), expected?: fn(), messsage?: ?)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#throwsblock-expected-message",
+            "!doc": "Tests if the given block throws an expected error. Otherwise throws an exception with the given optional message."
+          },
+          "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Assert.md#assertvalue-message",
+          "!doc": "Checks if the value is truthy. If it is not, throws an AssertionError, with the given optional message."
+        },
+        buffer: {
+          Buffer: "Buffer"
+        },
+        Buffer: {
+          "!type": "fn(str: string, encoding?: string) -> +Buffer",
+          prototype: {
+            "!proto": "String.prototype",
+            length: {
+              "!type": "number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#buflength",
+              "!doc": "Returns the capacity of the buffer in bytes. Note: when the buffer is converted to another type (e.g. String) the length of the converted value might be different from this value."
+            },
+            compare: {
+              "!type": "fn(otherBuffer: +Buffer)",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufcompareotherbuffer",
+              "!doc": "This function performs a lexicographic comparison between two buffers."
+            },
+            copy: {
+              "!type": "fn(targetBuffer: +Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufcopytargetbuffer-targetstart-sourcestart-sourceend",
+              "!doc": "Copy a sequence of bytes from buf buffer to targetBuffer buffer. The source byte range is specified by sourceStart and sourceEnd and the destination byte offset is specified by targetStart. Only the targetBuffer is modified."
+            },
+            equals: {
+              "!type": "fn(otherBuffer: +Buffer) -> bool",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufequalsotherbuffer",
+              "!doc": "Returns true if this and otherBuffer have exactly the same bytes. Returns false otherwise."
+            },
+            fill: {
+              "!type": "fn(value: number) -> +Buffer",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#buffillvalue",
+              "!doc": "Set all bytes of the buffer to value. The value is converted to integer first and its modulo 256 remainder is used for updating the buffer. Returns with buf."
+            },
+            slice: {
+              "!type": "fn(start?: number, end?: number) -> +Buffer",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufslicestart-end",
+              "!doc": "This function returns with a newly created buffer which contains the bytes of the buf buffer between start and end."
+            },
+            toString: {
+              "!type": "fn(start?: number, end?: number) -> string",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#buftostringstart-end",
+              "!doc": "Returns a string created from the bytes stored in the buffer. By passing start and end the conversion can be limited to a subset of the buf buffer. If a single hex string is passed to the function, the whole buffer is converted to hexadecimal data."
+            },
+            write: {
+              "!type": "fn(string: string, offset?: number, length?: number)",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufwritestring-offset-length",
+              "!doc": "Writes string into the buf buffer. The start position of the writing can be specified by offset and the maximum number of updated bytes can be limited by length. Returns total number of bytes written to the buffer."
+            },
+            writeUInt8: {
+              "!type": "fn(value: number, offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufwriteuint8value-offset-noassert",
+              "!doc": "Writes value into the buffer starting from offset position. The value must be a valid 8-bit unsigned integer."
+            },
+            writeUInt16LE: {
+              "!type": "fn(value: number, offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufwriteuint16levalue-offset-noassert",
+              "!doc": "Writes value into the buffer starting from offset position with little endian format. The value must be a valid 16-bit unsigned integer."
+            },
+            writeUInt32LE: {
+              "!type": "fn(value: number, offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufwriteuint32levalue-offset-noassert",
+              "!doc": "Writes value into the buffer starting from offset position with little endian format. The value must be a valid 32-bit unsigned integer."
+            },
+            readInt8: {
+              "!type": "fn(offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufreadint8offset-noassert",
+              "!doc": "Reads a signed 8-bit integer from buf buffer starting from offset position."
+            },
+            readUInt8: {
+              "!type": "fn(offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufreaduint8offset-noassert",
+              "!doc": "Reads an unsigned 8-bit integer from buf buffer starting from offset position."
+            },
+            readUInt16LE: {
+              "!type": "fn(offset: number, noAssert?: bool) -> number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufreaduint16leoffset-noassert",
+              "!doc": "Reads an unsigned 16-bit integer from buf buffer starting from offset position with little endian format."
+            }
+          },
+          byteLength: {
+            "!type": "fn(str: string, encoding?: string) -> number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufferbytelengthstr-encoding",
+            "!doc": "Returns the byte length of a buffer representing the value of the string argument encoded with encoding."
+          },
+          concat: {
+            "!type": "fn(list: [?]) -> +Buffer",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufferconcatlist",
+            "!doc": "Returns the concatenation of the Buffer objects provided in the list array."
+          },
+          isBuffer: {
+            "!type": "fn(obj: ?) -> bool",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#bufferisbufferobj",
+            "!doc": "Returns true if obj is an instance of Buffer. Returns false otherwise."
+          },
+          "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Buffer.md#new-bufferstr-encoding",
+          "!doc": "Creates a new buffer which contains the CESU-8 representation of the str string argument."
+        },
+        dns: {
+          ADDRCONFIG: {
+            "!type": "number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-DNS.md#dnsaddrconfig",
+            "!doc": "Returned address types are determined by the types of addresses supported by the current system."
+          },
+          V4MAPPED: {
+            "!type": "number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-DNS.md#dnsv4mapped",
+            "!doc": "If the IPv6 family was specified, but no IPv6 addresses were found, then return IPv4 mapped IPv6 addresses."
+          },
+          lookup: {
+            "!type": "fn(hostname: string, options?: ?, callback: fn(err: +Error, address: string, family: number))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-DNS.md#dnslookuphostname-options-callback",
+            "!doc": "Resolves a hostname (e.g. iotjs.net) into the first found A (IPv4) or AAAA (IPv6) record. All option properties are option. If option is a number, then it must be 4. If options is not provided, then IPv4 addresses are returned if found."
+          }
+        },
+        fs: {
+          Stats: {
+            "!type": "fn()",
+            prototype: {
+              isDirectory: "fn() -> bool",
+              isFile: "fn() -> bool"
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#class-fsstats",
+            "!doc": "fs.Stats class is an object returned from fs.stat(),fs.fstat() and their synchronous counterparts."
+          },
+          close: {
+            "!type": "fn(fd: number, callback?: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsclosefd-callback",
+            "!doc": "Closes the file of fd asynchronously."
+          },
+          closeSync: {
+            "!type": "fn(fd: number)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsclosesyncfd",
+            "!doc": "Closes the file of fd synchronously."
+          },
+          exists: {
+            "!type": "fn(path: string, callback?: fn(exists: bool))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsexistspath-callback",
+            "!doc": "Checks the file specified by path exists asynchronously."
+          },
+          existsSync: {
+            "!type": "fn(path: string) -> bool",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsexistssyncpath",
+            "!doc": "Checks the file specified by path exists synchronously."
+          },
+          fstat: {
+            "!type": "fn(fd: number, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsfstatfd-callback",
+            "!doc": "Get information about a file what specified by fd into stat asynchronously."
+          },
+          fstatSync: {
+            "!type": "fn(fd: number) -> +fs.Stats",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsfstatsyncfd",
+            "!doc": "Get information about a file what specified by fd synchronously."
+          },
+          mkdir: {
+            "!type": "fn(path: string, mode?: ?, callback?: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsmkdirpath-mode-callback",
+            "!doc": "Creates the directory specified by path asynchronously."
+          },
+          mkdirSync: {
+            "!type": "fn(path: string, mode?: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsmkdirsyncpath-mode",
+            "!doc": "Creates the directory specified by path synchronously."
+          },
+          open: {
+            "!type": "fn(path: string, flags: string, mode?: string, callback?: fn(err: +Error, fd: number))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsopenpath-flags-mode-callback",
+            "!doc": "Opens file asynchronously."
+          },
+          openSync: {
+            "!type": "fn(path: string, flags: string, mode?: string) -> number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsopensyncpath-flags-mode",
+            "!doc": "Opens file synchronously."
+          },
+          read: {
+            "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, bytesRead: number, buffer: +Buffer))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreadfd-buffer-offset-length-position-callback",
+            "!doc": "Reads data from the file specified by fd asynchronously."
+          },
+          readSync: {
+            "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreadsyncfd-buffer-offset-length-position",
+            "!doc": "Reads data from the file specified by fd synchronously."
+          },
+          readdir: {
+            "!type": "fn(path: string, callback?: fn(err: +Error, files: [?]))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreaddirpath-callback",
+            "!doc": "Reads the contents of the directory specified by path asynchronously, . and .. are excluded from files."
+          },
+          readdirSync: {
+            "!type": "fn(path: string) -> [?]",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreaddirsyncpath",
+            "!doc": "Reads the contents of the directory specified by path synchronously, . and .. are excluded from filenames."
+          },
+          readFile: {
+            "!type": "fn(filename: string, callback: fn(err: +Error, data: +Buffer))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreadfilepath-callback",
+            "!doc": "Reads entire file asynchronously into data."
+          },
+          readFileSync: {
+            "!type": "fn(path: string) -> ?",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsreadfilesyncpath",
+            "!doc": "Reads entire file synchronously."
+          },
+          rename: {
+            "!type": "fn(oldPath: string, newPath: string, callback?: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsrenameoldpath-newpath-callback",
+            "!doc": "Renames oldPath to newPath asynchronously."
+          },
+          renameSync: {
+            "!type": "fn(oldPath: string, newPath: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsrenamesyncoldpath-newpath",
+            "!doc": "Renames oldPath to newPath synchronously."
+          },
+          rmdir: {
+            "!type": "fn(path: string, callback?: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsrmdirpath-callback",
+            "!doc": "Removes the directory specified by path asynchronously."
+          },
+          rmdirSync: {
+            "!type": "fn(path: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsrmdirsyncpath",
+            "!doc": "Removes the directory specified by path synchronously."
+          },
+          stat: {
+            "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsstatpath-callback",
+            "!doc": "Get information about a file into stat asynchronously."
+          },
+          statSync: {
+            "!type": "fn(path: string) -> +fs.Stats",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsstatsyncpath",
+            "!doc": "Get information about a file synchronously."
+          },
+          unlink: {
+            "!type": "fn(path: string, callback?: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsunlinkpath-callback",
+            "!doc": "Removes the file specified by path asynchronously."
+          },
+          unlinkSync: {
+            "!type": "fn(path: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fsunlinksyncpath",
+            "!doc": "Removes the file specified by path synchronously."
+          },
+          write: {
+            "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position?: number, callback?: fn(err: +Error, byteWrite: number, buffer: +Buffer))",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fswritefd-buffer-offset-length-position-callback",
+            "!doc": "Writes buffer to the file specified by fd asynchronously."
+          },
+          writeSync: {
+            "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position?: number) -> number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fswritesyncfd-buffer-offset-length-position",
+            "!doc": "Writes buffer to the file specified by fd synchronously."
+          },
+          writeFile: {
+            "!type": "fn(path: string, data: +Buffer, callback: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fswritefilepath-data-callback",
+            "!doc": "Writes entire data to the file specified by path asynchronously."
+          },
+          writeFileSync: {
+            "!type": "fn(path: string, data: +Buffer)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-File-System.md#fswritefilesyncpath-data",
+            "!doc": "Writes entire data to the file specified by path synchronously."
+          }
+        },
+        http: {
+          createServer: {
+            "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +http.Server",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#httpcreateserverrequestlistener",
+            "!doc": "Returns a new web server object."
+          },
+          request: {
+            "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#httprequestoptions-callback",
+            "!doc": "IoT.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests."
+          },
+          get: {
+            "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#httpgetoptions-callback",
+            "!doc": "Since most requests are GET requests without bodies, IoT.js provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically."
+          },
+          METHODS: {
+            "!type": "string",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#httpmethods",
+            "!doc": "A list of HTTP methods supported by the parser as string properties of an Object."
+          },
+          Server: {
+            "!type": "fn()",
+            prototype: {
+              "!proto": "events.EventEmitter.prototype",
+            },
+            timeout: {
+              "!type": "number",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#servertimeout",
+              "!doc": "The number of milliseconds of inactivity before a socket is presumed to have timed out. Default value is 120000 (2 minutes)."
+            },
+            listen: {
+              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#serverlistenport-hostname-backlog-callback",
+              "!doc": "Wait for new TCP connection with specified port and hostname. If no hostname is provided, server accepts any IP address. backlog is maximum pending connections. Default backlog length is 511 (not 512). callback will be called when server has been bound."
+            },
+            close: {
+              "!type": "fn(callback?: ?)",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#serverclosecallback",
+              "!doc": "Stop accepting new connection to this server."
+            },
+            setTimeout: {
+              "!type": "fn(timeout: number, callback?: fn())",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#serversettimeoutms-cb",
+              "!doc": "Registers cb for 'timeout' event and sets socket's timeout value to ms. This event will be triggered by the underlying socket's 'timeout' event."
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#class-httpserver",
+            "!doc": "Class for HTTP server objects."
+          },
+          ServerResponse: {
+            "!type": "fn()",
+            prototype: {
+              "!proto": "stream.Writable.prototype",
+              end: {
+                "!type": "fn(data?: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responseenddata-callback",
+                "!doc": "Finishes sending the response."
+              },
+              getHeader: {
+                "!type": "fn(name: string) -> string",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responsegetheadername",
+                "!doc": "Returns name field of response's header."
+              },
+              removeHeader: {
+                "!type": "fn(name: string)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responseremoveheadername",
+                "!doc": "Removes name field from response's header."
+              },
+              setHeader: {
+                "!type": "fn(name: string, value: string)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responsesetheadername-value",
+                "!doc": "Sets response's header field(name) to value. If the field exists, it overwrites the existing value."
+              },
+              setTimeout: {
+                "!type": "fn(ms: number, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responsesettimeoutms-cb",
+                "!doc": "Registers cb for 'timeout' event and set socket's timeout value to ms. This event will be triggered by the underlying socket's 'timeout' event."
+              },
+              write: {
+                "!type": "fn(data: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responsewritedata-callback",
+                "!doc": "Sends data as a response body. callback will be called when data is flushed."
+              },
+              writeHead: {
+                "!type": "fn(statusCode: number, statusMessage?: string, headers?: ?)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#responsewriteheadstatuscode-statusmessage-headers",
+                "!doc": "Sets response's header. headers is a map between field and value in header."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#class-httpserverresponse",
+            "!doc": "This object is created internally by a HTTP server--not by the user. It is passed as the second parameter to the 'request' event."
+          },
+          ClientRequest: {
+            "!type": "fn()",
+            prototype: {
+              "!proto": "stream.Writable.prototype",
+              end: {
+                "!type": "fn(data?: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#requestenddata-callback",
+                "!doc": "Finishes sending the request."
+              },
+              setTimeout: {
+                "!type": "fn(ms: number, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#requestsettimeoutms-cb",
+                "!doc": "Registers cb for 'timeout' event and set socket's timeout value to ms. This event will be triggered by the underlying socket's 'timeout' event."
+              },
+              write: {
+                "!type": "fn(data: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#requestwritedata-callback",
+                "!doc": "Sends data as a request body. callback will be called when data is flushed."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#class-httpclientrequest",
+            "!doc": "This object is created internally and returned from http.request(). It represents an in-progress request whose header has already been queued."
+          },
+          IncomingMessage: {
+            "!type": "fn()",
+            prototype: {
+              "!proto": "stream.Readable.prototype",
+              headers: {
+                "!type": "?",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messageheaders",
+                "!doc": "HTTP header object."
+              },
+              method: {
+                "!type": "string",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messagemethod",
+                "!doc": "Requests method as string."
+              },
+              socket: {
+                "!type": "?",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messagesocket",
+                "!doc": "Underlying socket."
+              },
+              statusCode: {
+                "!type": "number",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messagestatuscode",
+                "!doc": "HTTP response status code as number of 3-digit."
+              },
+              statusMessage: {
+                "!type": "string",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messagestatusmessage",
+                "!doc": "HTTP response status message as string."
+              },
+              url: {
+                "!type": "string",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messageurl",
+                "!doc": "Requests URL as string"
+              },
+              setTimeout: {
+                "!type": "fn(ms: number, cb: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#messagesettimeoutms-cb",
+                "!doc": "Registers cb for 'timeout' event set socket's timeout value to ms. This event will be triggered by the underlying socket's 'timeout' event."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-HTTP.md#class-httpincomingmessage",
+            "!doc": "http.IncomingMessage inherits Stream.readable."
+          }
+        },
+        net: {
+          connect: {
+            "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#netconnectoptions-connectlistener",
+            "!doc": "Creates a new net.Socket and automatically connects with the supplied options."
+          },
+          createConnection: {
+            "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#netcreateconnectionoptions-connectlistener",
+            "!doc": "Creates a new net.Socket and automatically connects with the supplied options. The options are passed to both the net.Socket constructor and the socket.connect method."
+          },
+          createServer: {
+            "!type": "fn(options?: ?, connectionListener?: fn()) -> +net.Server",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#netcreateserveroptions-connectionlistener",
+            "!doc": "Creates a TCP server according to options. The connectionListener is automatically registered as a 'connection' event listener. If allowHalfOpen is true, then the socket becomes non-readable, but still writable. You should call the socket.end() method explicitly."
+          },
+          Server: {
+            "!type": "fn()",
+            prototype: {
+              "!proto": "net.Socket.prototype",
+              close: {
+                "!type": "fn(closeListener?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#serverclosecloselistener",
+                "!doc": "Stops listening new arriving connection. Server socket will be finally closed when all existing connections are closed, then emits 'close' event. The closeListener is registered as a 'close' event listener."
+              },
+              listen: {
+                "!type": "fn(options: ?, listenListener?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#serverlistenoptions-listenlistener",
+                "!doc": "It behaves as the server.listen(port[, host][, backlog][, listenListener]) function above."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#class-netserver",
+            "!doc": "This class is used to create a TCP or local server. You can create net.Server instance with net.createServer()."
+          },
+          Socket: {
+            "!type": "fn(options: ?)",
+            prototype: {
+              "!proto": "events.EventEmitter.prototype",
+              connect: {
+                "!type": "fn(options: ?, connectionListener?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketconnectoptions-connectlistener",
+                "!doc": "Creates a new socket object and automatically connects with the supplied options."
+              },
+              destroy: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketdestroy",
+                "!doc": "Ensures that no more I/O activity happens on the socket and destroys the socket as soon as possible."
+              },
+              end: {
+                "!type": "fn(data?: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketenddata-callback",
+                "!doc": "Half-closes the socket. The socket is no longer writable. If data is given it is equivalent to socket.write(data) followed by socket.end()."
+              },
+              pause: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketpause",
+                "!doc": "Pauses reading data."
+              },
+              resume: {
+                "!type": "fn()",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketresume",
+                "!doc": "Resumes reading data after a call to pause()."
+              },
+              setKeepAlive: {
+                "!type": "fn(enable?: bool, initialDelay?: number)",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketsetkeepaliveenable-initialdelay",
+                "!doc": "Enables or disables keep-alive functionality."
+              },
+              setTimeout: {
+                "!type": "fn(timeout: number, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketsettimeouttimeout-callback",
+                "!doc": "Sets timeout for the socket. If the socket is inactive for timeout milliseconds, 'timeout' event will emit."
+              },
+              write: {
+                "!type": "fn(data: +Buffer, callback?: fn())",
+                "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#socketwritedata-callback",
+                "!doc": "Sends data on the socket. The optional callback function will be called after the given data is flushed through the connection."
+              }
+            },
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Net.md#new-netsocketoptions",
+            "!doc": "Construct a new socket object. The options object specifies only the following information: allowHalfOpen {boolean}."
+          }
+        },
+        process: {
+          arch: {
+            "!type": "string",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processarch",
+            "!doc": "The arch property returns the processor architecture identifier that the IoT.js process is currently running on. For instance 'arm', 'ia32', 'x64', or 'unknown'."
+          },
+          argv: {
+            "!type": "[string]",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processargv",
+            "!doc": "The argv property returns an array containing the command line arguments passed when the IoT.js process was launched.The first element is the path to the IoT.js program. The second element is the path of the JavaScript file currently being executed. The remaining elements will be any additional arguments passed via command line."
+          },
+          env: {
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processenv",
+            "!doc": "The env property returns an object containing a few environment variables."
+          },
+          exitCode: {
+            "!type": "number",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processexitcode",
+            "!doc": "The exitCode property can be used to specify the exit code of the IoT.js process. This will be used when the process exits gracefully, or exited via process.exit() without specifying an exit code."
+          },
+          iotjs: {
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processiotjs",
+            "!doc": "The iotjs property holds IoT.js related information in an object."
+          },
+          platform: {
+            "!type": "string",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processplatform",
+            "!doc": "The platform returns the identification of the operating system the IoT.js process is currently running on. For instance 'linux', 'darwin', 'nuttx', 'tizenrt', or 'unknown'."
+          },
+          chdir: {
+            "!type": "fn(path: string)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processchdirpath",
+            "!doc": "The chdir method changes the current working directory of the IoT.js process or throws an exception if the operation fails (for instance the path specified does not exist)."
+          },
+          cwd: {
+            "!type": "fn()",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processcwd",
+            "!doc": "The cwd() call returns the current working directory of the IoT.js process."
+          },
+          exit: {
+            "!type": "fn(code?: number)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processexitcode-1",
+            "!doc": "The exit() method instructs the IoT.js to terminate the process synchronously with an exit status of code. If code is not specified, exit uses the process.exitCode value which defaults to 0. IoT.js will not exit till all 'exit' event listeners are called."
+          },
+          nextTick: {
+            "!type": "fn(callback: fn())",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processnexttickcallback-args",
+            "!doc": "The nextTick method adds the callback method to the 'next tick queue'. Once the current turn of the event loop is completed, all callbacks currently in the next tick queue will be called."
+          },
+          version: {
+            "!type": "string",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Process.md#processversion",
+            "!doc": "The version property returns the version numbering of the currently running IoT.js process as a string."
+          }
+        },
+        timers: {
+          setTimeout: {
+            "!type": "fn(callback: fn(), delay: number) -> timers.Timer",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#settimeoutcallback-delay-args",
+            "!doc": "Schedules execution of a one-time callback after delay milliseconds. Returns a Timeout for use with clearTimeout(). If callback is not a function, a TypeError will be thrown."
+          },
+          clearTimeout: {
+            "!type": "fn(timeout: timers.Timer)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#cleartimeouttimeout",
+            "!doc": "Cancels a Timeout object created by setTimeout()."
+          },
+          setInterval: {
+            "!type": "fn(callback: fn(), delay: number) -> timers.Timer",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#setintervalcallback-delay-args",
+            "!doc": "Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It's never less than ms but it may be longer."
+          },
+          clearInterval: {
+            "!type": "fn(timeout: timers.Timer)",
+            "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#clearintervaltimeout",
+            "!doc": "Cancels a Timeout object created by setInterval()."
+          },
+          Timer: {
+            unref: {
+              "!type": "fn()",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#timeoutref",
+              "!doc": "When called, requests that the IoT.js event loop should not exit as long as the Timeout is active."
+            },
+            ref: {
+              "!type": "fn()",
+              "!url": "https://github.com/Samsung/iotjs/blob/master/docs/api/IoT.js-API-Timers.md#timeoutunref",
+              "!doc": "When called, the active Timeout object will not force the IoT.js event loop to remain active. If there are no other scheduled activites, the process may exit, the process may exit before the Timeout object's callback is invoked."
+            }
+          }
+        },
+        setTimeout: "timers.setTimeout",
+        clearTimeout: "timers.clearTimeout",
+        setInterval: "timers.setInterval",
+        clearInterval: "timers.clearInterval",
+      }
+    };
+  });
+
\ No newline at end of file
-- 
2.7.4

