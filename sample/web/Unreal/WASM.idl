/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum ESlateShaderResource_Type {
  "ESlateShaderResource::NativeTexture",
  "ESlateShaderResource::TextureObject",
  "ESlateShaderResource::Material",
  "ESlateShaderResource::Invalid"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FSlateShaderResource {
  long GetWidth();
  long GetHeight();
  ESlateShaderResource_Type GetType();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ISlateAtlasProvider {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FCurveSequence {
  void FCurveSequence();
};

// TODO: not important right now...
// FCurveSequence implements TSharedFromThis<FCurveSequence>
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FMargin {
  void FMargin();
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FSlateRect {
  attribute float Left;
  attribute float Top;
  attribute float Right;
  attribute float Bottom;

  void FSlateRect(float InLeft, float InTop, float InRight, float InBottom);
  void FSlateRect([Const, Ref] FVector2D InStartPos, [Const, Ref] FVector2D InEndPos);
  [Value] static FSlateRect FromPointAndExtent([Const, Ref] FVector2D TopLeft, [Const, Ref] FVector2D Size);
  boolean IsValid();
  boolean IsEmpty();
  [Value] FVector2D GetSize();
  [Value] FVector2D GetCenter();
  [Value] FVector2D GetTopLeft();
  [Value] FVector2D GetTopRight();
  [Value] FVector2D GetBottomRight();
  [Value] FVector2D GetBottomLeft();
  [Value] FSlateRect InsetBy([Const, Ref] FMargin InsetAmount);
  [Value] FSlateRect ExtendBy([Const, Ref] FMargin ExtendAmount);
  [Value] FSlateRect OffsetBy([Const, Ref] FVector2D OffsetAmount);
  [Value] FSlateRect Expand([Const, Ref] FSlateRect Other);
  [Value] FSlateRect IntersectionWith([Const, Ref] FSlateRect Other);
  [Value] FSlateRect IntersectionWith([Const, Ref] FSlateRect Other, boolean OutOverlapping);
  boolean ContainsPoint([Const, Ref] FVector2D Point);
  static boolean DoRectanglesIntersect([Const, Ref] FSlateRect A, [Const, Ref] FSlateRect B);
  static boolean IsRectangleContained([Const, Ref] FSlateRect A, [Const, Ref] FSlateRect B);
  [Value] FString ToString();
  boolean InitFromString([Const, Ref] FString InSourceString);

  // TODO: operators not supported
  // bool operator!=( const FSlateRect& Other ) const
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FGeometry {
  void FGeometry();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FSlateWindowElementList {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FSlateLayoutTransform {
  void FSlateLayoutTransform(float InScale, [Const, Ref] FVector2D InTranslation);
  void FSlateLayoutTransform([Const, Ref] FVector2D InTranslation);
  [Const, Ref] FVector2D GetTranslation();
  float GetScale();
  [Value] FMatrix ToMatrix();
  [Value] FVector2D TransformPoint([Const, Ref] FVector2D Point);
  [Value] FVector2D TransformVector([Const, Ref] FVector2D Vector);
  [Value] FSlateLayoutTransform Concatenate([Const, Ref] FSlateLayoutTransform RHS);
  [Value] FSlateLayoutTransform Inverse();

  // TODO: operators not supported
  // boolean operator==([Const, Ref] FSlateLayoutTransform Other);
  // boolean operator!=([Const, Ref] FSlateLayoutTransform Other);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FPaintArgs {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FOptionalSize {
  void FOptionalSize();
  void FOptionalSize([Const] float SpecifiedSize);
  boolean IsSet();
  float Get();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FWidgetStyle {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FButtonStyle {
  void FButtonStyle();
};

// TODO: complicated and not needed now
// FButtonStyle implements FSlateWidgetStyle;
[NoDelete]
interface SWidget {
  void Construct(
    [Const, Ref] TAttributeFText InToolTipText,
    [Const, Ref] TSharedPtrIToolTip InToolTip,
    [Const, Ref] TAttributeTOptionalEMouseCursorType InCursor,
    [Const, Ref] TAttributebool InEnabledState,
    [Const, Ref] TAttributeEVisibility InVisibility,
    [Const, Ref] TAttributeTOptionalFSlateRenderTransform InTransform,
    [Const, Ref] TAttributeFVector2D InTransformPivot,
    [Const, Ref] FName InTag,
    [Const] boolean InForceVolatile,
    [Const, Ref] TArrayTSharedRefISlateMetaData InMetaData);

  void SWidgetConstruct(
    [Const, Ref] TAttributeFText InToolTipText,
    [Const, Ref] TSharedPtrIToolTip InToolTip,
    [Const, Ref] TAttributeTOptionalEMouseCursorType InCursor,
    [Const, Ref] TAttributebool InEnabledState,
    [Const, Ref] TAttributeEVisibility InVisibility,
    [Const, Ref] TAttributeTOptionalFSlateRenderTransform InTransform,
    [Const, Ref] TAttributeFVector2D InTransformPivot,
    [Const, Ref] FName InTag,
    [Const] boolean InForceVolatile,
    [Const, Ref] TArrayTSharedRefISlateMetaData InMetaData);

  long Paint(
    [Const, Ref] FPaintArgs Args,
    [Const, Ref] FGeometry AllottedGeometry,
    [Const, Ref] FSlateRect MyClippingRect,
    [Ref] FSlateWindowElementList OutDrawElements,
    long LayerId,
    [Const, Ref] FWidgetStyle InWidgetStyle,
    boolean bParentEnabled);

  void Tick(
    [Const, Ref] FGeometry AllottedGeometry,
    [Const] double InCurrentTime,
    [Const] float InDeltaTime);

  [Value] FReply OnFocusReceived(
    [Const, Ref] FGeometry MyGeometry,
    [Const, Ref] FFocusEvent InFocusEvent);

  void OnFocusLost([Const, Ref] FFocusEvent InFocusEvent);

  void OnFocusChanging(
    [Const, Ref] FWeakWidgetPath PreviousFocusPath,
    [Const, Ref] FWidgetPath NewWidgetPath,
    [Const, Ref] FFocusEvent InFocusEvent);

  [Value] FReply OnKeyChar([Const, Ref] FGeometry MyGeometry, [Const, Ref] FCharacterEvent InCharacterEvent);
  [Value] FReply OnPreviewKeyDown([Const, Ref] FGeometry MyGeometry, [Const, Ref] FKeyEvent InKeyEvent);
  [Value] FReply OnKeyDown([Const, Ref] FGeometry MyGeometry, [Const, Ref] FKeyEvent InKeyEvent);
  [Value] FReply OnKeyUp([Const, Ref] FGeometry MyGeometry, [Const, Ref] FKeyEvent InKeyEvent);
  [Value] FReply OnAnalogValueChanged([Const, Ref] FGeometry MyGeometry, [Const, Ref] FAnalogInputEvent InAnalogInputEvent);
  [Value] FReply OnMouseButtonDown([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  [Value] FReply OnPreviewMouseButtonDown([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  [Value] FReply OnMouseButtonUp([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  [Value] FReply OnMouseMove([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  void OnMouseEnter([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  void OnMouseLeave([Const, Ref] FPointerEvent MouseEvent);
  [Value] FReply OnMouseWheel([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  [Value] FCursorReply OnCursorQuery([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent CursorEvent);
  [Value] FReply OnMouseButtonDoubleClick([Const, Ref] FGeometry InMyGeometry, [Const, Ref] FPointerEvent InMouseEvent);
  boolean OnVisualizeTooltip([Const, Ref] TSharedPtrSWidget TooltipContent);
  [Value] TSharedPtrFPopupLayer OnVisualizePopup([Const, Ref] TSharedRefSWidget PopupContent);
  [Value] FReply OnDragDetected([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent MouseEvent);
  void OnDragEnter([Const, Ref] FGeometry MyGeometry, [Const, Ref] FDragDropEvent DragDropEvent);
  void OnDragLeave([Const, Ref] FDragDropEvent DragDropEvent);
  [Value] FReply OnDragOver([Const, Ref] FGeometry MyGeometry, [Const, Ref] FDragDropEvent DragDropEvent);
  [Value] FReply OnDrop([Const, Ref] FGeometry MyGeometry, [Const, Ref] FDragDropEvent DragDropEvent);
  [Value] FReply OnTouchGesture([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent GestureEvent);
  [Value] FReply OnTouchStarted([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent InTouchEvent);
  [Value] FReply OnTouchMoved([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent InTouchEvent);
  [Value] FReply OnTouchEnded([Const, Ref] FGeometry MyGeometry, [Const, Ref] FPointerEvent InTouchEvent);
  [Value] FReply OnMotionDetected([Const, Ref] FGeometry MyGeometry, [Const, Ref] FMotionEvent InMotionEvent);
  [Value] TOptionalbool OnQueryShowFocus([Const, Ref] EFocusCause InFocusCause);
  [Value] FPopupMethodReply OnQueryPopupMethod();
  [Value] TSharedPtrFVirtualPointerPosition TranslateMouseCoordinateFor3DChild(
    [Const, Ref] TSharedRefSWidget ChildWidget,
    [Const, Ref] FGeometry MyGeometry,
    [Const, Ref] FVector2D ScreenSpaceMouseCoordinate,
    [Const, Ref] FVector2D LastScreenSpaceMouseCoordinate);
  void OnFinishedPointerInput();
  void OnFinishedKeyInput();
  [Value] FNavigationReply OnNavigation([Const, Ref] FGeometry MyGeometry, [Const, Ref] FNavigationEvent InNavigationEvent);
  EWindowZone_Type GetWindowZoneOverride();
  void SlatePrepass();
  void SlatePrepass(float LayoutScaleMultiplier);
  [Const, Ref] FVector2D GetDesiredSize();
  float GetRelativeLayoutScale([Const, Ref] FSlotBase Child);
  void ArrangeChildren([Const, Ref] FGeometry AllottedGeometry, [Ref] FArrangedChildren ArrangedChildren);
  FChildren GetChildren();
  boolean SupportsKeyboardFocus();
  boolean HasKeyboardFocus();
  [Value] TOptionalEFocusCause HasUserFocus(long UserIndex);
  [Value] TOptionalEFocusCause HasAnyUserFocus();
  boolean HasUserFocusedDescendants(long UserIndex);
  boolean HasFocusedDescendants();
  boolean HasAnyUserFocusOrFocusedDescendants();
  boolean HasMouseCapture();
  boolean HasMouseCaptureByUser(long UserIndex, [Ref] TOptionalint32 PointerIndex);
  boolean HasMouseCaptureByUser(long UserIndex);
  void OnMouseCaptureLost();
  void TickWidgetsRecursively([Const, Ref] FGeometry AllottedGeometry, [Const] double InCurrentTime, [Const] float InDeltaTime);
  void SetEnabled([Const, Ref] TAttributebool InEnabledState);
  boolean IsEnabled();
  boolean IsInteractable();
  [Value] TSharedPtrIToolTip GetToolTip();
  void OnToolTipClosing();
  void EnableToolTipForceField([Const] boolean bEnableForceField);
  boolean HasToolTipForceField();
  boolean IsHovered();
  boolean IsDirectlyHovered();
  [Value] EVisibility GetVisibility();
  void SetVisibility([Ref] TAttributeEVisibility InVisibility);
  boolean IsVolatile();
  boolean IsVolatileIndirectly();
  void ForceVolatile(boolean bForce);
  void Invalidate([Ref] EInvalidateWidget Invalidate);
  void CacheVolatility();
  [Const, Ref] TOptionalFSlateRenderTransform GetRenderTransform();
  void SetRenderTransform([Ref] TAttributeTOptionalFSlateRenderTransform InTransform);
  [Const, Ref] FVector2D GetRenderTransformPivot();
  void SetRenderTransformPivot([Ref] TAttributeFVector2D InTransformPivot);
  void SetToolTipText([Const, Ref] TAttributeFText ToolTipText);
  void SetToolTip([Const, Ref] TSharedPtrIToolTip InToolTip);
  void SetCursor([Const, Ref] TAttributeTOptionalEMouseCursorType InCursor);
  void SetOnMouseButtonDown([Ref] FPointerEventHandler EventHandler);
  void SetOnMouseButtonUp([Ref] FPointerEventHandler EventHandler);
  void SetOnMouseMove([Ref] FPointerEventHandler EventHandler);
  void SetOnMouseDoubleClick([Ref] FPointerEventHandler EventHandler);
  [Value] FString ToString();
  [Value] FString GetTypeAsString();
  [Value] FName GetType();
  [Value] FString GetReadableLocation();
  [Value] FName GetCreatedInLocation();
  [Value] FName GetTag();
  [Value] FSlateColor GetForegroundColor();

/* TODO */
/* An appropriate string type? */
  void SetDebugInfo([Const] ANSICHAR InType, [Const] ANSICHAR InFile, long OnLine);

/* Overload with the same number of args */
  // void SetToolTipText([Const, Ref] FText InToolTipText);

/* Templates */
  //template<typename MetaDataType>
  //TSharedPtr<MetaDataType> GetMetaData() const
  //template<typename MetaDataType>
  //TArray<TSharedRef<MetaDataType>> GetAllMetaData() const
  //template<typename MetaDataType>
  //void AddMetadata(const TSharedRef<MetaDataType>& AddMe)
};

SWidget implements FSlateControlledConstruction;
SWidget implements TSharedFromThisSWidget;

interface FSlateControlledConstruction { };
[NoDelete]
interface TSharedFromThisSWidget { };
interface TAttributeFText { };
interface TSharedPtrIToolTip { };
interface TAttributeTOptionalEMouseCursorType { };
interface TAttributebool { };
interface TAttributeEVisibility { };
interface TAttributeTOptionalFSlateRenderTransform { };
interface TAttributeFVector2D { };
interface TArrayTSharedRefISlateMetaData { };
interface FFocusEvent { };
interface FReply { };
interface FWeakWidgetPath { };
interface FWidgetPath { };
interface FCharacterEvent { };
interface FKeyEvent { };
interface FAnalogInputEvent { };
interface FCursorReply { };
interface FDragDropEvent { };
interface FMotionEvent { };
interface EFocusCause { };
interface TOptionalbool { };
interface FPopupMethodReply { };
interface TSharedPtrFVirtualPointerPosition { };
interface FNavigationEvent { };
interface FNavigationReply { };
interface FSlotBase { };
interface FArrangedChildren { };
[NoDelete]
interface FChildren { };
interface TOptionalEFocusCause { };
interface EVisibility { };
interface TOptionalFSlateRenderTransform { };
interface EInvalidateWidget { };
interface FPointerEventHandler { };
interface ANSICHAR { };
interface FSlateColor { };
interface TOptionalint32 { };
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TSharedPtrFGenericWindow {
};

interface TSharedPtrSWindow {
};

interface TSharedPtrSWidget {
};

interface TSharedPtrIWindowTitleBar {
};

interface TSharedPtrISlateViewport {
};

interface TSharedRefFHittestGrid {
};

interface TSharedPtrFPopupLayer {
};

interface TSlotBaseFPopupLayerSlot {
};

interface TSharedRefFGenericWindow {
};

interface TSharedRefSWindow {
};

interface TSharedRefSWidget {
};

interface TSharedRefISlateViewport {
};

interface TArrayTSharedRefSWindow {
};

interface FOnWindowActivatedEvent {
};

interface FOnWindowDeactivatedEvent {
};

interface FOnWindowClosed {
};

interface FOnWindowMoved {
};

interface FOnSwitchWorldHack {
};

interface FRequestDestroyWindowOverride {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum ESizingRule_Type {
  "ESizingRule::FixedSize",
  "ESizingRule::Autosized",
  "ESizingRule::UserSized"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="SWindow::"]
interface FArguments {
};

interface FPopupLayerSlot{
};

FPopupLayerSlot implements TSlotBaseFPopupLayerSlot;

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface SWindow {
  [Value] attribute FVector2D MoveResizeStart;
  [Value] attribute FSlateRect MoveResizeRect;
  attribute EWindowZone_Type MoveResizeZone;

  void Construct([Const, Ref] FArguments InArgs);
  [Value] static FVector2D ComputeWindowSizeForContent([Ref] FVector2D ContentSize);
  EWindowType GetType();
  EWindowTransparency GetTransparencySupport();
  [Value] FText GetTitle();
  void SetTitle([Const, Ref] FText InTitle);
  [Value] FVector2D GetDesiredSizeDesktopPixels();
  [Value] FVector2D GetInitialDesiredSizeInScreen();
  [Value] FVector2D GetInitialDesiredPositionInScreen();
  [Value] FGeometry GetWindowGeometryInScreen();
  [Value] FGeometry GetWindowGeometryInWindow();
  [Value] FOptionalSize GetTitleBarSize();
  [Value] FSlateLayoutTransform GetLocalToScreenTransform();
  [Value] FSlateLayoutTransform GetLocalToWindowTransform();
  [Value] FVector2D GetPositionInScreen();
  [Value] FVector2D GetSizeInScreen();
  [Value] FSlateRect GetNonMaximizedRectInScreen();
  [Value] FSlateRect GetRectInScreen();
  [Value] FSlateRect GetClientRectInScreen();
  [Value] FVector2D GetClientSizeInScreen();
  [Value] FSlateRect GetClippingRectangleInWindow();
  [Value] FMargin GetWindowBorderSize(boolean bIncTitleBar);
  void MoveWindowTo([Ref] FVector2D NewPosition);
  void ReshapeWindow([Ref] FVector2D NewPosition, [Ref] FVector2D NewSize);
  void ReshapeWindow([Const, Ref] FSlateRect InNewShape);
  void Resize([Ref] FVector2D NewSize);
  [Value] FSlateRect GetFullScreenInfo();
  boolean IsMorphing();
  boolean IsMorphingSize();
  void MorphToPosition(
      [Const, Ref] FCurveSequence Sequence,
      [Const] float TargetOpacity,
      [Const, Ref] FVector2D TargetPosition);
  void MorphToShape(
      [Const, Ref] FCurveSequence Sequence,
      [Const] float TargetOpacity,
      [Const, Ref] FSlateRect TargetShape);
  void UpdateMorphTargetShape([Const, Ref] FSlateRect TargetShape);
  void UpdateMorphTargetPosition([Const, Ref] FVector2D TargetPosition);
  [Value] FVector2D GetMorphTargetPosition();
  [Value] FSlateRect GetMorphTargetShape();
  void FlashWindow();
  void BringToFront(boolean bForce);
  void HACK_ForceToFront();
  void SetCachedScreenPosition([Ref] FVector2D NewPosition);
  void SetCachedSize([Ref] FVector2D NewSize);
  [Value] TSharedPtrFGenericWindow GetNativeWindow();
  boolean IsDescendantOf([Const, Ref] TSharedPtrSWindow ParentWindow);
  void SetNativeWindow([Ref] TSharedRefFGenericWindow InNativeWindow);
  void SetContent([Ref] TSharedRefSWidget InContent);
  boolean HasOverlay();
  void RemoveOverlaySlot([Const, Ref] TSharedRefSWidget InContent);
  void RemovePopupLayerSlot([Const, Ref] TSharedRefSWidget WidgetToRemove);
  void SetFullWindowOverlayContent([Ref] TSharedPtrSWidget InContent);
  void BeginFullWindowOverlayTransition();
  void EndFullWindowOverlayTransition();
  boolean HasFullWindowOverlayContent();
  boolean AppearsInTaskbar();
  [Ref] FOnWindowActivatedEvent GetOnWindowActivatedEvent();
  void RequestDestroyWindow();
  void DestroyWindowImmediately();
  void NotifyWindowBeingDestroyed();
  void ShowWindow();
  void HideWindow();
  void EnableWindow(boolean bEnable);
  boolean IsVisible();
  boolean IsWindowMaximized();
  boolean IsWindowMinimized();
  void InitialMaximize();
  void InitialMinimize();
  void SetOpacity([Const] float InOpacity);
  float GetOpacity();
  void SetWidgetToFocusOnActivate([Ref] TSharedPtrSWidget InWidget);
  boolean ActivateWhenFirstShown();
  boolean AcceptsInput();
  boolean IsUserSized();
  boolean IsAutosized();
  void SetSizingRule(ESizingRule_Type InSizingRule);
  boolean IsRegularWindow();
  boolean IsTopmostWindow();
  boolean SizeWillChangeOften();
  boolean ShouldPreserveAspectRatio();
  long GetExpectedMaxWidth();
  long GetExpectedMaxHeight();
  [Value] FString ToString();
  boolean HasOSWindowBorder();
  boolean IsScreenspaceMouseWithin([Ref] FVector2D ScreenspaceMouseCoordinate);
  boolean HasSizingFrame();
  boolean HasCloseBox();
  boolean HasMaximizeBox();
  boolean HasMinimizeBox();
  void SetAsModalWindow();
  boolean IsModalWindow();
  void SetMirrorWindow(boolean bSetMirrorWindow);
  boolean IsVirtualWindow();
  boolean IsMirrorWindow();
  void Maximize();
  void Restore();
  void Minimize();
  long GetCornerRadius();
  boolean SupportsKeyboardFocus();
  [Value] FVector2D GetWindowSizeFromClientSize([Ref] FVector2D InClientSize);
  boolean IsFocusedInitially();
  long SwitchWorlds(long WorldId);
  boolean IsActive();
  boolean HasActiveChildren();
  boolean HasActiveParent();
  void SetViewportSizeDrivenByWindow(boolean bDrivenByWindow);
  boolean IsViewportSizeDrivenByWindow();
  [Value] FVector2D GetViewportSize();
  void SetIndependentViewportSize([Const, Ref] FVector2D VP);
  [Value] TSharedPtrSWindow GetParentWindow();
  [Value] TSharedPtrSWindow GetTopmostAncestor();
  void AddChildWindow([Const, Ref] TSharedRefSWindow ChildWindow);
  boolean RemoveDescendantWindow([Const, Ref] TSharedRefSWindow DescendantToRemove);
  void SetWindowMode(EWindowMode_Type WindowMode);
  EWindowMode_Type GetWindowMode();
  EWindowZone_Type GetCurrentWindowZone([Ref] FVector2D LocalMousePosition);
  [Value] TSharedPtrISlateViewport GetViewport();
  [Value] TSharedRefFHittestGrid GetHittestGrid();
  [Value] FWindowSizeLimits GetSizeLimits();
  [Ref] FPopupLayerSlot AddPopupLayerSlot();
  [Value] TSharedPtrFPopupLayer OnVisualizePopup([Const, Ref] TSharedRefSWidget PopupContent);
  [Const, Ref] TArrayTSharedRefSWindow GetChildWindows();
  [Ref] FOnWindowDeactivatedEvent GetOnWindowDeactivatedEvent();
  void SetOnWindowClosed([Const, Ref] FOnWindowClosed InDelegate);
  void SetOnWindowMoved([Const, Ref] FOnWindowMoved InDelegate);
  void SetRequestDestroyWindowOverride([Const, Ref] FRequestDestroyWindowOverride InDelegate);
  void SetViewport([Ref] TSharedRefISlateViewport ViewportRef);
  boolean OnIsActiveChanged([Const, Ref] FWindowActivateEvent ActivateEvent);
  void SetTitleBar([Const, Ref] TSharedPtrIWindowTitleBar InTitleBar);
  [Ref] FOverlaySlot AddOverlaySlot([Const] long ZOrder);
  void SetOnWorldSwitchHack([Ref] FOnSwitchWorldHack InOnWorldSwitchHack);
  long PaintWindow(
      [Ref] FPaintArgs Args,
      [Const, Ref] FGeometry AllottedGeometry,
      [Const, Ref] FSlateRect MyClippingRect,
      [Ref] FSlateWindowElementList OutDrawElements,
      long LayerId,
      [Const, Ref] FWidgetStyle InWidgetStyle,
      boolean bParentEnabled);
  void Tick(
      [Const, Ref] FGeometry AllottedGeometry,
      [Const] double InCurrentTime,
      [Const] float InDeltaTime);

  // TODO: calling a private constructor of class 'FCursorReply'
  // [Value] FCursorReply OnCursorQuery(
  //     [Const, Ref] FGeometry MyGeometry,
  //     [Const, Ref] FPointerEvent CursorEvent);

  // TODO: 'operator new' is a private member of 'FSlateControlledConstruction'
  // void SWindow();
  // [Value] static TSharedRefSWindow MakeToolTipWindow();
  // [Value] static TSharedRefSWindow MakeCursorDecorator();
  // [Value] static TSharedRefSWindow MakeNotificationWindow();

  // TODO: allocating an object of abstract class type 'const SWidget'
  // [Value] TSharedRefConstSWidget GetContent();

  // TODO: Signatures with 0 arguments for method 'GetNativeWindow' are not distinguishable
  // [Value] TSharedPtrConstFGenericWindow GetNativeWindow();

  // TODO: function overloads are not supported
  // [Ref] TArrayTSharedRefSWindow GetChildWindows();
};

SWindow implements SCompoundWidget;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="SOverlay::"]
interface FOverlaySlot {
};

// TODO: not needed now, can be exported later
// SOverlay implements SPanel;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface SCompoundWidget {
};

SCompoundWidget implements SWidget;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TArrayFCompositeSubFont {
};

interface TArrayFTypefaceEntry {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EFontHinting {
  "EFontHinting::Default",
  "EFontHinting::Auto",
  "EFontHinting::AutoLight",
  "EFontHinting::Monochrome",
  "EFontHinting::None"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FFontData {
  void FFontData();
  void FFontData(
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
  void SetFont([Ref] FString InFontFilename, [Const] UFontBulkData InBulkData);
  [Operator="=="] boolean equal([Const, Ref] FFontData Other);
  [Operator="!="] boolean not_equal([Const, Ref] FFontData Other);
  [Value] attribute FString FontFilename;
  [Const] readonly attribute UFontBulkData BulkDataPtr;
  attribute EFontHinting Hinting;
  [Value] attribute TArrayuint8 FontData_DEPRECATED;
};

interface FTypefaceEntry {
  void FTypefaceEntry();
  void FTypefaceEntry([Const, Ref] FName InFontName);
  void FTypefaceEntry(
      [Const, Ref] FName InFontName,
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
  [Value] attribute FName Name;
  [Value] attribute FFontData Font;
};

interface FTypeface {
  void FTypeface();
  void FTypeface(
      [Const, Ref] FName InFontName,
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
  [Ref] FTypeface AppendFont(
      [Const, Ref] FName InFontName,
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
  [Value] attribute TArrayFTypefaceEntry Fonts;
};

interface FCompositeSubFont {
  void FCompositeSubFont();
  [Value] attribute FTypeface Typeface;
  [Value] attribute TArrayFInt32Range CharacterRanges;
  attribute float ScalingFactor;
};

interface FCompositeFont {
  void FCompositeFont();
  void FCompositeFont(
      [Const, Ref] FName InFontName,
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
  void MakeDirty();
  [Value] attribute FTypeface DefaultTypeface;
  [Value] attribute TArrayFCompositeSubFont SubTypefaces;
  attribute long HistoryRevision;
};

interface FStandaloneCompositeFont {
  void FStandaloneCompositeFont();
  void FStandaloneCompositeFont(
      [Const, Ref] FName InFontName,
      [Ref] FString InFontFilename,
      [Const] UFontBulkData InBulkData,
      [Const] EFontHinting InHinting);
};

FStandaloneCompositeFont implements FCompositeFont;
FStandaloneCompositeFont implements FGCObject;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TSharedPtrFShapedGlyphFaceData {
};

interface TArrayFShapedGlyphEntry {
};

interface TOptionalFGlyphOffsetResult {
};

interface TOptionalint8 {
};

interface FShapedGlyphSequencePtr {
};

interface TArrayTWeakPtrFFreeTypeFace {
};

interface TSharedRefISlateFontAtlasFactory {
};

interface TSetFName {
};

interface TCHAR {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EFontCacheAtlasDataType {
  "EFontCacheAtlasDataType::Regular",
  "EFontCacheAtlasDataType::Outline",
  "EFontCacheAtlasDataType::Num"
};

enum ETextShapingMethod {
  "ETextShapingMethod::Auto",
  "ETextShapingMethod::KerningOnly",
  "ETextShapingMethod::FullShaping"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FShapedGlyphFontAtlasData {
  attribute long VerticalOffset;
  attribute long HorizontalOffset;
  attribute unsigned long StartU;
  attribute unsigned long StartV;
  attribute unsigned long USize;
  attribute unsigned long VSize;
  attribute octet TextureIndex;
  attribute boolean Valid;

  void FShapedGlyphFontAtlasData();
};

interface FShapedGlyphEntry {
  [Value] attribute TSharedPtrFShapedGlyphFaceData FontFaceData;
  attribute unsigned long GlyphIndex;
  attribute long SourceIndex;
  attribute long XAdvance;
  attribute long YAdvance;
  attribute long XOffset;
  attribute long YOffset;
  attribute byte Kerning;
  attribute octet NumCharactersInGlyph;
  attribute octet NumGraphemeClustersInGlyph;
  attribute TextBiDi_ETextDirection TextDirection;
  attribute boolean bIsVisible;

  void FShapedGlyphEntry();
};

interface FShapedGlyphEntryKey {
  void FShapedGlyphEntryKey(
      [Const, Ref] TSharedPtrFShapedGlyphFaceData InFontFaceData,
      unsigned long InGlyphIndex,
      [Const, Ref] FFontOutlineSettings InOutlineSettings);
  [Operator="=="] boolean equal([Const, Ref] FShapedGlyphEntryKey Other);
  [Operator="!="] boolean not_equal([Const, Ref] FShapedGlyphEntryKey Other);
};

interface FShapedGlyphSequence {
  void FShapedGlyphSequence(
      [Ref] TArrayFShapedGlyphEntry InGlyphsToRender,
      [Const] long InTextBaseline,
      [Const] unsigned long InMaxTextHeight,
      [Const] UObject InFontMaterial,
      [Const, Ref] FFontOutlineSettings InOutlineSettings,
      [Const, Ref] FSourceTextRange InSourceTextRange);
  unsigned long GetAllocatedSize();
  [Const, Ref] TArrayFShapedGlyphEntry GetGlyphsToRender();
  long GetTextBaseline();
  unsigned long GetMaxTextHeight();
  [Const] UObject GetFontMaterial();
  [Const, Ref] FFontOutlineSettings GetFontOutlineSettings();
  boolean IsDirty();
  [Value] TOptionalint32 GetMeasuredWidth(
      [Const] long InStartIndex,
      [Const] long InEndIndex,
      [Const] boolean InIncludeKerningWithPrecedingGlyph);
  [Value] TOptionalFGlyphOffsetResult GetGlyphAtOffset(
      [Ref] FSlateFontCache InFontCache,
      [Const] long InStartIndex,
      [Const] long InEndIndex,
      [Const] long InHorizontalOffset,
      [Const] long InStartOffset,
      [Const] boolean InIncludeKerningWithPrecedingGlyph);
  [Value] TOptionalint8 GetKerning([Const] long InIndex);
  [Value] FShapedGlyphSequencePtr GetSubSequence([Const] long InStartIndex, [Const] long InEndIndex);

  // TODO: overloads must have the same return type
  // [Value] FGlyphOffsetResult GetGlyphAtOffset(
  //     [Ref] FSlateFontCache InFontCache,
  //     [Const] long InHorizontalOffset,
  //     [Const] long InStartOffset);

  // TODO: Extended attributes differ on different overloads
  // long GetMeasuredWidth();
};

[Prefix="FShapedGlyphSequence::"]
interface FSourceTextRange {
  attribute long TextStart;
  attribute long TextLen;

  void FSourceTextRange([Const] long InTextStart, [Const] long InTextLen);
};

[Prefix="FShapedGlyphSequence::"]
interface FGlyphOffsetResult {
  [Const] readonly attribute FShapedGlyphEntry Glyph;
  attribute long GlyphOffset;
  attribute long CharacterIndex;

  void FGlyphOffsetResult();
  void FGlyphOffsetResult([Const] long InCharacterIndex);
  void FGlyphOffsetResult([Const] FShapedGlyphEntry InGlyph, [Const] long InGlyphOffset);
};

interface FCharacterEntry {
  [Value] attribute TCHAR Character;
  attribute long GlyphIndex;
  [Const] readonly attribute FFontData FontData;
  attribute float FontScale;
  attribute unsigned long StartU;
  attribute unsigned long StartV;
  attribute unsigned long USize;
  attribute unsigned long VSize;
  attribute long VerticalOffset;
  attribute long HorizontalOffset;
  attribute long GlobalDescender;
  attribute long XAdvance;
  attribute octet TextureIndex;
  attribute boolean HasKerning;
  attribute EFontFallback FallbackLevel;
  attribute boolean Valid;

  void FCharacterEntry();
};

interface FKerningPair {
  [Value] attribute TCHAR First;
  [Value] attribute TCHAR Second;

  void FKerningPair([Ref] DOMString InFirst, [Ref] DOMString InSecond);
  [Operator="=="] boolean equal([Const, Ref] FKerningPair Other);
};

interface FKerningTable {
  void FKerningTable([Const, Ref] FSlateFontCache InFontCache);
  byte GetKerning(
      [Const, Ref] FFontData InFontData,
      [Const] long InSize,
      [Ref] DOMString FirstChar,
      [Ref] DOMString SecondChar,
      float InScale);
  void CreateDirectTable();
};


interface FCharacterList {
  void FCharacterList(
      [Const, Ref] FSlateFontKey InFontKey,
      [Ref] FSlateFontCache InFontCache);
  boolean IsValidIndex([Ref] DOMString Character);
  [Value] FCharacterEntry GetCharacter(
      [Ref] DOMString Character,
      [Const] EFontFallback MaxFontFallback);
  boolean IsStale();
  byte GetKerning(
      [Ref] DOMString FirstChar,
      [Ref] DOMString SecondChar,
      [Const] EFontFallback MaxFontFallback);
  byte GetKerning(
      [Const, Ref] FCharacterEntry FirstCharacterEntry,
      [Const, Ref] FCharacterEntry SecondCharacterEntry);
  unsigned long GetMaxHeight();
  long GetBaseline();
};

interface FSlateFontCache {
  void FSlateFontCache([Ref] TSharedRefISlateFontAtlasFactory InFontAtlasFactory);
  long GetNumAtlasPages();
  [Value] FIntPoint GetAtlasPageSize();
  FSlateShaderResource GetAtlasPageResource([Const] long InIndex);
  boolean IsAtlasPageResourceAlphaOnly();
  [Ref] FCharacterList GetCharacterList(
      [Const, Ref] FSlateFontInfo InFontInfo,
      float FontScale,
      [Const, Ref] FFontOutlineSettings InOutlineSettings);
  [Value] FShapedGlyphFontAtlasData GetShapedGlyphFontAtlasData(
      [Const, Ref] FShapedGlyphEntry InShapedGlyph,
      [Const, Ref] FFontOutlineSettings InOutlineSettings);
  boolean AddNewEntry(
      [Ref] TCHAR Character,
      [Const, Ref] FSlateFontKey InKey,
      [Ref] FCharacterEntry OutCharacterEntry);
  boolean AddNewEntry(
      [Const, Ref] FCharacterRenderData InRenderData,
      octet OutTextureIndex,
      unsigned short OutGlyphX,
      unsigned short OutGlyphY,
      unsigned short OutGlyphWidth,
      unsigned short OutGlyphHeight);
  void FlushObject([Const] UObject InObject);
  void FlushCompositeFont([Const, Ref] FCompositeFont InCompositeFont);
  boolean ConditionalFlushCache();
  void UpdateCache();
  void ReleaseResources();
  FSlateShaderResource GetSlateTextureResource(unsigned long Index);
  FTextureResource GetEngineTextureResource(unsigned long Index);
  [Const, Ref] FFontData GetDefaultFontData([Const, Ref] FSlateFontInfo InFontInfo);
  [Const, Ref] FFontData GetFontDataForCharacter(
      [Const, Ref] FSlateFontInfo InFontInfo,
      [Const, Ref] DOMString InChar,
      float OutScalingFactor);
  unsigned long GetMaxCharacterHeight([Const, Ref] FSlateFontInfo InFontInfo, float FontScale);
  long GetBaseline([Const, Ref] FSlateFontInfo InFontInfo, float FontScale);
  void GetUnderlineMetrics(
      [Const, Ref] FSlateFontInfo InFontInfo,
      [Const] float FontScale,
      short OutUnderlinePos,
      short OutUnderlineThickness);
  byte GetKerning(
      [Const, Ref] FFontData InFontData,
      [Const] long InSize,
      [Ref] TCHAR First,
      [Ref] TCHAR Second,
      float Scale);
  boolean HasKerning([Const, Ref] FFontData InFontData);
  [Const, Ref] TSetFName GetFontAttributes([Const, Ref] FFontData InFontData);
  unsigned long GetLocalizedFallbackFontRevision();
  void RequestFlushCache();
  void FlushData();

  // TODO: overloading must differentiate by # of arguments
  // boolean AddNewEntry(
  //     [Const, Ref] FShapedGlyphEntry InShapedGlyph,
  //     [Const, Ref] FFontOutlineSettings InOutlineSettings,
  //     [Ref] FShapedGlyphFontAtlasData OutAtlasData);

  // TODO: no matching constructor for initialization of 'const FShapedGlyphSequenceRef'
  // [Value] FShapedGlyphSequenceRef ShapeBidirectionalText(
  //     [Const, Ref] FString InText,
  //     [Const, Ref] FSlateFontInfo InFontInfo,
  //     [Const] float InFontScale,
  //     [Const] TextBiDi_ETextDirection InBaseDirection,
  //     [Const] ETextShapingMethod InTextShapingMethod);
  // [Value] FShapedGlyphSequenceRef ShapeBidirectionalText(
  //     [Const] DOMString InText,
  //     [Const] long InTextStart,
  //     [Const] long InTextLen,
  //     [Const, Ref] FSlateFontInfo InFontInfo,
  //     [Const] float InFontScale,
  //     [Const] TextBiDi_ETextDirection InBaseDirection,
  //     [Const] ETextShapingMethod InTextShapingMethod);
  // [Value] FShapedGlyphSequenceRef ShapeUnidirectionalText(
  //     [Const, Ref] FString InText,
  //     [Const, Ref] FSlateFontInfo InFontInfo,
  //     [Const] float InFontScale,
  //     [Const] TextBiDi_ETextDirection InTextDirection,
  //     [Const] ETextShapingMethod InTextShapingMethod);
  // [Value] FShapedGlyphSequenceRef ShapeUnidirectionalText(
  //     [Const] DOMString InText,
  //     [Const] long InTextStart,
  //     [Const] long InTextLen,
  //     [Const, Ref] FSlateFontInfo InFontInfo,
  //     [Const] float InFontScale,
  //     [Const] TextBiDi_ETextDirection InTextDirection,
  //     [Const] ETextShapingMethod InTextShapingMethod);
};

FSlateFontCache implements ISlateAtlasProvider;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FSlateFontKey {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FCharacterMeasureInfo {
  attribute short SizeX;
  attribute short SizeY;
  attribute short XAdvance;
  attribute short GlobalAscender;
  attribute short GlobalDescender;
  attribute short VerticalOffset;
  attribute short HorizontalOffset;

  void FCharacterMeasureInfo(
      short InSizeX,
      short InSizeY,
      short InXAdvance,
      short InVerticalOffset,
      short InHorizontalOffset);
};

interface FCharacterRenderData {
  attribute short MaxHeight;
  attribute long GlyphIndex;
  attribute boolean HasKerning;
  [Value] attribute TCHAR Char;
  [Value] attribute TArrayuint8 RawPixels;
  [Value] attribute FCharacterMeasureInfo MeasureInfo;
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UFontBulkData {
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TSharedPtrcConstFCompositeFont {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EFontFallback {
  "EFontFallback::FF_NoFallback",
  "EFontFallback::FF_LocalizedFallback",
  "EFontFallback::FF_LastResortFallback",
  "EFontFallback::FF_Max"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FFontOutlineSettings {
  attribute long OutlineSize;
  attribute UObject OutlineMaterial;
  attribute boolean bSeparateFillAlpha;
  [Value] attribute FLinearColor OutlineColor;
  [Value] static attribute FFontOutlineSettings NoOutline;

  void FFontOutlineSettings();
  [Operator="=="] boolean equal([Const, Ref] FFontOutlineSettings Other);
};

interface FSlateFontInfo {
  attribute UObject FontMaterial;
  attribute long Size;
  attribute EFontFallback FontFallback;
  [Const] readonly attribute UObject FontObject;
  [Value] attribute FFontOutlineSettings OutlineSettings;
  [Value] attribute TSharedPtrcConstFCompositeFont CompositeFont;
  [Value] attribute FName TypefaceFontName;

  void FSlateFontInfo();
  void FSlateFontInfo(
      [Const] UObject InFontObject,
      [Const] long InSize,
      [Const, Ref] FName InTypefaceFontName);
  [Operator="=="] boolean equal([Const, Ref] FSlateFontInfo Other);
  [Operator="!="] boolean not_equal([Const, Ref] FSlateFontInfo Other);
  boolean HasValidFont();
  [Const] FCompositeFont GetCompositeFont();
  void PostSerialize([Const, Ref] FArchive Ar);

  // TODO: cannot override constructor
  //FSlateFontInfo([Ref] TSharedPtrFCompositeFont InCompositeFont, [Const] long InSize, [Ref] const FName&);
  //FSlateFontInfo([Const, Ref] FString InFontName, unsigned long InSize, [Ref] EFontHinting InHinting);
  //FSlateFontInfo([Const, Ref] FName InFontName, unsigned long InSize, [Ref] EFontHinting InHinting);
  //FSlateFontInfo([Const] ANSICHAR InFontName, unsigned long InSize, [Ref] EFontHinting InHinting);
  //FSlateFontInfo([Const] WIDECHAR InFontName, unsigned long InSize, [Ref] EFontHinting InHinting);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FWindowActivateEvent {
};

interface FPointerEvent {
};

// TODO: not needed now, can be exported later
// FPointerEvent implements FInputEvent;
enum EMipFadeSettings {
  "EMipFadeSettings::MipFade_Normal",
  "EMipFadeSettings::MipFade_Slow",
  "EMipFadeSettings::MipFade_NumSettings"
};

interface FRenderResource {
  void FRenderResource();
  void FRenderResource(ERHIFeatureLevel_Type InFeatureLevel);
  void InitDynamicRHI();
  void ReleaseDynamicRHI();
  void InitRHI();
  void ReleaseRHI();
  void InitResource();
  void ReleaseResource();
  void UpdateRHI();
  void InitResourceFromPossiblyParallelRendering();
  [Value] FString GetFriendlyName();
  boolean IsInitialized();
  void SetFeatureLevel(ERHIFeatureLevel_Type InFeatureLevel);

  // TODO: some constructors missing due to lack of function overloading
  //static TLinkedList<FRenderResource*>*& GetResourceList();
};

interface FMipBiasFade {
  attribute float TotalMipCount;
  attribute float MipCountDelta;
  attribute float StartTime;
  attribute float MipCountFadingRate;
  attribute float BiasOffset;

  void FMipBiasFade();
  void SetNewMipCount(
    float ActualMipCount,
    float TargetMipCount,
    double LastRenderTime,
    EMipFadeSettings FadeSetting
  );
  float CalcMipBias();
  boolean IsFading();
};

interface FTexture {
  [Value] attribute FTextureRHIRef TextureRHI;
  [Value] attribute FSamplerStateRHIRef SamplerStateRHI;
  [Value] attribute FSamplerStateRHIRef DeferredPassSamplerStateRHI;
  attribute double LastRenderTime;
  [Value] attribute FMipBiasFade MipBiasFade;
  attribute boolean bGreyScaleFormat;
  attribute boolean bIgnoreGammaConversions;
  attribute boolean bSRGB;

  void FTexture();
  long GetSizeX();
  long GetSizeY();
  void ReleaseRHI();
  [Value] FString GetFriendlyName();
};
FTexture implements FRenderResource;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FTextureReference {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRenderCommandFence {
  void FRenderCommandFence();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="FDebugRenderSceneProxy::"]
interface TArrayFDynamicMeshVertex {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="FDebugRenderSceneProxy::"]
interface FMesh {
  void FMesh();
  [Value] attribute TArrayFDynamicMeshVertex Vertices;
  [Value] attribute TArrayint32 Indices;
  [Value] attribute FColor Color;
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FTraceHandle {
};

interface FTraceDatum {
};

interface AsyncTraceData {
};
interface FSkyLightSceneProxy
{
  [Const] attribute USkyLightComponent LightComponent;
  attribute FTexture ProcessedTexture;
  attribute float BlendFraction;
  attribute FTexture BlendDestinationProcessedTexture;
  attribute float SkyDistanceThreshold;
  attribute boolean bCastShadows;
  attribute boolean bWantsStaticShadowing;
  attribute boolean bHasStaticLighting;
  [Value] attribute FLinearColor LightColor;
  [Value] attribute FSHVectorRGB3 IrradianceEnvironmentMap;
  attribute float AverageBrightness;
  attribute float IndirectLightingIntensity;
  attribute float OcclusionMaxDistance;
  attribute float Contrast;
  attribute float MinOcclusion;
  [Value] attribute FLinearColor OcclusionTint;

  void FSkyLightSceneProxy([Const] USkyLightComponent InLightComponent);
  void Initialize(
    float InBlendFraction,
    [Const] FSHVectorRGB3 InIrradianceEnvironmentMap,
    [Const] FSHVectorRGB3 BlendDestinationIrradianceEnvironmentMap,
    [Const] float[] InAverageBrightness,
    [Const] float[] BlendDestinationAverageBrightness
  );
};

interface FLightSceneProxy {
  void FLightSceneProxy([Const] ULightComponent InLightComponent);
  boolean AffectsBounds([Const, Ref] FBoxSphereBounds Bounds);
  [Value] FSphere GetBoundingSphere();
  float GetRadius();
  float GetOuterConeAngle();
  float GetSourceRadius();
  boolean IsInverseSquared();
  float GetLightSourceAngle();
  float GetTraceDistance();
  [Value] FVector2D GetLightShaftConeParams();
  void GetParameters([Ref] FVector4 LightPositionAndInvRadius, [Ref] FVector4 LightColorAndFalloffExponent, [Ref] FVector NormalizedLightDirection, [Ref] FVector2D SpotAngles, float LightSourceRadius, float LightSourceLength, float LightMinRoughness);
  [Value] FVector2D GetDirectionalLightDistanceFadeParameters(ERHIFeatureLevel_Type InFeatureLevel, boolean bPrecomputedLightingIsValid);
  boolean GetLightShaftOcclusionParameters(float OutOcclusionMaskDarkness, float OutOcclusionDepthRange);
  [Value] FVector GetLightPositionForLightShafts([Ref] FVector ViewOrigin);
  boolean ShouldCreatePerObjectShadowsForDynamicObjects();
  boolean UseCSMForDynamicObjects();
  long GetNumViewDependentWholeSceneShadows([Const, Ref] FSceneView View, boolean bPrecomputedLightingIsValid);
  boolean GetViewDependentWholeSceneProjectedShadowInitializer(
    [Const, Ref] FSceneView View,
    long InCascadeIndex,
    boolean bPrecomputedLightingIsValid,
    [Ref] FWholeSceneProjectedShadowInitializer OutInitializer
  );
  boolean GetViewDependentRsmWholeSceneProjectedShadowInitializer(
    [Const, Ref] FSceneView View,
    [Const, Ref] FBox LightPropagationVolumeBounds,
    [Ref] FWholeSceneProjectedShadowInitializer OutInitializer
  );
  boolean GetPerObjectProjectedShadowInitializer([Const, Ref] FBoxSphereBounds SubjectBounds, [Ref] FPerObjectProjectedShadowInitializer OutInitializer);
  [Value] FSphere GetShadowSplitBounds([Const, Ref] FSceneView View, long InCascadeIndex, boolean bPrecomputedLightingIsValid, FShadowCascadeSettings OutCascadeSettings);
  [Value] FSphere GetShadowSplitBoundsDepthRange([Const, Ref] FSceneView View, [Ref] FVector ViewOrigin, float SplitNear, float SplitFar, FShadowCascadeSettings OutCascadeSettings);
  boolean GetScissorRect([Ref] FIntRect ScissorRect, [Const, Ref] FSceneView View);
  void SetScissorRect([Ref] FRHICommandList RHICmdList, [Const, Ref] FSceneView View);
  boolean ShouldCreateRayTracedCascade(ERHIFeatureLevel_Type Type, boolean bPrecomputedLightingIsValid);
  float GetUserShadowBias();

  [Const] ULightComponent GetLightComponent();
  FLightSceneInfo GetLightSceneInfo();
  [Const, Ref] FMatrix GetWorldToLight();
  [Const, Ref] FMatrix GetLightToWorld();
  [Value] FVector GetDirection();
  [Value] FVector GetOrigin();
  [Value] FVector4 GetPosition();
  [Const, Ref] FLinearColor GetColor();
  float GetIndirectLightingScale();
  [Value] FGuid GetLightGuid();
  float GetShadowSharpen();
  float GetContactShadowLength();
  float GetMinRoughness();
  [Value] FVector GetLightFunctionScale();
  float GetLightFunctionFadeDistance();
  float GetLightFunctionDisabledBrightness();
  UTextureLightProfile GetIESTexture();
  FTexture GetIESTextureResource();
  [Const] FMaterialRenderProxy GetLightFunctionMaterial();
  boolean IsMovable();
  boolean HasStaticLighting();
  boolean HasStaticShadowing();
  boolean CastsDynamicShadow();
  boolean CastsStaticShadow();
  boolean CastsTranslucentShadows();
  boolean CastsShadowsFromCinematicObjectsOnly();
  boolean CastsModulatedShadows();
  [Const, Ref] FLinearColor GetModulatedShadowColor();
  boolean AffectsTranslucentLighting();
  boolean UseRayTracedDistanceFieldShadows();
  float GetRayStartOffsetDepthScale();
  octet GetLightType();
  octet GetLightingChannelMask();
  [Value] FName GetComponentName();
  [Value] FName GetLevelName();
  [Value] TStatId GetStatId();
  long GetShadowMapChannel();
  boolean IsUsedAsAtmosphereSunLight();
  long GetPreviewShadowMapChannel();
  boolean HasReflectiveShadowMap();
  boolean NeedsLPVInjection();
  [Const] FStaticShadowDepthMap GetStaticShadowDepthMap();
  void ApplyWorldOffset([Ref] FVector InOffset);
  float GetMaxDrawDistance();
  float GetFadeRange();

  // TODO: need to figure out how to easily export such complicated constructs...
  // bool GetWholeSceneProjectedShadowInitializer([Const, Ref] FSceneViewFamily ViewFamily, TArray<class FWholeSceneProjectedShadowInitializer, TInlineAllocator<6> >& OutInitializers)
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FWholeSceneProjectedShadowInitializer {
  void FWholeSceneProjectedShadowInitializer();
};

interface FPerObjectProjectedShadowInitializer {
  void FPerObjectProjectedShadowInitializer();
};

interface FShadowCascadeSettings {
  void FShadowCascadeSettings();
};

[NoDelete]
interface FLightSceneInfo {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FBaseParticle {
  [Value] attribute FVector OldLocation;
  attribute float RelativeTime;
  [Value] attribute FVector Location;
  attribute float OneOverMaxLifetime;
  [Value] attribute FVector BaseVelocity;
  attribute float Rotation;
  [Value] attribute FVector Velocity;
  attribute float BaseRotationRate;
  [Value] attribute FVector BaseSize;
  attribute float RotationRate;
  [Value] attribute FVector Size;
  attribute long Flags;
  [Value] attribute FLinearColor Color;
  [Value] attribute FLinearColor BaseColor;
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRenderTarget {
};

interface FViewport {
};

FViewport implements FRenderTarget;
interface FPrimitiveComponentId {
  void FPrimitiveComponentId();
  boolean IsValid();
  [Operator="=="] boolean equal([Ref] FPrimitiveComponentId OtherId);
  attribute unsigned long PrimIDValue;
};

enum ELightComponentType {
  "ELightComponentType::LightType_Directional",
  "ELightComponentType::LightType_Point",
  "ELightComponentType::LightType_Spot",
  "ELightComponentType::LightType_MAX",
  "ELightComponentType::LightType_NumBits"
};

enum ELightMapInteractionType {
  "LMIT_None",
  "LMIT_Texture",
  "LMIT_NumBits"
};

enum EMaterialQualityLevel_Type {
  "EMaterialQualityLevel::Low",
  "EMaterialQualityLevel::High",
  "EMaterialQualityLevel::Medium",
  "EMaterialQualityLevel::Num"
};
enum EMaterialValueType {
  "MCT_Float1",
  "MCT_Float2",
  "MCT_Float3",
  "MCT_Float4",
  "MCT_Float",
  "MCT_Texture2D",
  "MCT_TextureCube",
  "MCT_Texture",
  "MCT_StaticBool",
  "MCT_Unknown",
  "MCT_MaterialAttributes"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FMaterialRenderProxy {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FNavigableGeometryExport {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FNavigationRelevantData {
};
interface FTexture2DMipMap {
  void FTexture2DMipMap();
  [Value] attribute FByteBulkData BulkData;
  attribute long SizeX;
  attribute long SizeY;
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FTextureResource {
  void FTextureResource();
};

interface TIndirectArrayTexture2DMipMap {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FAnimNotifyQueue {
};

interface FBlendedCurve {
};
enum EAnimEventTriggerOffsets_Type {
  "EAnimEventTriggerOffsets::OffsetBefore",
  "EAnimEventTriggerOffsets::OffsetAfter",
  "EAnimEventTriggerOffsets::NoOffset"
};

enum EBoneAxis {
  "BA_X",
  "BA_Y",
  "BA_Z"
};

enum EBoneControlSpace {
  "BCS_WorldSpace",
  "BCS_ComponentSpace",
  "BCS_ParentBoneSpace",
  "BCS_BoneSpace",
  "BCS_MAX"
};

enum EBoneRotationSource {
  "BRS_KeepComponentSpaceRotation",
  "BRS_KeepLocalSpaceRotation",
  "BRS_CopyFromTarget"
};

enum EMontageNotifyTickType_Type {
  "EMontageNotifyTickType::Queued",
  "EMontageNotifyTickType::BranchingPoint"
};

enum ENotifyFilterType_Type {
  "ENotifyFilterType::NoFiltering",
  "ENotifyFilterType::LOD"
};

interface FGraphTraversalCounter {
  void FGraphTraversalCounter();

  long Get();
  void Increment();
  void Reset();
  void SynchronizeWith([Const, Ref] FGraphTraversalCounter InMasterCounter);
  boolean IsSynchronizedWith([Const, Ref] FGraphTraversalCounter InMasterCounter);
  boolean WasSynchronizedInTheLastFrame([Const, Ref] FGraphTraversalCounter InMasterCounter);
};

interface FAnimNotifyEvent {
  attribute float DisplayTime_DEPRECATED;
  attribute float TriggerTimeOffset;
  attribute float EndTriggerTimeOffset;
  attribute float TriggerWeightThreshold;
  [Value] attribute FName NotifyName;
  attribute UAnimNotify Notify;
  attribute UAnimNotifyState NotifyStateClass;
  attribute float Duration;
  [Value] attribute FAnimLinkableElement EndLink;
  attribute boolean bConvertedFromBranchingPoint;
  [Value] attribute TEnumAsByteEMontageNotifyTickType MontageTickType;
  attribute float NotifyTriggerChance;
  [Value] attribute TEnumAsByteENotifyFilterType NotifyFilterType;
  attribute long NotifyFilterLOD;
  attribute boolean bTriggerOnDedicatedServer;
  attribute long TrackIndex;
  
  void FAnimNotifyEvent();
  void RefreshTriggerOffset(EAnimEventTriggerOffsets_Type PredictedOffsetType);
  void RefreshEndTriggerOffset(EAnimEventTriggerOffsets_Type PredictedOffsetType);
  float GetTriggerTime();
  float GetEndTriggerTime();
  float GetDuration();
  void SetDuration(float NewDuration);
  boolean IsBranchingPoint();
  
  boolean IsBlueprintNotify();
  void SetTime(float NewTime, EAnimLinkMethod_Type ReferenceFrame);
  // TODO: operators == and < are not supported
  //bool operator ==(const FAnimNotifyEvent& Other);
  //bool operator <(const FAnimNotifyEvent& Other) const;
};
FAnimNotifyEvent implements FAnimLinkableElement;

interface FAnimSyncMarker {
  [Value] attribute FName MarkerName;
  attribute float Time;

  // TODO: operator < is not supported
  //ENGINE_API bool operator <(const FAnimSyncMarker& Other) const { return Time < Other.Time; }
};

interface TArrayFAnimSyncMarker {
};

interface TArrayFAnimSyncMarkerPtr {
};

interface FAnimNotifyTrack {
  [Value] attribute FName TrackName;
  [Value] attribute FLinearColor TrackColor;
  [Value] attribute TArrayFAnimNotifyEventPtr Notifies;
  [Value] attribute TArrayFAnimSyncMarkerPtr SyncMarkers;
  void FAnimNotifyTrack();
  void FAnimNotifyTrack([Ref] FName InTrackName, [Ref] FLinearColor InTrackColor);
};

enum EAdditiveAnimationType {
  "AAT_None",
  "AAT_LocalSpaceBase",
  "AAT_RotationOffsetMeshSpace",
  "AAT_MAX"
};

enum ECurveBlendOption_Type {
  "ECurveBlendOption::MaxWeight",
  "ECurveBlendOption::NormalizeByWeight",
  "ECurveBlendOption::BlendByWeight"
};

interface FSlotNodeWeightInfo {
  attribute float SourceWeight;
  attribute float SlotNodeWeight;
  attribute float TotalNodeWeight;
  void FSlotNodeWeightInfo();
  void Reset();
};

interface FMarkerSyncData {
  [Value] attribute TArrayFAnimSyncMarker AuthoredSyncMarkers;
  [Value] attribute TArrayFName UniqueMarkerNames;

  void GetMarkerIndicesForTime(float CurrentTime, boolean bLooping, [Const, Ref] TArrayFName ValidMarkerNames, [Ref] FMarkerPair OutPrevMarker, [Ref] FMarkerPair OutNextMarker, float SequenceLength);
  [Value] FMarkerSyncAnimPosition GetMarkerSyncPositionfromMarkerIndicies(long PrevMarker, long NextMarker, float CurrentTime, float SequenceLength);
  void CollectUniqueNames();
  void CollectMarkersInRange(float PrevPosition, float NewPosition, [Ref] TArrayFPassedMarker OutMarkersPassedThisTick, float TotalDeltaMove);
};

interface FAnimStackAllocator {
};

interface FAnimWeight {
  static boolean IsRelevant(float InWeight);
  static boolean IsFullWeight(float InWeight);
};

enum EAnimInterpolationType {
  "EAnimInterpolationType::Linear",
  "EAnimInterpolationType::Step"
};

interface FAnimKeyHelper {
  void FAnimKeyHelper(float InLength, long InNumKeys);
  float TimePerKey();
  long LastKey();
  float GetLength();
  long GetNumKeys();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFAnimNotifyEvent {
};

interface TArrayFAnimNotifyEventPtr {
};

interface TArrayFAnimNotifyEventConstPtr {
};

interface TEnumAsByteEAdditiveAnimationType {
};

interface TEnumAsByteEMontageNotifyTickType {
};

interface TEnumAsByteENotifyFilterType {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRawCurveTracks {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FCompactPose {
};
interface FSoundParseParameters {
  [Value] attribute FNotifyBufferFinishedHooks NotifyBufferFinishedHooks;
  attribute USoundClass SoundClass;
  attribute USoundSubmix SoundSubmix;
  [Value] attribute FTransform Transform;
  [Value] attribute FVector Velocity;
  attribute float Volume;
  attribute float VolumeMultiplier;
  attribute float VolumeApp;
  attribute float InteriorVolumeMultiplier;
  attribute float Priority;
  attribute float Pitch;
  attribute float StartTime;
  attribute float OmniRadius;
  attribute float AttenuationDistance;
  attribute float AbsoluteAzimuth;
  attribute float StereoSpread;
  attribute ESoundSpatializationAlgorithm SpatializationAlgorithm;
  attribute float LowPassFilterFrequency;
  attribute float AttenuationFilterFrequency;
  attribute float OcclusionFilterFrequency;
  attribute float AmbientZoneFilterFrequency;
  attribute unsigned long bUseSpatialization;
  attribute unsigned long bLooping;
  attribute unsigned long bEnableLowPassFilter;
  attribute unsigned long bIsOccluded;
  attribute unsigned long bIsPaused;

  void FSoundParseParameters();
};

interface FActiveSound {
  void FActiveSound();

  unsigned long GetAudioComponentID();
  void SetAudioComponent(UAudioComponent Component);
  [Value] FString GetAudioComponentName();
  [Value] FString GetOwnerName();

  unsigned long GetWorldID();
  [Value] TWeakObjectPtrUWorld GetWeakWorld();
  UWorld GetWorld();
  void SetWorld(UWorld World);

  USoundBase GetSound();
  void SetSound(USoundBase InSound);
  void SetSoundClass(USoundClass SoundClass);
  void SetAudioDevice(FAudioDevice InAudioDevice);
  boolean CanDelete();

  attribute FAudioDevice AudioDevice;
  attribute unsigned long ConcurrencyGroupID;
  attribute long ConcurrencyGeneration;
  attribute USoundConcurrency ConcurrencySettings;

  attribute unsigned short bHasCheckedOcclusion;
  attribute unsigned short bAllowSpatialization;
  attribute unsigned short bHasAttenuationSettings;
  attribute unsigned short bShouldRemainActiveIfDropped;
  attribute unsigned short bFadingOut;
  attribute unsigned short bFinished;
  attribute unsigned short bIsPaused;
  attribute unsigned short bShouldStopDueToMaxConcurrency;
  attribute unsigned short bRadioFilterSelected;
  attribute unsigned short bApplyRadioFilter;
  attribute unsigned short bHandleSubtitles;
  attribute unsigned short bLocationDefined;
  attribute unsigned short bIgnoreForFlushing;
  attribute unsigned short bEQFilterApplied;
  attribute unsigned short bAlwaysPlay;
  attribute unsigned short bIsUISound;
  attribute unsigned short bIsMusic;
  attribute unsigned short bReverb;
  attribute unsigned short bCenterChannelOnly;
  attribute unsigned short bIsPreviewSound;
  attribute unsigned short bGotInteriorSettings;
  attribute unsigned short bApplyInteriorVolumes;
  attribute unsigned short bEnableLowPassFilter;
  attribute unsigned short bUpdatePlayPercentage;
  attribute unsigned short UserIndex;

  attribute float PlaybackTime;
  attribute float RequestedStartTime;
  attribute float CurrentAdjustVolumeMultiplier;
  attribute float TargetAdjustVolumeMultiplier;
  attribute float TargetAdjustVolumeStopTime;

  attribute float VolumeMultiplier;
  attribute float PitchMultiplier;
  attribute float LowPassFilterFrequency;
  [Value] attribute FDynamicParameter CurrentOcclusionFilterFrequency;
  [Value] attribute FDynamicParameter CurrentOcclusionVolumeAttenuation;
  attribute float ConcurrencyVolumeScale;
  attribute float ConcurrencyDuckingVolumeScale;

  attribute float SubtitlePriority;
  attribute float Priority;
  attribute float FocusPriorityScale;
  attribute float FocusDistanceScale;
  attribute float VolumeConcurrency;
  attribute float OcclusionCheckInterval;
  attribute float LastOcclusionCheckTime;
  attribute float MaxDistance;

  [Value] attribute FTransform Transform;
  attribute float Azimuth;
  attribute float AbsoluteAzimuth;
  [Value] attribute FVector LastLocation;

  [Value] attribute FAttenuationSettings AttenuationSettings;
  [Value] attribute FInteriorSettings InteriorSettings;

  attribute unsigned long AudioVolumeID;
  attribute double LastUpdateTime; 
  attribute float SourceInteriorVolume;
  attribute float SourceInteriorLPF;
  attribute float CurrentInteriorVolume;
  attribute float CurrentInteriorLPF;
  [Value] attribute TMapUPTRINTFWaveInstancePtr WaveInstances;

  [Value] attribute TMapUPTRINTuint32 SoundNodeOffsetMap;
  [Value] attribute TArrayuint8 SoundNodeData;

  [Value] attribute TArrayFAudioComponentParam InstanceParameters;
  void UpdateWaveInstances([Ref] TArrayFWaveInstancePtr OutWaveInstances,
                           [Const] float DeltaTime);
  FWaveInstance FindWaveInstance([Const, Ref] UPTRINT WaveInstanceHash);
  void ApplyRadioFilter([Ref] FSoundParseParameters ParseParams);
  void SetFloatParameter([Const, Ref] FName InName, [Const] float InFloat);
  void SetWaveParameter([Const, Ref] FName InName, USoundWave InWave);
  void SetBoolParameter([Const, Ref] FName InName, [Const] boolean InBool);
  void SetIntParameter([Const, Ref] FName InName, [Const] long InInt);
  void SetSoundParameter([Const, Ref] FAudioComponentParam Param);
  boolean GetFloatParameter([Const, Ref] FName InName, float OutFloat);
  boolean GetWaveParameter([Const, Ref] FName InName, USoundWavePtr OutWave);
  boolean GetBoolParameter([Const, Ref] FName InName, boolean OutBool);
  boolean GetIntParameter([Const, Ref] FName InName, long OutInt);

  void CollectAttenuationShapesForVisualization(
      [Ref] TMultiMapEAttenuationShapeTypeFAttenuationSettingsAttenuationShapeDetails ShapeDetailsMap);
  void AddReferencedObjects([Ref] FReferenceCollector Collector);
  USoundClass GetSoundClass();
  USoundSubmix GetSoundSubmix();
  long FindClosestListener([Const, Ref] TArrayFListener InListners);
  unsigned long GetOwnerID();
  [Const] FSoundConcurrencySettings GetSoundConcurrencySettingsToApply();
  void OcclusionTraceDone([Const, Ref] FTraceHandle TraceHandle,
                          [Ref] FTraceDatum TraceDatum);
  unsigned long GetSoundConcurrencyObjectID();
  void ApplyAttenuation([Ref] FSoundParseParameters ParseParams,
                        [Const, Ref] FListener Listener,
                        [Const] FAttenuationSettings SettingsAttenuationNode);
  float GetPriority();

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FActiveSound* ActiveSound );
  // TODO: object of type 'FThreadSafeBool' cannot be assigned because its copy
  // assignment operator is implicitly deleted
  //[Value] attribute FThreadSafeBool bIsOccluded;
  //[Value] attribute FThreadSafeBool bAsyncOcclusionPending;
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFActiveSound {
};

interface TArrayFActiveSoundPtr {
};
enum ELoopingMode {
  "LOOP_Never",
  "LOOP_WithNotification",
  "LOOP_Forever"
};

enum EAudioPlugin_Type {
  "EAudioPlugin::SPATIALIZATION"
};

interface FNotifyBufferFinishedHooks {
  void AddNotify(USoundNode NotifyNode, [Ref] UPTRINT WaveInstanceHash);
  [Value] UPTRINT GetHashForNode(USoundNode NotifyNode);
  void AddReferencedObjects([Ref] FReferenceCollector Collector);
  void DispatchNotifies(FWaveInstance WaveInstance, [Const] boolean bStopped);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FNotifyBufferFinishedHooks& WaveInstance );
};

interface FDynamicParameter {
  void FDynamicParameter(float Value);
  void Set(float Value, float InDuration);
  void Update(float DeltaTime);
  float GetValue();
  float GetTargetValue();
};

interface FWaveInstance {
  attribute unsigned long TypeHashCounter;
  attribute USoundWave WaveData;
  attribute USoundClass SoundClass;
  attribute USoundSubmix SoundSubmix;
  [Value] attribute FNotifyBufferFinishedHooks NotifyBufferFinishedHooks;
  attribute FActiveSound ActiveSound;

  attribute float Volume;
  attribute float VolumeMultiplier;
  attribute float VolumeApp;
  attribute float Priority;
  attribute float VoiceCenterChannelVolume;
  attribute float RadioFilterVolume;
  attribute float RadioFilterVolumeThreshold;
  attribute float StereoBleed;
  attribute float LFEBleed;

  attribute ELoopingMode LoopingMode;
  attribute float StartTime;
  attribute unsigned long bApplyRadioFilter;
  attribute unsigned long bIsStarted;
  attribute unsigned long bIsFinished;
  attribute unsigned long bAlreadyNotifiedHook;
  attribute unsigned long bUseSpatialization;
  attribute unsigned long bEnableLowPassFilter;
  attribute unsigned long bIsOccluded;
  attribute unsigned long bEQFilterApplied;
  attribute unsigned long bIsUISound;
  attribute unsigned long bIsMusic;
  attribute unsigned long bReverb;
  attribute unsigned long bCenterChannelOnly;
  attribute unsigned long bIsPaused;
  attribute unsigned long bReportedSpatializationWarning;
  attribute ESoundSpatializationAlgorithm SpatializationAlgorithm;
  attribute EAudioOutputTarget_Type OutputTarget;
  attribute float LowPassFilterFrequency;
  attribute float OcclusionFilterFrequency;
  attribute float AmbientZoneFilterFrequency;
  attribute float AttenuationFilterFrequency;
  attribute float Pitch;
  [Value] attribute FVector Velocity;
  [Value] attribute FVector Location;
  attribute float OmniRadius;
  attribute float StereoSpread;
  attribute float AttenuationDistance;
  attribute float AbsoluteAzimuth; 
  attribute unsigned long TypeHash;
  [Value] attribute UPTRINT WaveInstanceHash;
  attribute unsigned short UserIndex;

  void FWaveInstance(FActiveSound ActiveSound);
  void StopWithoutNotification();
  void NotifyFinished([Const] boolean bStopped);
  void AddReferencedObjects([Ref] FReferenceCollector Collector);
  boolean ShouldStopDueToMaxConcurrency();
  float GetActualVolume();
  float GetVolume();
  float GetVolumeWeightedPriority();
  boolean IsStreaming();
  [Value] FString GetName();

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FWaveInstance* WaveInstance );
};

interface FSoundBuffer {
  void FSoundBuffer(FAudioDevice InAudioDevice);
  long GetSize();

  [Value] FString Describe(boolean bUseLongName);
  [Value] FName GetSoundClassName();
  [Value] FString GetChannelsDesc();
  boolean ReadCompressedInfo(USoundWave SoundWave);
  boolean ReadCompressedData(octet[] Destination, boolean bLooping);
  void Seek([Const] float SeekTime);
  long GetCurrentChunkIndex();
  long GetCurrentChunkOffset();
  boolean IsRealTimeSourceReady();
  void EnsureRealtimeTaskCompletion();
  attribute long ResourceID;
  attribute long NumChannels;
  [Value] attribute FString ResourceName;
  attribute boolean bAllocationInPermanentPool;
  attribute FAudioDevice AudioDevice;
};

interface FSoundSource {
  boolean PrepareForInitialization(FWaveInstance InWaveInstance);
  boolean IsPreparedToInit();
  boolean Init(FWaveInstance InWaveInstance);
  boolean IsInitialized();
  void Update();
  void Play();
  void Stop();
  boolean IsFinished();
  void SetPauseByGame(boolean bInIsPauseByGame);
  void SetPauseManually(boolean bInIsPauseManually);
  [Value] FString Describe(boolean bUseLongName);
  boolean IsGameOnly();
  [Const] FWaveInstance GetWaveInstance();

  boolean IsPlaying();
  boolean IsPaused();
  boolean IsPausedByGame();
  boolean IsPausedManually();
  boolean IsReverbApplied();
  boolean IsEQFilterApplied();
  boolean SetReverbApplied(boolean bHardwareAvailable);
  float SetStereoBleed();
  float SetLFEBleed();
  void SetFilterFrequency();
  void UpdateStereoEmitterPositions();
  void DrawDebugInfo();
  [Value] FSpatializationParams GetSpatializationParams();
  [Const] FSoundBuffer GetBuffer();
  void InitializeSourceEffects(unsigned long InEffectVoiceId);
  void SetVirtual();
  float GetPlaybackPercent();
  void NotifyPlaybackPercent();
};

interface FWaveModInfo {
  attribute unsigned long[] pSamplesPerSec;
  attribute unsigned long[] pAvgBytesPerSec;
  attribute unsigned long[] pBlockAlign;
  attribute unsigned long[] pBitsPerSample;
  attribute unsigned long[] pChannels;
  attribute unsigned long[] pFormatTag;

  attribute unsigned long[] pWaveDataSize;
  attribute unsigned long[] pMasterSize;
  attribute unsigned short[] SampleDataStart;
  attribute unsigned short[] SampleDataEnd;
  attribute unsigned long SampleDataSize;
  attribute unsigned short[] WaveDataEnd;
  attribute unsigned long NewDataSize;

  void FWaveModInfo();
  unsigned long Pad16Bit(unsigned long InDW);
  boolean ReadWaveInfo(octet[] WaveData, long WaveDataSize,
                       FString ErrorMessage);
  boolean ReadWaveHeader(octet[] RawWaveData, long Size, long Offset);
  void ReportImportFailure();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFWaveInstance {
};

interface TArrayFWaveInstancePtr {
};

interface TMapUPTRINTFWaveInstancePtr {
};
interface FDynamicMeshVertex {
  void FDynamicMeshVertex();
  void FDynamicMeshVertex([Const, Ref] FVector InPosition);
  void FDynamicMeshVertex(
      [Const, Ref] FVector InPosition,
      [Const, Ref] FVector InTangentX,
      [Const, Ref] FVector InTangentZ,
      [Const, Ref] FVector2D InTexCoord,
      [Const, Ref] FColor InColor);
  void SetTangents(
      [Const, Ref] FVector InTangentX,
      [Const, Ref] FVector InTangentY,
      [Const, Ref] FVector InTangentZ);
  [Value] FVector GetTangentY();
  [Value] attribute FVector Position;
  [Value] attribute FVector2D TextureCoordinate;
  [Value] attribute FPackedNormal TangentX;
  [Value] attribute FPackedNormal TangentZ;
  [Value] attribute FColor Color;
};

/* TODO */
interface FPackedNormal { };
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface AnimEncoding {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FFXSystemInterface {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FDebugDisplayInfo {
  void FDebugDisplayInfo([Const, Ref] TArrayFName InDisplayNames, [Const, Ref] TArrayFName InToggledCategories);
  boolean IsDisplayOn([Ref] FName DisplayName);
  boolean IsCategoryToggledOn([Ref] FName Category, boolean bDefaultsToOn);
  long NumDisplayNames();
};
interface FSpatializationParams {
  [Value] attribute FVector ListenerPosition;
  [Value] attribute FVector ListenerOrientation;
  [Value] attribute FVector EmitterPosition;
  [Value] attribute FVector EmitterWorldPosition;
  [Value] attribute FVector LeftChannelPosition;
  [Value] attribute FVector RightChannelPosition;
  attribute float Distance;
  attribute float NormalizedOmniRadius;

  void FSpatializationParams();
};

interface IAudioSpatializationAlgorithm
{
  void ProcessSpatializationForVoice(unsigned long VoiceIndex, float[] InSamples, float[] OutSamples, [Const, Ref] FVector Position);
  void ProcessSpatializationForVoice(unsigned long VoiceIndex, float[] InSamples, float[] OutSamples);
  void SetSpatializationParameters(unsigned long VoiceId, [Const, Ref] FSpatializationParams Params);
  void GetSpatializationParameters(unsigned long VoiceId, [Ref] FSpatializationParams OutParams);
  boolean IsSpatializationEffectInitialized();
  void InitializeSpatializationEffect(unsigned long BufferLength);
  boolean CreateSpatializationEffect(unsigned long VoiceId);
  VoidPtr GetSpatializationEffect(unsigned long VoiceId);
};

interface IAudioSpatializationPlugin {
  [Value] static FName GetModularFeatureName();
  [Ref] static IAudioSpatializationPlugin Get();
  static boolean IsAvailable();
  void Initialize();
  void Shutdown();
  IAudioSpatializationAlgorithm GetNewSpatializationAlgorithm(FAudioDevice AudioDevice);
};
IAudioSpatializationPlugin implements IModuleInterface;
IAudioSpatializationPlugin implements IModularFeature;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FActorComponentInstanceData {
  void FActorComponentInstanceData();
};

interface ECacheApplyPhase {
  void ECacheApplyPhase();
};
interface FCollisionQueryParams {
};

interface FComponentQueryParams {
	void FComponentQueryParams();
	void FComponentQueryParams([Ref] FName InTraceTag, [Const] AActor InIgnoreActor);
	[Value] static attribute FComponentQueryParams DefaultComponentQueryParams;
};
FComponentQueryParams implements FCollisionQueryParams;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FCollisionObjectQueryParams {
};

interface FCollisionResponseParams {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FCollisionNotifyInfo {
};

interface FRigidBodyCollisionInfo {
};

interface TArrayFCollisionNotifyInfo {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FPrimitiveSceneProxy {
};
interface FShadowMap {
  [Value] attribute TArrayFGuid LightGuids;
  boolean ContainsLight([Const, Ref] FGuid LightGuid);
  void AddReferencedObjects([Ref] FReferenceCollector Collector);
  void Serialize([Ref] FArchive Ar);
  [Value] FShadowMapInteraction GetInteraction();
  FShadowMap2D GetShadowMap2D();
  void AddRef();
  void Release();

  /* TODO */
  /* method only differs by const qualifier */
  //[Const] FShadowMap2D GetShadowMap2D();

  /* pure virtual class */
  //void FShadowMap();
  //void FShadowMap([Ref] TArrayFGuid InLightGuids);
};

interface FShadowMap2D {
  [Value] static TRefCountPtrFShadowMap2D AllocateShadowMap(
      UObject LightMapOuter,
      [Const, Ref] TMapULightComponentPtrFShadowMapData2DPtr ShadowMapData,
      [Const, Ref] FBoxSphereBounds Bounds,
      [Ref] ELightMapPaddingType InPaddingType,
      [Ref] EShadowMapFlags InShadowmapFlags);
  void FShadowMap2D();
  void FShadowMap2D([Const, Ref] TMapULightComponentPtrFShadowMapData2DPtr ShadowMapData);
  UShadowMapTexture2D GetTexture();
  [Const, Ref] FVector2D GetCoordinateScale();
  [Const, Ref] FVector2D GetCoordinateBias();
  boolean IsValid();
  boolean IsShadowFactorTexture();
  void AddReferencedObjects([Ref] FReferenceCollector Collector);
  void Serialize([Ref] FArchive Ar);
  [Value] FShadowMapInteraction GetInteraction();
  FShadowMap2D GetShadowMap2D();

  /* TODO */
  /* overload must differ by number of arguments */
  //void FShadowMap2D([Ref] TArrayFGuid LightGuids);

  /* rvalue references are not supported */
  //[Value] static TRefCountPtrFShadowMap2D AllocateInstancedShadowMap(
      //UObject LightMapOuter,
      //UInstancedStaticMeshComponent Component,
      //TArray<TMap<ULightComponent*,
      //TUniquePtr<FShadowMapData2D>>>&& InstancedShadowMapData,
      //UMapBuildDataRegistry Registry,
      //[Value] FGuid MapBuildDataId,
      //[Const, Ref] FBoxSphereBounds Bounds,
      //ELightMapPaddingType PaddingType,
      //EShadowMapFlags ShadowmapFlags);

  /* method only differs by const qualifier */
  //[Const] FShadowMap2D GetShadowMap2D();

  /* unresolved symbol */
  //static long EncodeSingleTexture(
      //ULevel LightingScenario,
      //[Ref] FShadowMapPendingTexture PendingTexture,
      //UShadowMapTexture2D Texture,
      //[Ref] TArrayTArrayFFourDistanceFieldSamples MipData);
  //static void EncodeTextures(
      //UWorld InWorld,
      //ULevel LightingScenario,
      //boolean bLightingSuccessful,
      //optional boolean bMultithreadedEncode = false);
};

FShadowMap2D implements FShadowMap;

/* TODO */
interface TArrayFGuid { };
interface FShadowMapInteraction { };
[NoDelete]
interface FShadowMapPendingTexture { };
interface UShadowMapTexture2D { };
interface TArrayTArrayFFourDistanceFieldSamples { };
interface TMapULightComponentPtrFShadowMapData2DPtr { };
interface ELightMapPaddingType { };
interface EShadowMapFlags { };
interface UInstancedStaticMeshComponent { };
interface UMapBuildDataRegistry { };
interface TRefCountPtrFShadowMap2D { };
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FSceneView {
  void FSceneView([Const, Ref] FSceneViewInitOptions InitOptions);
};

interface FSceneViewInitOptions {
  void FSceneViewInitOptions();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FSceneViewProjectionData {
  [Value] attribute FVector ViewOrigin;
  [Value] attribute FMatrix ViewRotationMatrix;
  [Value] attribute FMatrix ProjectionMatrix;

  void SetViewRectangle([Const, Ref] FIntRect InViewRect);
  void SetConstrainedViewRectangle([Const, Ref] FIntRect InViewRect);
  boolean IsValidViewRectangle();
  boolean IsPerspectiveProjection();
  [Const, Ref] FIntRect GetViewRect();
  [Const, Ref] FIntRect GetConstrainedViewRect();
  [Value] FMatrix ComputeViewProjectionMatrix();
};
enum EPixelFormat {
  "EPixelFormat::PF_Unknown",
  "EPixelFormat::PF_A32B32G32R32F",
  "EPixelFormat::PF_B8G8R8A8",
  "EPixelFormat::PF_G8",
  "EPixelFormat::PF_G16",
  "EPixelFormat::PF_DXT1",
  "EPixelFormat::PF_DXT3",
  "EPixelFormat::PF_DXT5",
  "EPixelFormat::PF_UYVY",
  "EPixelFormat::PF_FloatRGB",
  "EPixelFormat::PF_FloatRGBA",
  "EPixelFormat::PF_DepthStencil",
  "EPixelFormat::PF_ShadowDepth",
  "EPixelFormat::PF_R32_FLOAT",
  "EPixelFormat::PF_G16R16",
  "EPixelFormat::PF_G16R16F",
  "EPixelFormat::PF_G16R16F_FILTER",
  "EPixelFormat::PF_G32R32F",
  "EPixelFormat::PF_A2B10G10R10",
  "EPixelFormat::PF_A16B16G16R16",
  "EPixelFormat::PF_D24",
  "EPixelFormat::PF_R16F",
  "EPixelFormat::PF_R16F_FILTER",
  "EPixelFormat::PF_BC5",
  "EPixelFormat::PF_V8U8",
  "EPixelFormat::PF_A1",
  "EPixelFormat::PF_FloatR11G11B10",
  "EPixelFormat::PF_A8",
  "EPixelFormat::PF_R32_UINT",
  "EPixelFormat::PF_R32_SINT",
  "EPixelFormat::PF_PVRTC2",
  "EPixelFormat::PF_PVRTC4",
  "EPixelFormat::PF_R16_UINT",
  "EPixelFormat::PF_R16_SINT",
  "EPixelFormat::PF_R16G16B16A16_UINT",
  "EPixelFormat::PF_R16G16B16A16_SINT",
  "EPixelFormat::PF_R5G6B5_UNORM",
  "EPixelFormat::PF_R8G8B8A8",
  "EPixelFormat::PF_A8R8G8B8",
  "EPixelFormat::PF_BC4",
  "EPixelFormat::PF_R8G8",
  "EPixelFormat::PF_ATC_RGB",
  "EPixelFormat::PF_ATC_RGBA_E",
  "EPixelFormat::PF_ATC_RGBA_I",
  "EPixelFormat::PF_X24_G8",
  "EPixelFormat::PF_ETC1",
  "EPixelFormat::PF_ETC2_RGB",
  "EPixelFormat::PF_ETC2_RGBA",
  "EPixelFormat::PF_R32G32B32A32_UINT",
  "EPixelFormat::PF_R16G16_UINT",
  "EPixelFormat::PF_ASTC_4x4",
  "EPixelFormat::PF_ASTC_6x6",
  "EPixelFormat::PF_ASTC_8x8",
  "EPixelFormat::PF_ASTC_10x10",
  "EPixelFormat::PF_ASTC_12x12",
  "EPixelFormat::PF_BC6H",
  "EPixelFormat::PF_BC7",
  "EPixelFormat::PF_R8_UINT",
  "EPixelFormat::PF_MAX"
};
enum ESoundMixState_Type {
  "ESoundMixState::Inactive",
  "ESoundMixState::FadingIn",
  "ESoundMixState::Active",
  "ESoundMixState::FadingOut",
  "ESoundMixState::AwaitingRemoval"
};

enum ESortedActiveWaveGetType_Type {
  "ESortedActiveWaveGetType::FullUpdate",
  "ESortedActiveWaveGetType::PausedUpdate",
  "ESortedActiveWaveGetType::QueryOnly",
};

interface FListener {
  [Value] attribute FTransform Transform;
  [Value] attribute FVector Velocity;

  [Value] attribute FInteriorSettings InteriorSettings;
  attribute unsigned long AudioVolumeID;
  attribute unsigned long WorldID;
  attribute double InteriorStartTime;
  attribute double InteriorEndTime;
  attribute double ExteriorEndTime;
  attribute double InteriorLPFEndTime;
  attribute double ExteriorLPFEndTime;
  attribute float InteriorVolumeInterp;
  attribute float InteriorLPFInterp;
  attribute float ExteriorVolumeInterp;
  attribute float ExteriorLPFInterp;

  [Value] FVector GetUp();
  [Value] FVector GetFront();
  [Value] FVector GetRight();

  float Interpolate([Const] double EndTime);
  void UpdateCurrentInteriorSettings();
  void ApplyInteriorSettings(unsigned long AudioVolumeID,
                             [Const, Ref] FInteriorSettings Settings);

  void FListener();
};

interface FGlobalFocusSettings {
  attribute float FocusAzimuthScale;
  attribute float NonFocusAzimuthScale;
  attribute float FocusDistanceScale;
  attribute float NonFocusDistanceScale;
  attribute float FocusVolumeScale;
  attribute float NonFocusVolumeScale;
  attribute float FocusPriorityScale;
  attribute float NonFocusPriorityScale;

  void FGlobalFocusSettings();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FAudioDevice {
};

interface TArrayFListener {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFBoneData {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FBoneContainer {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface FSceneInterface {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[NoDelete]
interface INavAgentInterface {
  [Const, Ref] FNavAgentProperties GetNavAgentPropertiesRef();
  [Value] FVector GetNavAgentLocation();
  [Value] FVector GetMoveGoalOffset([Const] AActor MovingActor);
  void GetMoveGoalReachTest([Const] AActor MovingActor, [Const, Ref] FVector MoveOffset, [Const, Ref] FVector GoalOffset, float GoalRadius, float GoalHalfHeight);
  boolean ShouldPostponePathUpdates();
  boolean IsFollowingAPath();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FNavAgentProperties {
};

FNavAgentProperties implements FMovementProperties;

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FMovementProperties {
  attribute unsigned long bCanCrouch;
  attribute unsigned long bCanJump;
  attribute unsigned long bCanWalk;
  attribute unsigned long bCanSwim;
  attribute unsigned long bCanFly;

  void FMovementProperties();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface IInterface_PostProcessVolume {
};

interface TArrayIInterface_PostProcessVolumePtr {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UInterface_AssetUserData {
};

[NoDelete]
interface IInterface_AssetUserData {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UStaticMesh {
  void UStaticMesh();
};
UStaticMesh implements UObject;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FVector_NetQuantize10 {
  void FVector_NetQuantize10();
  void FVector_NetQuantize10(float InX, float InY, float InZ);
  void FVector_NetQuantize10([Const, Ref] FVector InVec);
  boolean NetSerialize([Ref] FArchive Ar, UPackageMap Map, boolean bOutSuccess);

  // TODO: function override is not fully supported
  // void FVector_NetQuantize10(EForceInit E);
};

FVector_NetQuantize10 implements FVector;

interface FVector_NetQuantize100 {
  void FVector_NetQuantize100();
  void FVector_NetQuantize100(float InX, float InY, float InZ);
  void FVector_NetQuantize100([Const, Ref] FVector InVec);
  boolean NetSerialize([Ref] FArchive Ar, UPackageMap Map, boolean bOutSuccess);

  // TODO: function override is not fully supported
  // void FVector_NetQuantize100(EForceInit E);
};

FVector_NetQuantize100 implements FVector;

interface FVector_NetQuantizeNormal {
  void FVector_NetQuantizeNormal();
  void FVector_NetQuantizeNormal(float InX, float InY, float InZ);
  void FVector_NetQuantizeNormal([Const, Ref] FVector InVec);
  boolean NetSerialize([Ref] FArchive Ar, UPackageMap Map, boolean bOutSuccess);

  // TODO: function override is not fully supported
  // void FVector_NetQuantizeNormal(EForceInit E);
};

FVector_NetQuantizeNormal implements FVector;
interface TArrayAssetUserData {
  void TArrayAssetUserData();
  VoidPtr GetData();
  long Num();
};

interface TArrayUAssetUserDataPtr {
  void TArrayUAssetUserDataPtr();
};

interface TSubclassOfUAssetUserData {
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UAssetUserData {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UDemoNetDriver {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FLightComponentMapBuildData {
  void FLightComponentMapBuildData();
};
interface USkeletalMesh {
  attribute USkeleton Skeleton;
  [Value] attribute TArrayFSkeletalMaterial Materials;
  [Value] attribute TArrayFBoneMirrorInfo SkelMirrorTable;
  [Value] attribute TEnumAsByteEAxisType SkelMirrorAxis;
  [Value] attribute TEnumAsByteEAxisType SkelMirrorFlipAxis;
  [Value] attribute TArrayFSkeletalMeshLODInfo LODInfo;
  attribute UBodySetup BodySetup;
  attribute UPhysicsAsset PhysicsAsset;
  attribute UPhysicsAsset ShadowPhysicsAsset;
  [Value] attribute TArrayUMorphTargetPtr MorphTargets;
  [Value] attribute FRenderCommandFence ReleaseResourcesFence;
  [Value] attribute FReferenceSkeleton RefSkeleton;
  [Value] attribute TMapFNameint32 MorphTargetIndexMap;

  FSkeletalMeshResource GetImportedResource();
  FSkeletalMeshResource GetResourceForRendering();
  [Value] FBoxSphereBounds GetBounds();
  [Value] FBoxSphereBounds GetImportedBounds();
  void SetImportedBounds([Const, Ref] FBoxSphereBounds InBounds);
  void SetPositiveBoundsExtension([Const, Ref] FVector InExtension);
  void SetNegativeBoundsExtension([Const, Ref] FVector InExtension);
  void CalculateExtendedBounds();
  void ValidateBoundsExtension();
  void InitResources();
  void ReleaseResources();
  void ReleaseCPUResources();
  void UpdateUVChannelData(boolean bResetOverrides);
  [Const] FMeshUVChannelInfo GetUVChannelData(long MaterialIndex);
  boolean GetSortCenterPoint([Ref] FVector OutSortCenter);
  unsigned long GetVertexBufferFlags();
  void BeginDestroy();
  boolean IsReadyForFinishDestroy();
  void PreSave([Const] ITargetPlatform TargetPlatform);
  void Serialize([Ref] FArchive Ar);
  void PostInitProperties();
  void PostLoad();
  void GetAssetRegistryTags([Ref] TArrayUObjectFAssetRegistryTag OutTags);
  [Value] FString GetDesc();
  [Value] FString GetDetailedInfoInternal();
  void GetResourceSizeEx([Ref] FResourceSizeEx CumulativeResourceSize);
  static void AddReferencedObjects(UObject InThis, [Ref] FReferenceCollector Collector);
  void CalculateInvRefMatrices();
  static void CalculateRequiredBones([Ref] FStaticLODModel LODModel, [Const, Ref] FReferenceSkeleton RefSkeleton, [Const] TMapFBoneIndexTypeFBoneIndexType BonesToRemove);
  USkeletalMeshSocket FindSocket([Const] FName InSocketName);
  long NumSockets();
  USkeletalMeshSocket GetSocketByIndex(long Index);
  [Value] FMatrix GetRefPoseMatrix(long BoneIndex);
  [Value] FMatrix GetComposedRefPoseMatrix([Const] FName InBoneName);
  void InitBoneMirrorInfo();
  void CopyMirrorTableFrom(USkeletalMesh SrcMesh);
  void ExportMirrorTable([Ref] TArrayFBoneMirrorExport MirrorExportInfo);
  void ImportMirrorTable([Ref] TArrayFBoneMirrorExport MirrorExportInfo);
  boolean MirrorTableIsGood([Ref] FString ProblemBones);
  [Ref] TArrayUSkeletalMeshSocketPtr GetMeshOnlySocketList();
  [Value] TArrayUSkeletalMeshSocketPtr GetActiveSocketList();
  void DebugVerifySkeletalMeshLOD();
  UMorphTarget FindMorphTarget([Const] FName MorphTargetName);
  void RegisterMorphTarget(UMorphTarget MorphTarget);
  void UnregisterMorphTarget(UMorphTarget MorphTarget);
  void InitMorphTargets();
  boolean IsSectionUsingCloth(long InSectionIndex, optional boolean bCheckCorrespondingSections = true);
  void CreateBodySetup();
  UBodySetup GetBodySetup();
  boolean GetPhysicsTriMeshData(FTriMeshCollisionData CollisionData, boolean InUseAllTriData);
  boolean ContainsPhysicsTriMeshData(boolean InUseAllTriData);
  boolean WantsNegXTriMesh();
  void AddAssetUserData(UAssetUserData InUserData);
  void RemoveUserDataOfClass(TSubclassOfUAssetUserData InUserDataClass);
  UAssetUserData GetAssetUserDataOfClass(TSubclassOfUAssetUserData InUserDataClass);
  [Const] TArrayUAssetUserDataPtr GetAssetUserDataArray();

/* TODO */
/* This is not enabled by default in our build: */
// #if WITH_APEX_CLOTHING
  // boolean HasClothSectionsInAllLODs(long AssetIndex);
  // boolean HasClothSections(long LODIndex, long AssetIndex);
  // void GetOriginSectionIndicesWithCloth(long LODIndex, [Ref] TArrayuint32 OutSectionIndices);
  // void GetOriginSectionIndicesWithCloth(long LODIndex, long AssetIndex, [Ref] TArrayuint32 OutSectionIndices);
  // void GetClothSectionIndices(long LODIndex, long AssetIndex, [Ref] TArrayuint32 OutSectionIndices);
  // void LoadClothCollisionVolumes(long AssetIndex, ClothingAsset ClothingAsset);
  // boolean IsMappedClothingLOD(long LODIndex, long AssetIndex);
  // long GetClothAssetIndex(long LODIndex, long SectionIndex);
  // void BuildApexToUnrealBoneMapping();
// #endif

/* bitfields are not supported */
  //uint32 bUseFullPrecisionUVs:1;
  //uint32 bHasBeenSimplified:1;
  //uint32 bHasVertexColors:1;
  //uint32 bEnablePerPolyCollision : 1;

/* can't pass POD types with [Ref] */
  // USkeletalMeshSocket FindSocketAndIndex([Const] FName InSocketName, [Ref] long OutIndex);
  // UMorphTarget FindMorphTargetAndIndex([Const] FName MorphTargetName, [Ref] long OutIndex);

/* override must have different number of arguments */
  // [Value] FMatrix GetComposedRefPoseMatrix(long InBoneIndex);

/* extended attributes differ on overloads */
  // [Const, Ref] TArrayUSkeletalMeshSocketPtr GetMeshOnlySocketList();
};

USkeletalMesh implements UObject;
USkeletalMesh implements IInterface_CollisionDataProvider;
USkeletalMesh implements IInterface_AssetUserData;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/
/* This is not enabled by default in our build: */
// #if WITH_APEX_CLOTHING
  // interface TArrayuint32 { };
  // [Prefix="nvidia::apex::"]
  // interface ClothingAsset { };
// #endif
[NoDelete]
interface IInterface_CollisionDataProvider { };
interface FSkeletalMeshResource { };
interface TArrayFSkeletalMaterial { };
interface TArrayFBoneMirrorInfo { };
interface TArrayFSkeletalMeshLODInfo { };
[NoDelete]
interface UPhysicsAsset { };
interface TArrayUMorphTargetPtr { };
interface FReferenceSkeleton { };
interface TMapFNameint32 { };
interface FMeshUVChannelInfo { };
interface FResourceSizeEx { };
[NoDelete]
interface FReferenceCollector { };
interface FStaticLODModel { };
interface TMapFBoneIndexTypeFBoneIndexType { };
interface USkeletalMeshSocket { };
interface TArrayFBoneMirrorExport { };
interface TArrayUSkeletalMeshSocketPtr { };
interface UMorphTarget { };
interface FTriMeshCollisionData { };
interface UTexture {
  void UTexture();

  attribute long LODBias;
  attribute long NumCinematicMipLevels;
  attribute long SRGB;

  attribute long NeverStream;
  attribute long bNoTiling;

  attribute long bUseCinematicMipLevels;

  [Value] attribute TEnumAsByteTextureCompressionSettings CompressionSettings;
  [Value] attribute TEnumAsByteTextureFilter Filter;
  [Value] attribute TEnumAsByteTextureGroup LODGroup;

  attribute FTextureResource Resource;
  [Value] attribute FTextureReference TextureReference;
  [Value] attribute FRenderCommandFence ReleaseFence;

  void ReleaseResource();
  void UpdateResource();
  FTextureResource CreateResource();

  long GetCachedLODBias();
  void UpdateCachedLODBias(boolean bIncTextureMips);
  EMaterialValueType GetMaterialType();
  void WaitForStreaming();
  boolean UpdateStreamingStatus(boolean bWaitForMipFading);
  void CleanupCachedRunningPlatformData();

  void AddAssetUserData(UAssetUserData InUserData);
  [Const] TArrayUAssetUserDataPtr GetAssetUserDataArray();

  float GetSurfaceWidth();
  float GetSurfaceHeight();

  void PostInitProperties();
  void PostLoad();
  void PreSave([Const] ITargetPlatform TargetPlatform);
  void BeginDestroy();
  boolean IsReadyForFinishDestroy();
  void FinishDestroy();

  boolean IsPostLoadThreadSafe();
  float GetAverageBrightness(boolean bIgnoreTrueBlack, boolean bUseGrayscale);

  boolean HasHDRSource();
  boolean IsNormalMap();
  long CalcTextureMemorySizeEnum(ETextureMipCount Enum);

  [Value] FGuid GetLightingGuid();
  void SetLightingGuid();
  //TODO
  //static FOnTextureSaved PreSaveEvent;
  //FTexturePlatformData GetRunningPlatformData();
  //void RemoveUserDataOfClass(TSubclassOfUAssetUserData InUserDataClass);
  //UAssetUserData GetAssetUserDataOfClass(TSubclassOfUAssetUserData InUserDataClass);
  //void Serialize(FArchive& Ar) override;
  //static class UEnum* GetPixelFormatEnum();
  //static const TCHAR* GetTextureGroupString(TextureGroup InGroup);
  //static const TCHAR* GetMipGenSettingsString(TextureMipGenSettings InEnum);
  //static TextureMipGenSettings GetMipGenSettingsFromString(const TCHAR* InStr, bool bTextureGroup);
  //static bool ForceUpdateTextureStreaming();
};
UTexture implements UObject;

enum TextureAddress {
  "TA_Wrap",
  "TA_Clamp",
  "TA_Mirror",
  "TA_MAX"
};

enum ETextureMipCount {
  "TMC_ResidentMips",
  "TMC_AllMips",
  "TMC_AllMipsBiased",
  "TMC_MAX"
};

enum TextureCompressionSettings {
  "TC_Default",
  "TC_Normalmap",
  "TC_Masks",
  "TC_Grayscale",
  "TC_Displacementmap",
  "TC_VectorDisplacementmap",
  "TC_HDR",
  "TC_EditorIcon",
  "TC_Alpha",
  "TC_DistanceFieldFont",
  "TC_HDR_Compressed",
  "TC_BC7",
  "TC_MAX"
};

enum TextureFilter {
  "TF_Nearest",
  "TF_Bilinear",
  "TF_Trilinear",
  "TF_Default",
  "TF_MAX"
};

interface TEnumAsByteTextureCompressionSettings {
  void TEnumAsByteTextureCompressionSettings();
  void Assign(TextureCompressionSettings InValue);
  long GetValue();
};

interface TEnumAsByteTextureFilter {
  void TEnumAsByteTextureFilter();
  void Assign(TextureFilter InValue);
  long GetValue();
};

interface TEnumAsByteTextureAddress {
  void TEnumAsByteTextureAddress();
  void Assign(TextureAddress InValue);
  long GetValue();
};

interface FTexturePlatformData {
  void FTexturePlatformData();
  [Value] attribute FTexture2DMipMap[] Mips;
  attribute long SizeX;
  attribute long SizeY;
  attribute long NumSlices;
  attribute EPixelFormat PixelFormat;
  long GetNumNonStreamingMips();
  boolean TryLoadMips(long FirstMipToLoad, VoidPtr[] OutMipData);
};

interface TArrayUTexture {
};

interface TArrayUTexturePtr {
};
interface FMaterialTextureInfo {
  void FMaterialTextureInfo();
  attribute float SamplingScale;
  attribute long UVChannelIndex;
  [Value] attribute FName TextureName;
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FStreamingTextureLevelContext {
};

interface TArrayFStreamingTexturePrimitiveInfo {
};

interface FTexCoordScaleMap {
};
interface UTexture2D {
  void UTexture2D();
  attribute long RequestedMips;
  attribute long ResidentMips;
  attribute long LevelIndex;
  attribute long FirstResourceMemMip;

  [Value] FIntPoint GetImportedSize();

  attribute long bIsStreamable;
  attribute long bHasCancelationPending;
  attribute long bForceMiplevelsToBeResident;
  attribute long bIgnoreStreamingMipBias;
  attribute long bGlobalForceMipLevelsToBeResident;
  [Value] attribute TEnumAsByteTextureAddress AddressX;
  [Value] attribute TEnumAsByteTextureAddress AddressY;
  attribute FTexturePlatformData PlatformData;

  [Value] readonly attribute FThreadSafeCounter PendingMipChangeRequestStatus;
  attribute FTexture2DResourceMem ResourceMem;

  void BeginDestroy();
  void PostLoad();
  void PreSave([Const] ITargetPlatform TargetPlatform);
  void GetAssetRegistryTags([Ref] TArrayUObjectFAssetRegistryTag OutTags);
  [Value] FString GetDesc();

  float GetSurfaceWidth();
  float GetSurfaceHeight();
  FTextureResource CreateResource();
  EMaterialValueType GetMaterialType();
  void UpdateResource();
  float GetAverageBrightness(boolean bIgnoreTrueBlack, boolean bUseGrayscale);

  long GetSizeX();
  long GetSizeY();
  long GetNumMips();
  EPixelFormat GetPixelFormat();
  long GetMipTailBaseIndex();
  [Const, Value] TIndirectArrayTexture2DMipMap GetPlatformMips();

  long GetStreamingIndex();
  float GetLastRenderTimeForStreaming();
  void InvalidateLastRenderTimeForStreaming();
  void GetMipData(long FirstMipToLoad, VoidPtr[] OutMipData);

  long GetNumNonStreamingMips();

  long CalcTextureMemorySize(long MipCount);
  long CalcTextureMemorySizeEnum(ETextureMipCount Enum);

  long HasSameSourceArt(UTexture2D InTexture);
  long HasAlphaChannel();
  boolean IsReadyForStreaming();
  void WaitForStreaming();
  boolean UpdateStreamingStatus(boolean bWaitForMipFading);
  boolean CancelPendingMipChangeRequest();
  boolean ShouldMipLevelsBeForcedResident();
  boolean IsFullyStreamedIn();
  void LinkStreaming();
  void UnlinkStreaming();
  void UpdateTextureRegions(long MipIndex, long NumRegions, [Const] FUpdateTextureRegion2D Regions, long SrcPitch, long SrcBpp, octet[] SrcData);

  void SetForceMipLevelsToBeResident(float Seconds, long CinematicTextureGroups);
  //TODO
  //void Serialize(FArchive& Ar);
  //FTexturePlatformData** GetRunningPlatformData();
  //static FORCEINLINE int32 GetMinTextureResidentMipCount()
  //static void SetMinTextureResidentMipCount(int32 InMinTextureResidentMipCount);
  //static void CalcAllowedMips( int32 MipCount, int32 NumNonStreamingMips, int32 LODBias, int32& OuMinAllowedMips, int32& OutMaxAllowedMips );
  //long GetSourceArtCRC(uint32& OutSourceCRC);
  //void GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize) override;
  //ENGINE_API static void CancelPendingTextureStreaming();
  //ENGINE_API static float GetGlobalMipMapLODBias();
  //boolean GetResourceMemSettings(int32 FirstMipIdx, int32& OutSizeX, int32& OutSizeY, int32& OutNumMips, uint32& OutTexCreateFlags);
  //static class UTexture2D* CreateTransient(int32 InSizeX, int32 InSizeY, EPixelFormat InFormat = PF_B8G8R8A8);

  void RefreshSamplerStates();
};
UTexture2D implements UTexture;

interface TArrayUTexture2D {
};
interface TArrayUTexture2DPtr {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ULevel {
  void ULevel();
};

interface TSetULevel {
};

interface TSetULevelPtr {
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TEnumAsByteEAutoExposureMethod {
  void TEnumAsByteEAutoExposureMethod();
};

interface TEnumAsByteEDepthOfFieldMethod {
  void TEnumAsByteEDepthOfFieldMethod();
};

interface TArrayFWeightedBlendable {
  void TArrayFWeightedBlendable();
};

interface TScriptInterfaceIBlendableInterface {
  void TScriptInterfaceIBlendableInterface();
};

interface TArrayUObjectPtr {
  void TArrayUObjectPtr();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FWeightedBlendables {
  [Value] attribute TArrayFWeightedBlendable Array;
};

interface FPostProcessSettings {
  attribute long bOverride_WhiteTemp;
  attribute long bOverride_WhiteTint;
  attribute long bOverride_ColorSaturation;
  attribute long bOverride_ColorContrast;
  attribute long bOverride_ColorGamma;
  attribute long bOverride_ColorGain;
  attribute long bOverride_ColorOffset;
  attribute long bOverride_ColorSaturationShadows;
  attribute long bOverride_ColorContrastShadows;
  attribute long bOverride_ColorGammaShadows;
  attribute long bOverride_ColorGainShadows;
  attribute long bOverride_ColorOffsetShadows;
  attribute long bOverride_ColorSaturationMidtones;
  attribute long bOverride_ColorContrastMidtones;
  attribute long bOverride_ColorGammaMidtones;
  attribute long bOverride_ColorGainMidtones;
  attribute long bOverride_ColorOffsetMidtones;
  attribute long bOverride_ColorSaturationHighlights;
  attribute long bOverride_ColorContrastHighlights;
  attribute long bOverride_ColorGammaHighlights;
  attribute long bOverride_ColorGainHighlights;
  attribute long bOverride_ColorOffsetHighlights;
  attribute long bOverride_ColorCorrectionShadowsMax;
  attribute long bOverride_ColorCorrectionHighlightsMin;
  attribute long bOverride_FilmWhitePoint;
  attribute long bOverride_FilmSaturation;
  attribute long bOverride_FilmChannelMixerRed;
  attribute long bOverride_FilmChannelMixerGreen;
  attribute long bOverride_FilmChannelMixerBlue;
  attribute long bOverride_FilmContrast;
  attribute long bOverride_FilmDynamicRange;
  attribute long bOverride_FilmHealAmount;
  attribute long bOverride_FilmToeAmount;
  attribute long bOverride_FilmShadowTint;
  attribute long bOverride_FilmShadowTintBlend;
  attribute long bOverride_FilmShadowTintAmount;
  attribute long bOverride_FilmSlope;
  attribute long bOverride_FilmToe;
  attribute long bOverride_FilmShoulder;
  attribute long bOverride_FilmBlackClip;
  attribute long bOverride_FilmWhiteClip;
  attribute long bOverride_SceneColorTint;
  attribute long bOverride_SceneFringeIntensity;
  attribute long bOverride_AmbientCubemapTint;
  attribute long bOverride_AmbientCubemapIntensity;
  attribute long bOverride_BloomIntensity;
  attribute long bOverride_BloomThreshold;
  attribute long bOverride_Bloom1Tint;
  attribute long bOverride_Bloom1Size;
  attribute long bOverride_Bloom2Size;
  attribute long bOverride_Bloom2Tint;
  attribute long bOverride_Bloom3Tint;
  attribute long bOverride_Bloom3Size;
  attribute long bOverride_Bloom4Tint;
  attribute long bOverride_Bloom4Size;
  attribute long bOverride_Bloom5Tint;
  attribute long bOverride_Bloom5Size;
  attribute long bOverride_Bloom6Tint;
  attribute long bOverride_Bloom6Size;
  attribute long bOverride_BloomSizeScale;
  attribute long bOverride_BloomDirtMaskIntensity;
  attribute long bOverride_BloomDirtMaskTint;
  attribute long bOverride_BloomDirtMask;
  attribute long bOverride_AutoExposureMethod;
  attribute long bOverride_AutoExposureLowPercent;
  attribute long bOverride_AutoExposureHighPercent;
  attribute long bOverride_AutoExposureMinBrightness;
  attribute long bOverride_AutoExposureMaxBrightness;
  attribute long bOverride_AutoExposureSpeedUp;
  attribute long bOverride_AutoExposureSpeedDown;
  attribute long bOverride_AutoExposureBias;
  attribute long bOverride_HistogramLogMin;
  attribute long bOverride_HistogramLogMax;
  attribute long bOverride_LensFlareIntensity;
  attribute long bOverride_LensFlareTint;
  attribute long bOverride_LensFlareTints;
  attribute long bOverride_LensFlareBokehSize;
  attribute long bOverride_LensFlareBokehShape;
  attribute long bOverride_LensFlareThreshold;
  attribute long bOverride_VignetteIntensity;
  attribute long bOverride_GrainIntensity;
  attribute long bOverride_GrainJitter;
  attribute long bOverride_AmbientOcclusionIntensity;
  attribute long bOverride_AmbientOcclusionStaticFraction;
  attribute long bOverride_AmbientOcclusionRadius;
  attribute long bOverride_AmbientOcclusionFadeDistance;
  attribute long bOverride_AmbientOcclusionFadeRadius;
  attribute long bOverride_AmbientOcclusionDistance_DEPRECATED;
  attribute long bOverride_AmbientOcclusionRadiusInWS;
  attribute long bOverride_AmbientOcclusionPower;
  attribute long bOverride_AmbientOcclusionBias;
  attribute long bOverride_AmbientOcclusionQuality;
  attribute long bOverride_AmbientOcclusionMipBlend;
  attribute long bOverride_AmbientOcclusionMipScale;
  attribute long bOverride_AmbientOcclusionMipThreshold;
  attribute long bOverride_LPVIntensity;
  attribute long bOverride_LPVDirectionalOcclusionIntensity;
  attribute long bOverride_LPVDirectionalOcclusionRadius;
  attribute long bOverride_LPVDiffuseOcclusionExponent;
  attribute long bOverride_LPVSpecularOcclusionExponent;
  attribute long bOverride_LPVDiffuseOcclusionIntensity;
  attribute long bOverride_LPVSpecularOcclusionIntensity;
  attribute long bOverride_LPVSize;
  attribute long bOverride_LPVSecondaryOcclusionIntensity;
  attribute long bOverride_LPVSecondaryBounceIntensity;
  attribute long bOverride_LPVGeometryVolumeBias;
  attribute long bOverride_LPVVplInjectionBias;
  attribute long bOverride_LPVEmissiveInjectionIntensity;
  attribute long bOverride_IndirectLightingColor;
  attribute long bOverride_IndirectLightingIntensity;
  attribute long bOverride_ColorGradingIntensity;
  attribute long bOverride_ColorGradingLUT;
  attribute long bOverride_DepthOfFieldFocalDistance;
  attribute long bOverride_DepthOfFieldFstop;
  attribute long bOverride_DepthOfFieldSensorWidth;
  attribute long bOverride_DepthOfFieldDepthBlurRadius;
  attribute long bOverride_DepthOfFieldDepthBlurAmount;
  attribute long bOverride_DepthOfFieldFocalRegion;
  attribute long bOverride_DepthOfFieldNearTransitionRegion;
  attribute long bOverride_DepthOfFieldFarTransitionRegion;
  attribute long bOverride_DepthOfFieldScale;
  attribute long bOverride_DepthOfFieldMaxBokehSize;
  attribute long bOverride_DepthOfFieldNearBlurSize;
  attribute long bOverride_DepthOfFieldFarBlurSize;
  attribute long bOverride_DepthOfFieldMethod;
  attribute long bOverride_MobileHQGaussian;
  attribute long bOverride_DepthOfFieldBokehShape;
  attribute long bOverride_DepthOfFieldOcclusion;
  attribute long bOverride_DepthOfFieldColorThreshold;
  attribute long bOverride_DepthOfFieldSizeThreshold;
  attribute long bOverride_DepthOfFieldSkyFocusDistance;
  attribute long bOverride_DepthOfFieldVignetteSize;
  attribute long bOverride_MotionBlurAmount;
  attribute long bOverride_MotionBlurMax;
  attribute long bOverride_MotionBlurPerObjectSize;
  attribute long bOverride_ScreenPercentage;
  attribute long bOverride_ScreenSpaceReflectionIntensity;
  attribute long bOverride_ScreenSpaceReflectionQuality;
  attribute long bOverride_ScreenSpaceReflectionMaxRoughness;
  attribute long bOverride_ScreenSpaceReflectionRoughnessScale;
  attribute float WhiteTemp;
  attribute float WhiteTint;
  [Value] attribute FVector4 ColorSaturation;
  [Value] attribute FVector4 ColorContrast;
  [Value] attribute FVector4 ColorGamma;
  [Value] attribute FVector4 ColorGain;
  [Value] attribute FVector4 ColorOffset;
  [Value] attribute FVector4 ColorSaturationShadows;
  [Value] attribute FVector4 ColorContrastShadows;
  [Value] attribute FVector4 ColorGammaShadows;
  [Value] attribute FVector4 ColorGainShadows;
  [Value] attribute FVector4 ColorOffsetShadows;
  attribute float ColorCorrectionShadowsMax;
  [Value] attribute FVector4 ColorSaturationMidtones;
  [Value] attribute FVector4 ColorContrastMidtones;
  [Value] attribute FVector4 ColorGammaMidtones;
  [Value] attribute FVector4 ColorGainMidtones;
  [Value] attribute FVector4 ColorOffsetMidtones;
  [Value] attribute FVector4 ColorSaturationHighlights;
  [Value] attribute FVector4 ColorContrastHighlights;
  [Value] attribute FVector4 ColorGammaHighlights;
  [Value] attribute FVector4 ColorGainHighlights;
  [Value] attribute FVector4 ColorOffsetHighlights;
  attribute float ColorCorrectionHighlightsMin;
  [Value] attribute FLinearColor FilmWhitePoint;
  [Value] attribute FLinearColor FilmShadowTint;
  attribute float FilmShadowTintBlend;
  attribute float FilmShadowTintAmount;
  attribute float FilmSaturation;
  [Value] attribute FLinearColor FilmChannelMixerRed;
  [Value] attribute FLinearColor FilmChannelMixerGreen;
  [Value] attribute FLinearColor FilmChannelMixerBlue;
  attribute float FilmContrast;
  attribute float FilmToeAmount;
  attribute float FilmHealAmount;
  attribute float FilmDynamicRange;
  attribute float FilmSlope;
  attribute float FilmToe;
  attribute float FilmShoulder;
  attribute float FilmBlackClip;
  attribute float FilmWhiteClip;
  [Value] attribute FLinearColor SceneColorTint;
  attribute float SceneFringeIntensity;
  attribute float BloomIntensity;
  attribute float BloomThreshold;
  attribute float BloomSizeScale;
  attribute float Bloom1Size;
  attribute float Bloom2Size;
  attribute float Bloom3Size;
  attribute float Bloom4Size;
  attribute float Bloom5Size;
  attribute float Bloom6Size;
  [Value] attribute FLinearColor Bloom1Tint;
  [Value] attribute FLinearColor Bloom2Tint;
  [Value] attribute FLinearColor Bloom3Tint;
  [Value] attribute FLinearColor Bloom4Tint;
  [Value] attribute FLinearColor Bloom5Tint;
  [Value] attribute FLinearColor Bloom6Tint;
  attribute float BloomDirtMaskIntensity;
  [Value] attribute FLinearColor BloomDirtMaskTint;
  attribute UTexture BloomDirtMask;
  attribute float LPVIntensity;
  attribute float LPVVplInjectionBias;
  attribute float LPVSize;
  attribute float LPVSecondaryOcclusionIntensity;
  attribute float LPVSecondaryBounceIntensity;
  attribute float LPVGeometryVolumeBias;
  attribute float LPVEmissiveInjectionIntensity;
  attribute float LPVDirectionalOcclusionIntensity;
  attribute float LPVDirectionalOcclusionRadius;
  attribute float LPVDiffuseOcclusionExponent;
  attribute float LPVSpecularOcclusionExponent;
  attribute float LPVDiffuseOcclusionIntensity;
  attribute float LPVSpecularOcclusionIntensity;
  [Value] attribute FLinearColor AmbientCubemapTint;
  attribute float AmbientCubemapIntensity;
  attribute UTextureCube AmbientCubemap;
  [Value] attribute TEnumAsByteEAutoExposureMethod AutoExposureMethod;
  attribute float AutoExposureLowPercent;
  attribute float AutoExposureHighPercent;
  attribute float AutoExposureMinBrightness;
  attribute float AutoExposureMaxBrightness;
  attribute float AutoExposureSpeedUp;
  attribute float AutoExposureSpeedDown;
  attribute float AutoExposureBias;
  attribute float HistogramLogMin;
  attribute float HistogramLogMax;
  attribute float LensFlareIntensity;
  [Value] attribute FLinearColor LensFlareTint;
  attribute float LensFlareBokehSize;
  attribute float LensFlareThreshold;
  attribute UTexture LensFlareBokehShape;
  [Value] attribute FLinearColor[] LensFlareTints;
  attribute float VignetteIntensity;
  attribute float GrainJitter;
  attribute float GrainIntensity;
  attribute float AmbientOcclusionIntensity;
  attribute float AmbientOcclusionStaticFraction;
  attribute float AmbientOcclusionRadius;
  attribute long AmbientOcclusionRadiusInWS;
  attribute float AmbientOcclusionFadeDistance;
  attribute float AmbientOcclusionFadeRadius;
  attribute float AmbientOcclusionDistance_DEPRECATED;
  attribute float AmbientOcclusionPower;
  attribute float AmbientOcclusionBias;
  attribute float AmbientOcclusionQuality;
  attribute float AmbientOcclusionMipBlend;
  attribute float AmbientOcclusionMipScale;
  attribute float AmbientOcclusionMipThreshold;
  [Value] attribute FLinearColor IndirectLightingColor;
  attribute float IndirectLightingIntensity;
  attribute float ColorGradingIntensity;
  attribute UTexture ColorGradingLUT;
  [Value] attribute TEnumAsByteEDepthOfFieldMethod DepthOfFieldMethod;
  attribute long bMobileHQGaussian;
  attribute float DepthOfFieldFstop;
  attribute float DepthOfFieldSensorWidth;
  attribute float DepthOfFieldFocalDistance;
  attribute float DepthOfFieldDepthBlurAmount;
  attribute float DepthOfFieldDepthBlurRadius;
  attribute float DepthOfFieldFocalRegion;
  attribute float DepthOfFieldNearTransitionRegion;
  attribute float DepthOfFieldFarTransitionRegion;
  attribute float DepthOfFieldScale;
  attribute float DepthOfFieldMaxBokehSize;
  attribute float DepthOfFieldNearBlurSize;
  attribute float DepthOfFieldFarBlurSize;
  attribute UTexture DepthOfFieldBokehShape;
  attribute float DepthOfFieldOcclusion;
  attribute float DepthOfFieldColorThreshold;
  attribute float DepthOfFieldSizeThreshold;
  attribute float DepthOfFieldSkyFocusDistance;
  attribute float DepthOfFieldVignetteSize;
  attribute float MotionBlurAmount;
  attribute float MotionBlurMax;
  attribute float MotionBlurPerObjectSize;
  attribute float ScreenPercentage;
  attribute float ScreenSpaceReflectionIntensity;
  attribute float ScreenSpaceReflectionQuality;
  attribute float ScreenSpaceReflectionMaxRoughness;
  [Value] attribute FWeightedBlendables WeightedBlendables;
  [Value] attribute TArrayUObjectPtr Blendables_DEPRECATED;

  void OnAfterLoad();
  void AddBlendable([Ref] TScriptInterfaceIBlendableInterface InBlendableObject, float InWeight);
  void RemoveBlendable([Ref] TScriptInterfaceIBlendableInterface InBlendableObject);
  void FPostProcessSettings();
  void SetBaseValues();
};
enum TextureMipGenSettings {
  "TextureMipGenSettings::TMGS_FromTextureGroup",
  "TextureMipGenSettings::TMGS_SimpleAverage",
  "TextureMipGenSettings::TMGS_Sharpen0",
  "TextureMipGenSettings::TMGS_Sharpen1",
  "TextureMipGenSettings::TMGS_Sharpen2",
  "TextureMipGenSettings::TMGS_Sharpen3",
  "TextureMipGenSettings::TMGS_Sharpen4",
  "TextureMipGenSettings::TMGS_Sharpen5",
  "TextureMipGenSettings::TMGS_Sharpen6",
  "TextureMipGenSettings::TMGS_Sharpen7",
  "TextureMipGenSettings::TMGS_Sharpen8",
  "TextureMipGenSettings::TMGS_Sharpen9",
  "TextureMipGenSettings::TMGS_Sharpen10",
  "TextureMipGenSettings::TMGS_NoMipmaps",
  "TextureMipGenSettings::TMGS_LeaveExistingMips",
  "TextureMipGenSettings::TMGS_Blur1",
  "TextureMipGenSettings::TMGS_Blur2",
  "TextureMipGenSettings::TMGS_Blur3",
  "TextureMipGenSettings::TMGS_Blur4",
  "TextureMipGenSettings::TMGS_Blur5",
  "TextureMipGenSettings::TMGS_MAX"
};

enum TextureGroup
{
  "TEXTUREGROUP_World",
  "TEXTUREGROUP_WorldNormalMap",
  "TEXTUREGROUP_WorldSpecular",
  "TEXTUREGROUP_Character",
  "TEXTUREGROUP_CharacterNormalMap",
  "TEXTUREGROUP_CharacterSpecular",
  "TEXTUREGROUP_Weapon",
  "TEXTUREGROUP_WeaponNormalMap",
  "TEXTUREGROUP_WeaponSpecular",
  "TEXTUREGROUP_Vehicle",
  "TEXTUREGROUP_VehicleNormalMap",
  "TEXTUREGROUP_VehicleSpecular",
  "TEXTUREGROUP_Cinematic",
  "TEXTUREGROUP_Effects",
  "TEXTUREGROUP_EffectsNotFiltered",
  "TEXTUREGROUP_Skybox",
  "TEXTUREGROUP_UI",
  "TEXTUREGROUP_Lightmap",
  "TEXTUREGROUP_RenderTarget",
  "TEXTUREGROUP_MobileFlattened",
  "TEXTUREGROUP_ProcBuilding_Face",
  "TEXTUREGROUP_ProcBuilding_LightMap",
  "TEXTUREGROUP_Shadowmap",
  "TEXTUREGROUP_ColorLookupTable",
  "TEXTUREGROUP_Terrain_Heightmap",
  "TEXTUREGROUP_Terrain_Weightmap",
  "TEXTUREGROUP_Bokeh",
  "TEXTUREGROUP_IESLightProfile",
  "TEXTUREGROUP_Pixels2D",
  "TEXTUREGROUP_HierarchicalLOD",
  "TEXTUREGROUP_MAX"
};

interface TEnumAsByteTextureMipGenSettings {
  void TEnumAsByteTextureMipGenSettings();
  void Assign(TextureMipGenSettings InValue);
  long GetValue();
};

interface TEnumAsByteTextureGroup {
  void TEnumAsByteTextureGroup();
  void Assign(TextureGroup InValue);
  long GetValue();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UWorldComposition {
};
interface AStaticMeshActor {
  void AStaticMeshActor();
  UStaticMeshComponent GetStaticMeshComponent();

  void SetMobility(EComponentMobility_Type InMobility);
};
AStaticMeshActor implements AActor;

interface TObjectIteratorAStaticMeshActor {
  void TObjectIteratorAStaticMeshActor();
  boolean Next();
  AActor Current();
};
interface ADirectionalLight {
  void ADirectionalLight();
  void PostLoad();
};
ADirectionalLight implements ALight;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ULevelStreaming {
};
ULevelStreaming implements UObject;

interface TArrayULevelStreaming {
};

interface TArrayULevelStreamingPtr {
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TSubclassOfUDamageType {
};

interface TEnumAsByteECollisionChannel {
};

interface TEnumAsByteESceneDepthPriorityGroup {
};

interface TEnumAsByteEIndirectLightingCacheQuality {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EMovementMode {
  "MOVE_None",
  "MOVE_Walking",
  "MOVE_NavWalking",
  "MOVE_Falling",
  "MOVE_Swimming",
  "MOVE_Flying",
  "MOVE_Custom",
  "MOVE_MAX"
};

enum EComponentMobility_Type {
  "EComponentMobility::Static",
  "EComponentMobility::Stationary",
  "EComponentMobility::Movable"
};

enum ECollisionChannel {
  "ECC_WorldStatic",
  "ECC_WorldDynamic",
  "ECC_Pawn",
  "ECC_Visibility",
  "ECC_Camera",
  "ECC_PhysicsBody",
  "ECC_Vehicle",
  "ECC_Destructible",
  "ECC_EngineTraceChannel1",
  "ECC_EngineTraceChannel2",
  "ECC_EngineTraceChannel3",
  "ECC_EngineTraceChannel4",
  "ECC_EngineTraceChannel5",
  "ECC_EngineTraceChannel6",
  "ECC_GameTraceChannel1",
  "ECC_GameTraceChannel2",
  "ECC_GameTraceChannel3",
  "ECC_GameTraceChannel4",
  "ECC_GameTraceChannel5",
  "ECC_GameTraceChannel6",
  "ECC_GameTraceChannel7",
  "ECC_GameTraceChannel8",
  "ECC_GameTraceChannel9",
  "ECC_GameTraceChannel10",
  "ECC_GameTraceChannel11",
  "ECC_GameTraceChannel12",
  "ECC_GameTraceChannel13",
  "ECC_GameTraceChannel14",
  "ECC_GameTraceChannel15",
  "ECC_GameTraceChannel16",
  "ECC_GameTraceChannel17",
  "ECC_GameTraceChannel18",
  "ECC_OverlapAll_Deprecated",
  "ECC_MAX",
};

enum ECollisionResponse {
  "ECR_Ignore",
  "ECR_Overlap",
  "ECR_Block",
  "ECR_MAX",
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FLightmassLightSettings {
  attribute float IndirectLightingSaturation;
  attribute float ShadowExponent;
  attribute boolean bUseAreaShadowsForStationaryLight;

  void FLightmassLightSettings();
};

interface FLightmassPointLightSettings {
};
FLightmassPointLightSettings implements FLightmassLightSettings;

interface FDamageEvent {
  [Value] attribute TSubclassOfUDamageType DamageTypeClass;
  static readonly attribute long ClassID;

  void FDamageEvent();
  void FDamageEvent([Ref] TSubclassOfUDamageType InDamageTypeClass);
  long GetTypeID();
  boolean IsOfType(long InID);
  void GetBestHitInfo([Const] AActor HitActor, [Const] AActor HitInstigator, [Ref] FHitResult OutHitInfo, [Ref] FVector OutImpulseDir);

  // TODO: some constructors missing due to lack of function overloading
  // void FDamageEvent([Const, Ref] FDamageEvent InDamageEvent)
};

enum ESpawnActorCollisionHandlingMethod {
  "ESpawnActorCollisionHandlingMethod::Undefined",
  "ESpawnActorCollisionHandlingMethod::AlwaysSpawn",
  "ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn",
  "ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding",
  "ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding"
};

enum ELevelCollectionType {
  "ELevelCollectionType::DynamicSourceLevels",
  "ELevelCollectionType::DynamicDuplicatedLevels",
  "ELevelCollectionType::StaticLevels"
};

enum EWorldType_Type {
  "EWorldType::None",
  "EWorldType::Game",
  "EWorldType::Editor",
  "EWorldType::PIE",
  "EWorldType::EditorPreview",
  "EWorldType::GamePreview",
  "EWorldType::Inactive"
};

enum EFlushLevelStreamingType {
  "EFlushLevelStreamingType::None",
  "EFlushLevelStreamingType::Full",
  "EFlushLevelStreamingType::Visibility"
};

enum ESceneDepthPriorityGroup {
  "SDPG_World",
  "SDPG_Foreground",
  "SDPG_MAX"
};

enum EIndirectLightingCacheQuality {
  "ILCQ_Off",
  "ILCQ_Point",
  "ILCQ_Volume"
};

interface FLightingChannels {
  void FLightingChannels();

  attribute boolean bChannel0;
  attribute boolean bChannel1;
  attribute boolean bChannel2;
};

enum ECollisionEnabled_Type {
  "ECollisionEnabled::NoCollision",
  "ECollisionEnabled::QueryOnly",
  "ECollisionEnabled::PhysicsOnly",
  "ECollisionEnabled::QueryAndPhysics"
};

interface FMTDResult {
  [Value] attribute FVector Direction;
  attribute float Distance;
  void FMTDResult();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FOverlapResult {
};

interface FCollisionImpactData {
};

interface TArrayFOverlapResult {
};

interface FWalkableSlopeOverride {
};

interface FCollisionResponseContainer {
};

interface FRigidBodyState {
};

interface FRigidBodyErrorCorrection {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UNetDriver {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UWorldProxy {
  void UWorldProxy();

  [Operator="=="] boolean equal([Const, Ref] UWorldProxy Other);
  UWorld GetReference();

  // TODO: not supported operator
  //inline UWorld* operator->()
  //UWorld& operator*()
  //const UWorld& operator*() const
  //UWorldProxy& operator=(UWorld* InWorld)
  //UWorldProxy& operator=(const UWorldProxy& InProxy)
  //operator UWorld*() const
};

interface FSeamlessTravelHandler {
  void FSeamlessTravelHandler();
  boolean StartTravel(UWorld InCurrentWorld, [Const, Ref] FURL InURL, [Const, Ref] FGuid InGuid);
  boolean IsInTransition();
  boolean HasSwitchedToDefaultMap();
  [Value] FString GetDestinationMapName();
  [Const] UWorld GetLoadedWorld();
  void CancelTravel();
  void SetPauseAtMidpoint(boolean bNowPaused);
  UWorld Tick();
};

interface FLevelStreamingGCHelper {
  [Value] static attribute FOnGCStreamedOutLevelsEvent OnGCStreamedOutLevels;
  static void AddGarbageCollectorCallback();
  static void RequestUnload(ULevel InLevel);
  static void CancelUnloadRequest(ULevel InLevel);
  static void PrepareStreamedOutLevelsForGC();
  static void VerifyLevelsGotRemovedByGC();
  static long GetNumLevelsPendingPurge();
};

interface FLevelViewportInfo {
  [Value] attribute FVector CamPosition;
  [Value] attribute FRotator CamRotation;
  attribute float CamOrthoZoom;
  attribute boolean CamUpdated;

  void FLevelViewportInfo();
  void FLevelViewportInfo([Const, Ref] FVector InCamPosition, [Const, Ref] FRotator InCamRotation, float InCamOrthoZoom);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FLevelViewportInfo& I )
};

interface FStartPhysicsTickFunction {
  attribute UWorld Target;
};
FStartPhysicsTickFunction implements FTickFunction;

interface FEndPhysicsTickFunction {
  attribute UWorld Target;
};
FEndPhysicsTickFunction implements FTickFunction;

interface FStartAsyncSimulationFunction {
  attribute UWorld Target;
};
FStartAsyncSimulationFunction implements FTickFunction;

interface FActorSpawnParameters {
  void FActorSpawnParameters();
  [Value] attribute FName Name;
  attribute AActor Template;
  attribute AActor Owner;
  attribute APawn Instigator;
  attribute ULevel OverrideLevel;
  attribute ESpawnActorCollisionHandlingMethod SpawnCollisionHandlingOverride;

  boolean IsRemoteOwned();
  attribute unsigned long bNoFail;
  attribute unsigned long bDeferConstruction;
  attribute unsigned long bAllowDuringConstructionScript;
  attribute EObjectFlags ObjectFlags;
};

interface FWorldAsyncTraceState {
  void FWorldAsyncTraceState();

  [Ref] AsyncTraceData GetBufferForFrame(long Frame);
  [Ref] AsyncTraceData GetBufferForCurrentFrame();
  [Ref] AsyncTraceData GetBufferForPreviousFrame();

  [Value] readonly attribute AsyncTraceData[] DataBuffer;
  attribute long CurrentFrame;
};

interface FLevelCollection {
  void FLevelCollection();

  ELevelCollectionType GetType();
  void SetType([Const] ELevelCollectionType InType);
  AGameStateBase GetGameState();
  void SetGameState([Const] AGameStateBase InGameState);
  UNetDriver GetNetDriver();
  void SetNetDriver([Const] UNetDriver InNetDriver);
  UDemoNetDriver GetDemoNetDriver();
  void SetDemoNetDriver([Const] UDemoNetDriver InDemoNetDriver);
  [Const, Ref] TSetULevelPtr GetLevels();
  void AddLevel([Const] ULevel Level);
  void RemoveLevel([Const] ULevel Level);
  void SetPersistentLevel([Const] ULevel Level);
  ULevel GetPersistentLevel();
  boolean IsVisible();
  void SetIsVisible([Const] boolean bInIsVisible);

  // TODO: not supported operator
  //FLevelCollection& operator=(FLevelCollection&& Other);
  // TODO: connot override
  //FLevelCollection(FLevelCollection&& Other);
};

interface FScopedLevelCollectionContextSwitch {
};

interface UWorld {
  void UWorld();
  attribute ULevel PersistentLevel;
  attribute UNetDriver NetDriver;
  attribute ULineBatchComponent LineBatcher;
  attribute ULineBatchComponent PersistentLineBatcher;
  attribute ULineBatchComponent ForegroundLineBatcher;
  attribute AGameNetworkManager NetworkManager;
  attribute UPhysicsCollisionHandler PhysicsCollisionHandler;

  [Value] attribute TArrayUObjectPtr ExtraReferencedObjects;
  [Value] attribute TArrayUObjectPtr PerModuleDataObjects;
  [Value] attribute TArrayULevelStreamingPtr StreamingLevels;
  [Value] attribute FString StreamingLevelsPrefix;
  attribute ULevel CurrentLevelPendingVisibility;
  attribute UDemoNetDriver DemoNetDriver;
  attribute AParticleEventManager MyParticleEventManager;
  [Value] attribute TArrayFVector ViewLocationsRenderedLastFrame;
  attribute unsigned long bWorldWasLoadedThisTick;
  attribute unsigned long bTriggerPostLoadMap;

  void SetNavigationSystem(UNavigationSystem InNavigationSystem);
  attribute FSceneInterface Scene;
  attribute ERHIFeatureLevel_Type FeatureLevel;
  boolean SetCurrentLevel(ULevel InLevel);
  ULevel GetCurrentLevel();
  [Value] static attribute TMapFNameEWorldType_Type WorldTypePreLoadMap;
  void CreateFXSystem();
  void SetShouldTick([Const] boolean bInShouldTick);
  boolean ShouldTick();

  [Value] attribute FURL URL;
  attribute FFXSystemInterface FXSystem;
  attribute boolean bInTick;
  attribute boolean bIsBuilt;
  attribute boolean bTickNewlySpawned;
  attribute ETickingGroup TickGroup;
  [Value] attribute FStartPhysicsTickFunction StartPhysicsTickFunction;
  [Value] attribute FEndPhysicsTickFunction EndPhysicsTickFunction;
  [Value] attribute FStartAsyncSimulationFunction StartAsyncTickFunction;
  attribute boolean bPostTickComponentUpdate;
  attribute long PlayerNum;
  attribute float TimeSinceLastPendingKillPurge;
  attribute boolean FullPurgeTriggered;
  attribute boolean bShouldDelayGarbageCollect;
  attribute boolean bIsWorldInitialized;
  attribute long StreamingVolumeUpdateDelay;
  attribute boolean bIsLevelStreamingFrozen;
  attribute boolean bShouldForceUnloadStreamingLevels;
  attribute boolean bShouldForceVisibleStreamingLevels;
  attribute boolean bDoDelayedUpdateCullDistanceVolumes;
  attribute EWorldType_Type WorldType;
  attribute boolean bIsRunningConstructionScript;
  attribute boolean bShouldSimulatePhysics;

  [Value] attribute FName DebugDrawTraceTag;
  [Value] attribute TArrayIInterface_PostProcessVolumePtr PostProcessVolumes;
  [Value] attribute TSetAAudioVolumePtr AudioVolumes;
  attribute unsigned long AudioDeviceHandle;
  attribute double LastTimeUnbuiltLightingWasEncountered;
  attribute float TimeSeconds;
  attribute float UnpausedTimeSeconds;
  attribute float RealTimeSeconds;
  attribute float AudioTimeSeconds;
  attribute float DeltaTimeSeconds;
  attribute float PauseDelay;
  [Value] attribute FIntVector OriginLocation;
  [Value] attribute FIntVector RequestedOriginLocation;
  attribute boolean bOriginOffsetThisFrame;
  attribute UWorldComposition WorldComposition;
  attribute EFlushLevelStreamingType FlushLevelStreamingType;

  attribute ETravelType NextTravelType;
  [Value] attribute FString NextURL;
  attribute float NextSwitchCountdown;
  [Value] attribute TArrayFName PreparingLevelNames;
  [Value] attribute FName CommittedPersistentLevelName;
  attribute unsigned long NumLightingUnbuiltObjects;
  attribute unsigned long NumInvalidReflectionCaptureComponents;
  attribute long NumTextureStreamingUnbuiltComponents;
  attribute long NumTextureStreamingDirtyResources;
  attribute unsigned long bDropDetail;
  attribute unsigned long bAggressiveLOD;
  attribute unsigned long bIsDefaultLevel;
  attribute unsigned long bRequestedBlockOnAsyncLoading;
  attribute unsigned long bActorsInitialized;
  attribute unsigned long bBegunPlay;
  attribute unsigned long bMatchStarted;
  attribute unsigned long bPlayersOnly;
  attribute unsigned long bPlayersOnlyPending;
  attribute unsigned long bStartup;
  attribute unsigned long bIsTearingDown;
  attribute unsigned long bKismetScriptError;
  attribute unsigned long bDebugPauseExecution;
  attribute unsigned long bIsCameraMoveableWhenPaused;
  attribute unsigned long bAllowAudioPlayback;
  attribute unsigned long bDebugFrameStepExecution;
  attribute unsigned long bAreConstraintsDirty;
  [Value] readonly attribute FThreadSafeCounter AsyncPreRegisterLevelStreamingTasks;

  AStaticMeshActor SpawnActorStaticMeshActor();
  APointLight SpawnActorPointLight();
  ADirectionalLight SpawnActorDirectionalLight();

  // TODO: FTickTaskLevel is a private type
  //attribute FTickTaskLevel TickTaskLevel;
};
UWorld implements UObject;
UWorld implements FNetworkNotify;

[Prefix="UWorld::"]
interface InitializationValues {
  void InitializationValues();
  attribute unsigned long bInitializeScenes;
  attribute unsigned long bAllowAudioPlayback;
  attribute unsigned long bRequiresHitProxies;
  attribute unsigned long bCreatePhysicsScene;
  attribute unsigned long bCreateNavigation;
  attribute unsigned long bCreateAISystem;
  attribute unsigned long bShouldSimulatePhysics;
  attribute unsigned long bEnableTraceCollision;
  attribute unsigned long bTransactional;
  attribute unsigned long bCreateFXSystem;

  [Ref] InitializationValues InitializeScenes([Const] boolean bInitialize);
  [Ref] InitializationValues AllowAudioPlayback([Const] boolean bAllow);
  [Ref] InitializationValues RequiresHitProxies([Const] boolean bRequires);
  [Ref] InitializationValues CreatePhysicsScene([Const] boolean bCreate);
  [Ref] InitializationValues CreateNavigation([Const] boolean bCreate);
  [Ref] InitializationValues CreateAISystem([Const] boolean bCreate);
  [Ref] InitializationValues ShouldSimulatePhysics([Const] boolean bInShouldSimulatePhysics);
  [Ref] InitializationValues EnableTraceCollision([Const] boolean bInEnableTraceCollision);
  [Ref] InitializationValues SetTransactional([Const] boolean bInTransactional);
  [Ref] InitializationValues CreateFXSystem([Const] boolean bCreate);
};

interface FWorldDelegates {
	[Value] static attribute FOnWorldTickStart OnWorldTickStart;

	[Value] static attribute FWorldEvent OnPostWorldCreation;
	[Value] static attribute FWorldInitializationEvent OnPreWorldInitialization;
	[Value] static attribute FWorldInitializationEvent OnPostWorldInitialization;

	[Value] static attribute FWorldPostDuplicateEvent OnPostDuplicate;
	[Value] static attribute FWorldCleanupEvent OnWorldCleanup;
	[Value] static attribute FWorldEvent OnPreWorldFinishDestroy;
	[Value] static attribute FOnLevelChanged LevelAddedToWorld;
	[Value] static attribute FOnLevelChanged LevelRemovedFromWorld;
	[Value] static attribute FLevelOffsetEvent PostApplyLevelOffset;
	[Value] static attribute FWorldGetAssetTags GetAssetTags;
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TWeakObjectPtrUWorld {
};

interface TMapFNameEWorldType_Type {
};

[Prefix="FLevelStreamingGCHelper::"]
interface FOnGCStreamedOutLevelsEvent {
};

[Prefix="FWorldDelegates::"]
interface FOnWorldTickStart {
};

[Prefix="FWorldDelegates::"]
interface FWorldEvent {
};

[Prefix="FWorldDelegates::"]
interface FWorldInitializationEvent {
};

[Prefix="FWorldDelegates::"]
interface FWorldPostDuplicateEvent {
};

[Prefix="FWorldDelegates::"]
interface FWorldCleanupEvent {
};

[Prefix="FWorldDelegates::"]
interface FOnLevelChanged {
};

[Prefix="FWorldDelegates::"]
interface FLevelOffsetEvent {
};

[Prefix="FWorldDelegates::"]
interface FWorldGetAssetTags {
};
interface ALight {
  attribute long bEnabled;

  void ALight();
  void OnRep_bEnabled();
  void SetMobility(EComponentMobility_Type InMobility);
  void SetEnabled(boolean bSetEnabled);
  boolean IsEnabled();
  void ToggleEnabled();
  void SetBrightness(float NewBrightness);
  float GetBrightness();
  void SetLightColor([Ref] FLinearColor NewLightColor);
  [Value] FLinearColor GetLightColor();
  void SetLightFunctionMaterial(UMaterialInterface NewLightFunctionMaterial);
  void SetLightFunctionScale([Ref] FVector NewLightFunctionScale);
  void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
  void SetCastShadows(boolean bNewValue);
  void SetAffectTranslucentLighting(boolean bNewValue);
  boolean IsToggleable();
  void Destroyed();
  boolean IsLevelBoundsRelevant();
  ULightComponent GetLightComponent();
};
ALight implements AActor;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UTextureCube {
  void UTextureCube();
};
interface FURL {
  [Value] attribute FString Protocol;
  [Value] attribute FString Host;
  attribute long Port;
  [Value] attribute FString Map;
  [Value] attribute FString RedirectURL;
  [Value] attribute TArrayFString Op;
  [Value] attribute FString Portal;
  attribute long Valid;

  [Value] static attribute FUrlConfig UrlConfig;
  static attribute boolean bDefaultsInitialized;
  void FURL();
  void FURL([Const] TCHAR Filename);
  void FURL(FURL Base, [Const] TCHAR TextURL, ETravelType Type);

  static void StaticInit();
  static void StaticExit();
  boolean IsInternal();
  boolean IsLocalInternal();
  boolean HasOption([Const] TCHAR Test);
  [Const] TCHAR GetOption([Const] TCHAR Match, [Const] TCHAR Default);
  void LoadURLConfig([Const] TCHAR Section, [Const, Ref] FString Filename);
  void SaveURLConfig([Const] TCHAR Section, [Const] TCHAR Item, [Const, Ref] FString Filename);
  void AddOption([Const] TCHAR Str);
  void RemoveOption([Const] TCHAR Key, [Const] TCHAR Section, [Const, Ref] FString Filename);
  [Operator="=="] boolean equal([Const, Ref] FURL Other);

  // TODO: operator not supported
  //ENGINE_API friend FArchive& operator<<( FArchive& Ar, FURL& U );
};

enum ETravelType {
  "TRAVEL_Absolute",
  "TRAVEL_Partial",
  "TRAVEL_Relative",
  "TRAVEL_MAX"
};

enum ETickingGroup {
  "TG_PrePhysics",
  "TG_StartPhysics",
  "TG_DuringPhysics",
  "TG_EndPhysics",
  "TG_PostPhysics",
  "TG_PostUpdateWork",
  "TG_LastDemotable",
  "TG_NewlySpawned",
  "TG_MAX"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FPrimitiveComponentPostPhysicsTickFunction {
};
FPrimitiveComponentPostPhysicsTickFunction implements FTickFunction;

interface FTickFunction {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UTextureLightProfile {
  void UTextureLightProfile();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UCanvas {
};

UCanvas implements UObject;
interface ASkyLight {
  attribute long bEnabled;

  void ASkyLight();
  void OnRep_bEnabled();
  USkyLightComponent GetLightComponent();
};
ASkyLight implements AInfo;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FNetworkNotify {
};
interface APointLight {
  attribute UPointLightComponent PointLightComponent;
  void SetRadius(float NewRadius);
  void SetLightFalloffExponent(float NewLightFalloffExponent);
};
APointLight implements ALight;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface AParticleEventManager {
};
//AParticleEventManager implements AActor;
interface AEmitter {
  [Value] attribute FParticleSpawnSignature OnParticleSpawn;
  [Value] attribute FParticleBurstSignature OnParticleBurst;
  [Value] attribute FParticleDeathSignature OnParticleDeath;
  [Value] attribute FParticleCollisionSignature OnParticleCollide;
  void OnParticleSystemFinished(UParticleSystemComponent FinishedComponent);
  void OnRep_bCurrentlyActive();
  void Activate();
  void Deactivate();
  void ToggleActive();
  boolean IsActive();
  void SetTemplate(UParticleSystem NewTemplate);
  void SetFloatParameter([Ref] FName ParameterName, float Param);
  void SetVectorParameter([Ref] FName ParameterName, [Ref] FVector Param);
  void SetColorParameter([Ref] FName ParameterName, [Ref] FLinearColor Param);
  void SetActorParameter([Ref] FName ParameterName, AActor Param);
  void SetMaterialParameter([Ref] FName ParameterName, UMaterialInterface Param);
  void AutoPopulateInstanceProperties();
  [Value] FString GetDetailedInfoInternal();
  void PostActorCreated();
  void PostInitializeComponents();
  UParticleSystemComponent GetParticleSystemComponent();

  /* TODO */
  /* bitfields are not supported */
  //uint32 bDestroyOnSystemFinish:1;
  //uint32 bPostUpdateTickGroup:1;
  //uint32 bCurrentlyActive:1;
};

AEmitter implements AActor;

/* TODO */
interface FParticleSpawnSignature { };
interface FParticleBurstSignature { };
interface FParticleDeathSignature { };
interface FParticleCollisionSignature { };
interface UParticleSystem { };
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UNavigationSystem {
};
enum ENavDataGatheringMode {
  "ENavDataGatheringMode::Default",
  "ENavDataGatheringMode::Instant",
  "ENavDataGatheringMode::Lazy"
};
[NoDelete]
interface INavRelevantInterface {
  void GetNavigationData([Ref] FNavigationRelevantData Data);
  [Value] FBox GetNavigationBounds();
  boolean SupportsGatheringGeometrySlices();
  void GatherGeometrySlice([Ref] FNavigableGeometryExport GeomExport, [Const, Ref] FBox SliceBox);
  ENavDataGatheringMode GetGeometryGatheringMode();
  void PrepareGeometryExportSync();
  void UpdateNavigationBounds();
  boolean IsNavigationRelevant();
  UObject GetNavigationParent();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface USkeleton {
};
enum ERootMotionRootLock_Type {
  "ERootMotionRootLock::RefPose",
  "ERootMotionRootLock::AnimFirstFrame",
  "ERootMotionRootLock::Zero"
};

interface FPassedMarker {
  [Value] attribute FName PassedMarkerName;
  attribute float DeltaTimeWhenPassed;
};

interface TArrayFPassedMarker {
};

interface UAnimationAsset {
  void TickAssetPlayer([Ref] FAnimTickRecord Instance, [Ref] FAnimNotifyQueue NotifyQueue, [Ref] FAnimAssetTickContext Context);
  float GetMaxCurrentTime();

  void SetSkeleton(USkeleton NewSkeleton);
  void SetSkeletonVirtualBoneGuid([Ref] FGuid Guid);
  void ResetSkeleton(USkeleton NewSkeleton);
  void ValidateSkeleton();

  [Const, Ref] TArrayUAnimMetaDataPtr GetMetaData();
  TArrayFName GetUniqueMarkerNames();

  boolean IsValidAdditive();

  USkeleton GetSkeleton();

  [Value] FGuid GetSkeletonVirtualBoneGuid();
};
UAnimationAsset implements UObject;
UAnimationAsset implements IInterface_AssetUserData;

interface FMarkerPair {
  attribute long MarkerIndex;
  attribute float TimeToMarker;
  void FMarkerPair();
  void Reset();
};

interface FMarkerSyncAnimPosition {
  [Value] attribute FName PreviousMarkerName;
  [Value] attribute FName NextMarkerName;
  attribute float PositionBetweenMarkers;
  boolean IsValid();
  void FMarkerSyncAnimPosition();
  void FMarkerSyncAnimPosition([Const, Ref] FName InPrevMarkerName, [Const, Ref] FName InNextMarkerName, [Const] float InAlpha);
  [Value] FString ToString();
};

interface FAnimTickRecord {
  attribute UAnimationAsset SourceAsset;

  attribute float[] TimeAccumulator;
  attribute float PlayRateMultiplier;
  attribute float EffectiveBlendWeight;
  attribute float RootMotionWeightModifier;
  attribute boolean bLooping;

  attribute FMarkerTickRecord MarkerTickRecord;
  attribute boolean bCanUseMarkerSync;
  attribute float LeaderScore;
  
  float GetRootMotionWeight();  
  void FAnimTickRecord();
  
  // TODO: union can't be exported
  //union
  //{
  //  struct
  //  {
  //    float  BlendSpacePositionX;
  //    float  BlendSpacePositionY;
  //    FBlendFilter* BlendFilter;
  //    TArray<FBlendSampleData>* BlendSampleDataCache;
  //  } BlendSpace;
  //
  //  struct
  //  {
  //    float CurrentPosition;
  //    float PreviousPosition;
  //    float MoveDelta;
  //    TArray<FPassedMarker>* MarkersPassedThisTick;
  //  } Montage;
  //};
  // TODO: operator < is not supported
  //ENGINE_API bool operator <(const FAnimTickRecord& Other) const { return LeaderScore > Other.LeaderScore; }
};

enum ERootMotionMode_Type {
  "ERootMotionMode::NoRootMotionExtraction",
  "ERootMotionMode::IgnoreRootMotion",
  "ERootMotionMode::RootMotionFromEverything",
  "ERootMotionMode::RootMotionFromMontagesOnly"
};

interface FAnimAssetTickContext {
  void FAnimAssetTickContext(float InDeltaTime, ERootMotionMode_Type InRootMotionMode, boolean bInOnlyOneAnimationInGroup, [Const, Ref] TArrayFName ValidMarkerNames);
  void FAnimAssetTickContext(float InDeltaTime, ERootMotionMode_Type InRootMotionMode, boolean bInOnlyOneAnimationInGroup);

  boolean IsLeader();
  boolean IsFollower();
  float GetDeltaTime();
  void SetLeaderDelta(float InLeaderDelta);

  float GetLeaderDelta();
  void SetPreviousAnimationPositionRatio(float NormalizedTime);
  void SetAnimationPositionRatio(float NormalizedTime);

  float GetPreviousAnimationPositionRatio();
  float GetAnimationPositionRatio();
  boolean CanUseMarkerPosition();
  void ConvertToFollower();

  boolean ShouldGenerateNotifies();
  boolean IsSingleAnimationContext();
  [Value] attribute FRootMotionMovementParams RootMotionMovementParams;

  attribute ERootMotionMode_Type RootMotionMode;
  [Value] attribute FMarkerTickContext MarkerTickContext;
};

interface FMarkerTickRecord {
  [Value] attribute FMarkerPair PreviousMarker;
  [Value] attribute FMarkerPair NextMarker;
  boolean IsValid();
  void Reset();
};

interface FAnimExtractContext {
  attribute boolean bExtractRootMotion;
  attribute float CurrentTime;
  [Value] attribute TArrayfloat PoseCurves;

  void FAnimExtractContext();
  void FAnimExtractContext(float InCurrentTime);
  void FAnimExtractContext(float InCurrentTime, boolean InbExtractRootMotion);
  // TODO: override not supported
  //void FAnimExtractContext([Ref] TArrayFloat InPoseCurves);
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRootMotionMovementParams {
};

interface FMarkerTickContext {
};

interface TEnumAsByteERootMotionRootLockType {
};
interface ASkeletalMeshActor {
  attribute USkeletalMesh ReplicatedMesh;
  attribute UPhysicsAsset ReplicatedPhysAsset;
  attribute UMaterialInterface ReplicatedMaterial0;
  attribute UMaterialInterface ReplicatedMaterial1;
  void OnRep_ReplicatedMesh();
  void OnRep_ReplicatedPhysAsset();
  void OnRep_ReplicatedMaterial0();
  void OnRep_ReplicatedMaterial1();
  void PostInitializeComponents();
  void PreviewBeginAnimControl(UInterpGroup InInterpGroup);
  void PreviewSetAnimPosition([Ref] FName SlotName, long ChannelIndex, UAnimSequence InAnimSequence, float InPosition, boolean bLooping, boolean bFireNotifies, float AdvanceTime);
  void PreviewSetAnimWeights([Ref] TArrayFAnimSlotInfo SlotInfos);
  void PreviewFinishAnimControl(UInterpGroup InInterpGroup);
  void GetAnimControlSlotDesc([Ref] TArrayFAnimSlotDesc OutSlotDescs);
  void SetAnimWeights([Const, Ref] TArrayFAnimSlotInfo SlotInfos);
  void BeginAnimControl(UInterpGroup InInterpGroup);
  void SetAnimPosition([Ref] FName SlotName, long ChannelIndex, UAnimSequence InAnimSequence, float InPosition, boolean bFireNotifies, boolean bLooping);
  void FinishAnimControl(UInterpGroup InInterpGroup);
  USkeletalMeshComponent GetSkeletalMeshComponent();
};

ASkeletalMeshActor implements AActor;
ASkeletalMeshActor implements IMatineeAnimInterface;

[NoDelete]
interface IMatineeAnimInterface { };
interface UInterpGroup { };
interface TArrayFAnimSlotInfo { };
interface TArrayFAnimSlotDesc { };
enum ETypeAdvanceAnim {
  "ETAA_Default",
  "ETAA_Finished",
  "ETAA_Looped"
};

interface UAnimSequenceBase {
  [Value] attribute TArrayFAnimNotifyEvent Notifies;
  attribute float SequenceLength;
  attribute float RateScale;
  [Value] attribute FRawCurveTracks RawCurveData;

  float GetPlayLength();
  void SortNotifies();
  void GetAnimNotifies([Const] float StartTime, [Const] float DeltaTime, [Const] boolean bAllowLooping, [Ref] TArrayFAnimNotifyEventConstPtr OutActiveNotifies);
  void GetAnimNotifiesFromDeltaPositions([Const] float PreviousPosition, [Const] float CurrentPosition, [Ref] TArrayFAnimNotifyEventConstPtr OutActiveNotifies);
  void EvaluateCurveData([Ref] FBlendedCurve OutCurve, float CurrentTime, boolean bForceUseRawData);
  void RefreshCacheData();

  void TickByMarkerAsFollower([Ref] FMarkerTickRecord Instance, [Ref] FMarkerTickContext MarkerContext, float CurrentTime, float OutPreviousTime, [Const] float MoveDelta, [Const] boolean bLooping);
  void TickByMarkerAsLeader([Ref] FMarkerTickRecord Instance, [Ref] FMarkerTickContext MarkerContext, float CurrentTime, float OutPreviousTime, [Const] float MoveDelta, [Const] boolean bLooping);
  void GetAnimationPose([Ref] FCompactPose OutPose, [Ref] FBlendedCurve OutCurve, [Const, Ref] FAnimExtractContext ExtractionContext);
  void HandleAssetPlayerTickedInternal([Ref] FAnimAssetTickContext Context, [Const] float PreviousTime, [Const] float MoveDelta, [Const, Ref] FAnimTickRecord Instance, [Ref] FAnimNotifyQueue NotifyQueue);
  boolean HasRootMotion();

  void AdvanceMarkerPhaseAsLeader(boolean bLooping, float MoveDelta, [Const, Ref] TArrayFName ValidMarkerNames, float CurrentTime, [Ref] FMarkerPair PrevMarker, [Ref] FMarkerPair NextMarker, [Ref] TArrayFPassedMarker MarkersPassed);
  void AdvanceMarkerPhaseAsFollower([Const, Ref] FMarkerTickContext Context, float DeltaRemaining, boolean bLooping, float CurrentTime, [Ref] FMarkerPair PreviousMarker, [Ref] FMarkerPair NextMarker);
  void GetMarkerIndicesForTime(float CurrentTime, boolean bLooping, [Const, Ref] TArrayFName ValidMarkerNames, [Ref] FMarkerPair OutPrevMarker, [Ref] FMarkerPair OutNextMarker);
  [Value] FMarkerSyncAnimPosition GetMarkerSyncPositionfromMarkerIndicies(long PrevMarker, long NextMarker, float CurrentTime);
  void GetMarkerIndicesForPosition([Const, Ref] FMarkerSyncAnimPosition SyncPosition, boolean bLooping, [Ref] FMarkerPair OutPrevMarker, [Ref] FMarkerPair OutNextMarker, float CurrentTime);

  float GetFirstMatchingPosFromMarkerSyncPos([Const, Ref] FMarkerSyncAnimPosition InMarkerSyncGroupPosition);
  float GetNextMatchingPosFromMarkerSyncPos([Const, Ref] FMarkerSyncAnimPosition InMarkerSyncGroupPosition, [Const] float StartingPosition);
  float GetPrevMatchingPosFromMarkerSyncPos([Const, Ref] FMarkerSyncAnimPosition InMarkerSyncGroupPosition, [Const] float StartingPosition);

  EAdditiveAnimationType GetAdditiveAnimType();
  boolean CanBeUsedInMontage();
  void EnableRootMotionSettingFromMontage(boolean bInEnableRootMotion, [Const] ERootMotionRootLock_Type InRootMotionRootLock);
  boolean IsNotifyAvailable();
};
UAnimSequenceBase implements UAnimationAsset;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UAnimMontage {
};

interface FAnimMontageInstance {
};
enum EAnimLinkMethod_Type {
  "EAnimLinkMethod::Absolute",
  "EAnimLinkMethod::Relative",
  "EAnimLinkMethod::Proportional"
};

interface FAnimLinkableElement {
  void FAnimLinkableElement();
  void Update();
  void Link(UAnimSequenceBase AnimObject, float AbsTime, long InSlotIndex);
  void LinkMontage(UAnimMontage Montage, float AbsMontageTime, long InSlotIndex);
  void LinkSequence(UAnimSequenceBase Sequence, float AbsSequenceTime);
  void Clear();
  void OnChanged(float NewMontageTime);
  float GetTime(EAnimLinkMethod_Type ReferenceFrame);
  void SetTime(float NewTime, EAnimLinkMethod_Type ReferenceFrame);
  [Const] UAnimSequenceBase GetLinkedSequence();
  [Const] UAnimMontage GetLinkedMontage();
  void ChangeLinkMethod(EAnimLinkMethod_Type NewLinkMethod);
  void ChangeSlotIndex(long NewSlotIndex);
  EAnimLinkMethod_Type GetLinkMethod();
  long GetSlotIndex();
  long GetSegmentIndex();
  void SetSegmentIndex(long NewSegmentIndex);
  boolean ConditionalRelink();
  void RefreshSegmentOnLoad();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UAnimInstance {
};
interface FCompressionMemorySummary {
  void FCompressionMemorySummary(boolean bInEnabled);

  void GatherPreCompressionStats(UAnimSequence Seq,
                                 long ProgressNumerator,
                                 long ProgressDenominator);
  void GatherPostCompressionStats(UAnimSequence Seq,
                                  [Ref] TArrayFBoneData BoneData);
};

interface FAnimCompressContext {
  [Value] attribute FCompressionMemorySummary CompressionSummary;
  attribute long AnimIndex;
  attribute long MaxAnimations;
  attribute boolean bAllowAlternateCompressor;
  attribute boolean bOutput;

  void FAnimCompressContext(boolean bInAllowAlternateCompressor,
                            boolean bInOutput,
                            long InMaxAnimations);
  void GatherPreCompressionStats(UAnimSequence Seq);
  void GatherPostCompressionStats(UAnimSequence Seq,
                                  [Ref] TArrayFBoneData BoneData);
};

interface TSharedPtrFAnimCompressContext {
};

interface UAnimCompress {
  [Value] attribute FString Description;
  attribute long bNeedsSkeleton;
  [Value] attribute TEnumAsByteAnimationCompressionFormat TranslationCompressionFormat;
  [Value] attribute TEnumAsByteAnimationCompressionFormat RotationCompressionFormat;
  [Value] attribute TEnumAsByteAnimationCompressionFormat ScaleCompressionFormat;

  static void BitwiseCompressAnimationTracks(
    UAnimSequence Seq, 
    AnimationCompressionFormat TargetTranslationFormat, 
    AnimationCompressionFormat TargetRotationFormat,
    AnimationCompressionFormat TargetScaleFormat,
    [Const, Ref] TArrayTranslationTrack TranslationData,
    [Const, Ref] TArrayRotationTrack RotationData,
    [Const, Ref] TArrayScaleTrack ScaleData,
    boolean IncludeKeyTable);
};
UAnimCompress implements UObject;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UAnimNotify {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface UAnimNotifyState {
};
interface UAnimMetaData {
};
UAnimMetaData implements UObject;

interface TArrayUAnimMetaDataPtr {
};
enum AnimationCompressionFormat {
  "ACF_None",
  "ACF_Float96NoW",
  "ACF_Fixed48NoW",
  "ACF_IntervalFixed32NoW",
  "ACF_Fixed32NoW",
  "ACF_Float32NoW",
  "ACF_Identity",
  "ACF_MAX"
};

interface TEnumAsByteAnimationCompressionFormat {
};

interface TArrayTranslationTrack {
};

interface TArrayRotationTrack {
};

interface TArrayScaleTrack {
};

interface FTransformArrayA2 {
};

enum AnimationKeyFormat {
  "AKF_ConstantKeyLerp",
  "AKF_VariableKeyLerp",
  "AKF_PerTrackCompression",
  "AKF_MAX"
};

interface TEnumAsByteAnimationKeyFormat {
};

enum EAdditiveBasePoseType {
  "ABPT_None",
  "ABPT_RefPose",
  "ABPT_AnimScaled",
  "ABPT_AnimFrame",
  "ABPT_MAX"
};

interface FRawAnimSequenceTrack {
  [Value] attribute TArrayFVector PosKeys;
  [Value] attribute TArrayFQuat RotKeys;
  [Value] attribute TArrayFVector ScaleKeys;

  // TODO: operator<< is not supported
  //friend FArchive& operator<<( FArchive& Ar, FRawAnimSequenceTrack& T )
};

interface TArrayFRawAnimSequenceTrack {
};

interface FAnimSequenceTrackContainer {
  void FAnimSequenceTrackContainer();
  [Value] attribute TArrayFRawAnimSequenceTrack AnimationTracks;
  [Value] attribute TArrayFName TrackNames;
  void Initialize(long NumNode);
  long GetNum();
  // TODO: function override
  //void Initialize(TArrayFName InTrackNames);
};

interface FTrackToSkeletonMap {
  attribute long BoneTreeIndex;
  void FTrackToSkeletonMap();
  void FTrackToSkeletonMap(long InBoneTreeIndex);
  // TODO: operator<< is not supported
  //friend FArchive& operator<<(FArchive& Ar, FTrackToSkeletonMap &Item);
};

interface TArrayFTrackToSkeletonMap {
};

interface FTranslationTrack {
  void FTranslationTrack();
  [Value] attribute TArrayFVector PosKeys;
  [Value] attribute TArrayfloat Times;
};

interface FRotationTrack {
  void FRotationTrack();
  [Value] attribute TArrayFQuat RotKeys;
  [Value] attribute TArrayfloat Times;
};

interface FScaleTrack {
  void FScaleTrack();
  [Value] attribute TArrayFVector ScaleKeys;
  [Value] attribute TArrayfloat Times;
};

interface FCurveTrack {
  [Value] attribute FName CurveName;

  [Value] attribute TArrayfloat CurveWeights;

  boolean IsValidCurveTrack();
  boolean CompressCurveWeights();
};

interface FCompressedTrack {
  [Value] attribute TArrayuint8 ByteStream;
  [Value] attribute TArrayfloat Times;
  attribute float[] Mins;
  attribute float[] Ranges;

  void FCompressedTrack();
};

interface FCompressedOffsetData {
  [Value] attribute TArrayint32 OffsetData;
  attribute long StripSize;

  void FCompressedOffsetData(long InStripSize);
  void SetStripSize(long InStripSize);
  long GetOffsetData(long StripIndex, long Offset);
  void SetOffsetData(long StripIndex, long Offset, long Value);
  void AddUninitialized(long NumOfTracks);
  void Empty(long NumOfTracks);
  long GetMemorySize();
  long GetNumTracks();
  boolean IsValid();
};

interface UAnimSequence {
  attribute long NumFrames;

  [Value] attribute TEnumAsByteAnimationCompressionFormat TranslationCompressionFormat;
  [Value] attribute TEnumAsByteAnimationCompressionFormat RotationCompressionFormat;
  [Value] attribute TEnumAsByteAnimationCompressionFormat ScaleCompressionFormat;

  [Value] attribute TArrayint32 CompressedTrackOffsets;
  [Value] attribute FCompressedOffsetData CompressedScaleOffsets;
  [Value] attribute TArrayuint8 CompressedByteStream;
  [Value] attribute TEnumAsByteAnimationKeyFormat KeyEncodingFormat;

  attribute AnimEncoding TranslationCodec;
  attribute AnimEncoding RotationCodec;
  attribute AnimEncoding ScaleCodec;

  [Value] attribute FRawCurveTracks CompressedCurveData;
  [Value] attribute TEnumAsByteEAdditiveAnimationType AdditiveAnimType;
  [Value] attribute TEnumAsByteEAdditiveBasePoseType RefPoseType;

  attribute UAnimSequence RefPoseSeq;
  attribute long RefFrameIndex;
  attribute long EncodingPkgVersion;
  [Value] attribute FName RetargetSource;
  attribute EAnimInterpolationType Interpolation;
  attribute boolean bEnableRootMotion;
  [Value] attribute TEnumAsByteERootMotionRootLockType RootMotionRootLock;
  attribute boolean bForceRootLock;
  attribute boolean bRootMotionSettingsCopiedFromMontage;
  [Value] attribute TArrayFAnimSyncMarker AuthoredSyncMarkers;
  [Value] attribute TArrayFName UniqueMarkerNames;
  TArrayFName GetUniqueMarkerNames();
  void EvaluateCurveData([Ref] FBlendedCurve OutCurve, float CurrentTime, boolean bForceUseRawData);
  [Value] FTransform ExtractRootMotion(float StartTime, float DeltaTime, boolean bAllowLooping);
  [Value] FTransform ExtractRootMotionFromRange(float StartTrackPosition, float EndTrackPosition);
  [Value] FTransform ExtractRootTrackTransform(float Pos, [Const] FBoneContainer RequiredBones);

  void GetBonePose([Ref] FCompactPose OutPose,
                   [Ref] FBlendedCurve OutCurve,
                   [Const, Ref] FAnimExtractContext ExtractionContext,
                   boolean bForceUseRawData);

  [Const, Value] TArrayFRawAnimSequenceTrack GetRawAnimationData();
  [Const, Ref] TArrayFTrackToSkeletonMap GetRawTrackToSkeletonMapTable();
  [Const, Ref] TArrayFTrackToSkeletonMap GetCompressedTrackToSkeletonMapTable();
  [Value] FRawAnimSequenceTrack GetRawAnimationTrack(long TrackIndex);

  void GetBonePose_Additive([Ref] FCompactPose OutPose,
                            [Ref] FBlendedCurve OutCurve,
                            [Const, Ref] FAnimExtractContext ExtractionContext);
  void GetAdditiveBasePose([Ref] FCompactPose OutPose,
                           [Ref] FBlendedCurve OutCurve,
                           [Const, Ref] FAnimExtractContext ExtractionContext);
  void GetBoneTransform([Ref] FTransform OutAtom,
                        long TrackIndex,
                        float Time,
                        boolean bUseRawData);
  void ExtractBoneTransform(
      [Const, Ref] TArrayFRawAnimSequenceTrack InRawAnimationData,
      [Ref] FTransform OutAtom,
      long TrackIndex,
      float Time);
  long GetApproxRawSize();
  long GetApproxCompressedSize();

  void RequestAnimCompression(boolean bAsyncCompression,
                              boolean AllowAlternateCompressor,
                              boolean bOutput);
  void RequestAnimCompression(boolean bAsyncCompression,
                              TSharedPtrFAnimCompressContext CompressContext);
  void RequestSyncAnimRecompression(boolean bOutput);

  void SerializeCompressedData([Ref] FArchive Ar, boolean bDDCData);
  long GetSkeletonIndexFromRawDataTrackIndex([Const] long TrackIndex);
  long GetSkeletonIndexFromCompressedDataTrackIndex([Const] long TrackIndex);
  void RecycleAnimSequence();

  static boolean CopyAnimSequenceProperties(UAnimSequence SourceAnimSeq,
                                            UAnimSequence DestAnimSeq,
                                            boolean bSkipCopyingNotifies);
  static boolean CopyNotifies(UAnimSequence SourceAnimSeq,
                              UAnimSequence DestAnimSeq);
  void SortSyncMarkers();

  float GetCurrentTimeFromMarkers([Ref] FMarkerPair PrevMarker,
                                  [Ref] FMarkerPair NextMarker,
                                  float PositionBetweenMarkers);
  void AdvanceMarkerPhaseAsLeader(boolean bLooping,
                                  float MoveDelta,
                                  [Const, Ref] TArrayFName ValidMarkerNames,
                                  float CurrentTime,
                                  [Ref] FMarkerPair PrevMarker,
                                  [Ref] FMarkerPair NextMarker,
                                  [Ref] TArrayFPassedMarker MarkersPassed);
  void AdvanceMarkerPhaseAsFollower([Const, Ref] FMarkerTickContext Context,
                                    float DeltaRemaining,
                                    boolean bLooping,
                                    float CurrentTime,
                                    [Ref] FMarkerPair PreviousMarker,
                                    [Ref] FMarkerPair NextMarker);
  void GetMarkerIndicesForTime(float CurrentTime,
                               boolean bLooping,
                               [Const, Ref] TArrayFName ValidMarkerNames,
                               [Ref] FMarkerPair OutPrevMarker,
                               [Ref] FMarkerPair OutNextMarker);
  [Value] FMarkerSyncAnimPosition GetMarkerSyncPositionfromMarkerIndicies(
      long PrevMarker,
      long NextMarker,
      float CurrentTime);
  void GetMarkerIndicesForPosition(
      [Const, Ref] FMarkerSyncAnimPosition SyncPosition,
      boolean bLooping,
      [Ref] FMarkerPair OutPrevMarker,
      [Ref] FMarkerPair OutNextMarker,
      float CurrentTime);

  attribute boolean bCompressionInProgress;

  // TODO: function override is not supported
  //void ExtractBoneTransform([Const, Ref] FRawAnimSequenceTrack InRawAnimationTrack, [Ref] FTransform OutAtom, float Time);
  //void ExtractBoneTransform([Const] FRawAnimSequenceTrack RawTrack, [Ref] FTransform OutAtom, long KeyIndex);

  // TODO: Functions declarated in header but defined in WITH_EDITOE macro
  //boolean CompressRawAnimSequenceTrack([Ref] FRawAnimSequenceTrack RawTrack, float MaxPosDiff, float MaxAngleDiff);
  //boolean CompressRawAnimData(float MaxPosDiff, float MaxAngleDiff);
  //boolean CompressRawAnimData();
  //void FlipRotationWForNonRoot(USkeletalMesh SkelMesh);
  //boolean IsCompressedDataValid();
};
UAnimSequence implements UAnimSequenceBase;

interface FScopedAnimSequenceRawDataCache {
  attribute UAnimSequence SrcAnim;
  [Value] attribute TArrayFRawAnimSequenceTrack RawAnimationData;
  [Value] attribute TArrayFRawAnimSequenceTrack TemporaryAdditiveBaseAnimationData;
  [Value] attribute TArrayFName AnimationTrackNames;
  [Value] attribute TArrayFTrackToSkeletonMap TrackToSkeletonMapTable;
  [Value] attribute FRawCurveTracks RawCurveData;
  attribute boolean bWasEmpty;

  void FScopedAnimSequenceRawDataCache();
  void InitFrom(UAnimSequence Src);
  void RestoreTo(UAnimSequence Src);
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteEAdditiveBasePoseType {
};
interface FRootMotionExtractionStep {
  attribute UAnimSequence AnimSequence;
  attribute float StartPosition;
  attribute float EndPosition;

  void FRootMotionExtractionStep();

  void FRootMotionExtractionStep(UAnimSequence InAnimSequence,
                                 float InStartPosition,
                                 float InEndPosition);
};

interface TArrayFRootMotionExtractionStep {
};

interface FAnimSegment {
  attribute UAnimSequenceBase AnimReference;

  attribute float StartPos;
  attribute float AnimStartTime;

  attribute float AnimEndTime;
  attribute float AnimPlayRate;

  attribute long LoopingCount;

  void FAnimSegment();
  float GetValidPlayRate();
  float GetLength();
  boolean IsInRange(float CurPos);
  boolean IsIncluded(float InStartPos, float InEndPos);
  UAnimSequenceBase GetAnimationData(float PositionInTrack,
                                     float PositionInAnim,
                                     float Weight);
  float ConvertTrackPosToAnimPos([Const] float TrackPosition);

  void GetAnimNotifiesFromTrackPositions(
      [Const] float PreviousTrackPosition,
      [Const] float CurrentTrackPositiol,
      [Ref] TArrayFAnimNotifyEventConstPtr OutActiveNotifies);
	
  void GetRootMotionExtractionStepsForTrackRange(
      [Ref] TArrayFRootMotionExtractionStep RootMotionExtractionSteps,
      [Const] float StartPosition,
      [Const] float EndPosition);

  boolean IsValid();

  boolean IsNotifyAvailable();
};

interface FAnimTrack {
  [Value] attribute TArrayFAnimSegment AnimSegments;

  void FAnimTrack();
  float GetLength();
  boolean IsAdditive();
  boolean IsRotationOffsetAdditive();

  long GetTrackAdditiveType();
  boolean HasRootMotion();

  void GetRootMotionExtractionStepsForTrackRange(
      [Ref] TArrayFRootMotionExtractionStep RootMotionExtractionSteps,
      [Const] float StartTrackPosition,
      [Const] float EndTrackPosition);
  void ValidateSegmentTimes();
  boolean IsValidToAdd([Const] UAnimSequenceBase SequenceBase);

  long GetSegmentIndexAtTime(float InTime);
  FAnimSegment GetSegmentAtTime(float InTime);

  void GetAnimationPose([Ref] FCompactPose OutPose,
                        [Ref] FBlendedCurve OutCurve,
                        [Const, Ref] FAnimExtractContext ExtractionContext);
  void EnableRootMotionSettingFromMontage(
      boolean bInEnableRootMotion,
      [Const] ERootMotionRootLock_Type InRootMotionRootLock);
  void InvalidateRecursiveAsset(UAnimCompositeBase CheckAsset);
  boolean ContainRecursive(
      [Const, Ref] TArrayUAnimCompositeBasePtr CurrentAccumulatedList);
  void GetAnimNotifiesFromTrackPositions(
      [Const] float PreviousTrackPosition,
      [Const] float CurrentTrackPosition,
      [Ref] TArrayFAnimNotifyEventConstPtr OutActiveNotifies);
  boolean IsNotifyAvailable();
};

interface UAnimCompositeBase {
  void PostLoad();
  void ExtractRootMotionFromTrack([Const, Ref] FAnimTrack SlotAnimTrack,
                                  float StartTrackPosition,
                                  float EndTrackPosition,
                                  [Ref] FRootMotionMovementParams RootMotion);
  void InvalidateRecursiveAsset();
  boolean ContainRecursive(
      [Ref] TArrayUAnimCompositeBasePtr CurrentAccumulatedList);
};
UAnimCompositeBase implements UAnimSequenceBase;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFAnimSegment {
};

interface TArrayUAnimCompositeBase {
};

interface TArrayUAnimCompositeBasePtr {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UMovementComponent {
};

// TODO: UActorComponent is a tricky class, let's leave it for now...
// UMovementComponent implements UActorComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface AController {
  void AController();
};

AController implements INavAgentInterface;

// TODO: AController hides AActor's functions so this cannot be exported
// AController implements AActor;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface UPawnMovementComponent {
  void SetUpdatedComponent(USceneComponent NewUpdatedComponent);
  void AddInputVector([Ref] FVector WorldVector, boolean bForce);
  [Value] FVector GetPendingInputVector();
  [Value] FVector GetLastInputVector();
  [Value] FVector ConsumeInputVector();
  boolean IsMoveInputIgnored();
  APawn GetPawnOwner();
  void NotifyBumpedPawn(APawn BumpedPawn);
  void RequestPathMove([Const, Ref] FVector MoveInput);
  void Serialize([Ref] FArchive Ar);
};

UPawnMovementComponent implements UNavMovementComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UCharacterMovementComponent {
  void UCharacterMovementComponent();
};

UCharacterMovementComponent implements UPawnMovementComponent;

// TODO: should be exported in further phase of the export task
// UCharacterMovementComponent implements IRVOAvoidanceInterface;
// UCharacterMovementComponent implements INetworkPredictionInterface;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface APawn {
};

APawn implements AActor;
APawn implements INavAgentInterface;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TSubclassOfUActorComponent {
};

interface TArrayFLifetimeProperty {
};

interface TArrayFSimulatedRootMotionReplicatedMove {
};

interface FCharacterReachedApexSignature {
};

interface FLandedSignature {
};

interface FMovementModeChangedSignature {
};

interface FCharacterMovementUpdatedSignature {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FRepRootMotionMontage {
  attribute boolean bIsActive;
  attribute UAnimMontage AnimMontage;
  attribute float Position;
  attribute UPrimitiveComponent MovementBase;
  attribute boolean bRelativePosition;
  attribute boolean bRelativeRotation;
  [Value] attribute FVector_NetQuantize100 Location;
  [Value] attribute FRotator Rotation;
  [Value] attribute FName MovementBaseBoneName;
  [Value] attribute FRootMotionSourceGroup AuthoritativeRootMotion;
  [Value] attribute FVector_NetQuantize10 Acceleration;
  [Value] attribute FVector_NetQuantize10 LinearVelocity;

  void Clear();
  boolean HasRootMotion();
};

interface FSimulatedRootMotionReplicatedMove {
  attribute float Time;
  [Value] attribute FRepRootMotionMontage RootMotion;
};

interface FBasedMovementInfo {
  attribute UPrimitiveComponent MovementBase;
  [Value] attribute FName BoneName;
  [Value] attribute FVector_NetQuantize100 Location;
  [Value] attribute FRotator Rotation;
  attribute boolean bServerHasBaseComponent;
  attribute boolean bRelativeRotation;
  attribute boolean bServerHasVelocity;

  boolean HasRelativeLocation();
  boolean HasRelativeRotation();
  boolean IsBaseUnresolved();
};

interface ACharacter {
  attribute float CrouchedEyeHeight;
  attribute unsigned long bIsCrouched;
  attribute unsigned long bReplayHasRootMotionSources;
  attribute unsigned long bPressedJump;
  attribute unsigned long bClientUpdating;
  attribute unsigned long bClientWasFalling;
  attribute unsigned long bClientResimulateRootMotion;
  attribute unsigned long bClientResimulateRootMotionSources;
  attribute unsigned long bSimGravityDisabled;
  attribute unsigned long bClientCheckEncroachmentOnNetUpdate;
  attribute unsigned long bServerMoveIgnoreRootMotion;
  attribute float JumpKeyHoldTime;
  attribute float JumpMaxHoldTime;
  attribute long JumpMaxCount;
  attribute long JumpCurrentCount;
  attribute unsigned long bWasJumping;
  [Value] attribute FRootMotionMovementParams ClientRootMotionParams;
  [Value] attribute TArrayFSimulatedRootMotionReplicatedMove RootMotionRepMoves;
  [Value] attribute FCharacterReachedApexSignature OnReachedJumpApex;
  [Value] attribute FLandedSignature LandedDelegate;
  [Value] attribute FMovementModeChangedSignature MovementModeChangedDelegate;
  [Value] attribute FCharacterMovementUpdatedSignature OnCharacterMovementUpdated;
  [Value] attribute FRootMotionSourceGroup SavedRootMotion;
  [Value] attribute FRepRootMotionMontage RepRootMotion;
  [Value] static attribute FName MeshComponentName;
  [Value] static attribute FName CharacterMovementComponentName;
  [Value] static attribute FName CapsuleComponentName;

  void ACharacter();
  void GetLifetimeReplicatedProps([Ref] TArrayFLifetimeProperty OutLifetimeProps);
  void OnRep_ReplicatedBasedMovement();
  void SetReplicateMovement(boolean bInReplicateMovement);
  float GetReplicatedServerLastTransformUpdateTimeStamp();
  [Value] FVector GetNavAgentLocation();
  void OnRep_IsCrouched();
  void ClearCrossLevelReferences();
  void PreNetReceive();
  void PostNetReceive();
  void OnRep_ReplicatedMovement();
  void PostNetReceiveLocationAndRotation();
  void GetSimpleCollisionCylinder(float CollisionRadius, float CollisionHalfHeight);
  void Jump();
  void StopJumping();
  boolean CanJump();
  boolean IsJumpProvidingForce();
  void CheckJumpInput(float DeltaTime);
  void ClearJumpInput();
  float GetJumpMaxHoldTime();
  void ClientCheatWalk();
  void ClientCheatWalk_Implementation();
  void ClientCheatFly();
  void ClientCheatFly_Implementation();
  void ClientCheatGhost();
  void ClientCheatGhost_Implementation();
  void SaveRelativeBasedMovement([Const, Ref] FVector NewRelativeLocation, [Const, Ref] FRotator NewRotation, boolean bRelativeRotation);
  unsigned short GetReplicatedMovementMode();
  [Value] FVector GetBaseTranslationOffset();
  [Value] FQuat GetBaseRotationOffset();
  [Value] FRotator GetBaseRotationOffsetRotator();
  void PostInitializeComponents();
  float GetDefaultHalfHeight();
  void TurnOff();
  void TornOff();
  void Restart();
  void PawnClientRestart();
  void RecalculateBaseEyeHeight();
  void UpdateNavigationRelevance();
  void UnPossessed();
  void OnLaunched([Ref] FVector LaunchVelocity, boolean bXYOverride, boolean bZOverride);
  void OnJumped_Implementation();
  void Falling();
  void NotifyJumpApex();
  void LaunchCharacter([Ref] FVector LaunchVelocity, boolean bXYOverride, boolean bZOverride);
  void OnWalkingOffLedge([Const, Ref] FVector PreviousFloorImpactNormal, [Const, Ref] FVector PreviousFloorContactNormal, [Const, Ref] FVector PreviousLocation, float TimeDelta);
  void OnWalkingOffLedge_Implementation([Const, Ref] FVector PreviousFloorImpactNormal, [Const, Ref] FVector PreviousFloorContactNormal, [Const, Ref] FVector PreviousLocation, float TimeDelta);
  void Crouch(boolean bClientSimulation);
  void UnCrouch(boolean bClientSimulation);
  boolean CanCrouch();
  void OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
  void K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
  void OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
  void K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
  void K2_UpdateCustomMovement(float DeltaTime);
  void OnUpdateSimulatedPosition([Const, Ref] FVector OldLocation, [Const, Ref] FQuat OldRotation);
  void OnRep_RootMotion();
  void SimulatedRootMotionPositionFixup(float DeltaSeconds);
  boolean IsPlayingRootMotion();
  boolean IsPlayingNetworkedRootMotionMontage();
  void SetAnimRootMotionTranslationScale(float InAnimRootMotionTranslationScale);
  float GetAnimRootMotionTranslationScale();
  void SetBase(UPrimitiveComponent NewBase, [Const, Ref] FName BoneName, boolean bNotifyActor);
  UPrimitiveComponent GetMovementBase();
  UPawnMovementComponent GetMovementComponent();
  [Const, Ref] FBasedMovementInfo GetBasedMovement();
  [Const, Ref] FBasedMovementInfo GetReplicatedBasedMovement();
  USkeletalMeshComponent GetMesh();
  UAnimMontage GetCurrentMontage();
  void PossessedBy(AController NewController);
  void MoveBlockedBy([Const, Ref] FHitResult Impact);
  void Landed([Const, Ref] FHitResult Hit);
  void OnLanded([Const, Ref] FHitResult Hit);
  boolean ShouldNotifyLanded([Const, Ref] FHitResult Hit);
  UActorComponent FindComponentByClass([Const, Ref] TSubclassOfUActorComponent ComponentClass);
  float PlayAnimMontage(UAnimMontage AnimMontage, float InPlayRate, [Ref] FName StartSectionName);
  void StopAnimMontage(UAnimMontage AnimMontage);
  void OnMovementModeChanged(EMovementMode PrevMovementMode, short PreviousCustomMode);
  void K2_OnMovementModeChanged(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, short PrevCustomMode, short NewCustomMode);
  void SetupPlayerInputComponent(UInputComponent PlayerInputComponent);
  void DisplayDebug(UCanvas Canvas, [Const, Ref] FDebugDisplayInfo DebugDisplay, float YL, float YPos);
  void ApplyDamageMomentum(float DamageTaken, [Const, Ref] FDamageEvent DamageEvent, APawn PawnInstigator, AActor DamageCauser);
  long FindRootMotionRepMove([Const, Ref] FAnimMontageInstance ClientMontageInstance);
  boolean CanUseRootMotionRepMove([Const, Ref] FSimulatedRootMotionReplicatedMove RootMotionRepMove, [Const, Ref] FAnimMontageInstance ClientMontageInstance);
  boolean RestoreReplicatedMove([Const, Ref] FSimulatedRootMotionReplicatedMove RootMotionRepMove);
  FAnimMontageInstance GetRootMotionAnimMontageInstance();
  void PreReplication([Ref] IRepChangedPropertyTracker ChangedPropertyTracker);
  UCharacterMovementComponent GetCharacterMovement();
  UCapsuleComponent GetCapsuleComponent();

  // TODO: cannot create constructor with parameters when NewObject is used
  // void ACharacter([Const, Ref] FObjectInitializer ObjectInitializer);

  // TODO: Which classes should be put as T?
  // template<class T>
  // T* FindComponentByClass() const
  // {
  //     return AActor::FindComponentByClass<T>();
  // }
};

ACharacter implements APawn;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UNavMovementComponent {
};

UNavMovementComponent implements UMovementComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface AVolume {
};
interface AActor {
  void AActor();
  [Value] FTransform GetActorTransform();
  boolean SetActorTransform([Const, Ref] FTransform NewTransform);
  [Value] FVector GetActorLocation();
  boolean SetActorLocation([Const, Ref] FVector NewLocation);
  [Value] FRotator GetActorRotation();
  boolean SetActorRotation([Const, Ref] FRotator NewRotation);
  [Value] FVector GetActorScale3D();
  void SetActorScale3D([Const, Ref] FVector NewScale3D);
  [Value] FVector GetActorForwardVector();
  [Value] FVector GetActorUpVector();
  [Value] FVector GetActorRightVector();
};
AActor implements UObject;


interface TArrayAActor {
};

interface TArrayAActorPtr {
};

interface TSetAActorPtr {
};

interface TSubclassOfAActor {
};

interface TSubclassOfAActorPtr {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface AGameNetworkManager {
};
interface AInfo {
  void AInfo();
  boolean IsLevelBoundsRelevant();
};
AInfo implements AActor;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRootMotionSourceGroup {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface AGameStateBase {
};
// TODO: AGameStateBase derives from AInfo but hides some of functions
//AGameStateBase implements AInfo;
interface UMaterial {
  void UMaterial();
};
UMaterial implements UMaterialInterface;
interface UMaterialInterface {
  void UMaterialInterface();
};
UMaterialInterface implements UObject;

interface TArrayUMaterialInterfacePtr {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ACameraActor {
  void ACameraActor();
};
ACameraActor implements UObject;

interface TObjectIteratorACameraActor {
  void TObjectIteratorACameraActor();
  boolean Next();
  AActor Current();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TEnumAsByteEAspectRatioAxisConstraint {
  void TEnumAsByteEAspectRatioAxisConstraint();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum ECameraProjectionMode_Type {
  "ECameraProjectionMode::Perspective",
  "ECameraProjectionMode::Orthographic"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FMinimalViewInfo {
  [Value] attribute FVector Location;
  [Value] attribute FRotator Rotation;
  attribute float FOV;
  attribute float OrthoWidth;
  attribute float OrthoNearClipPlane;
  attribute float OrthoFarClipPlane;
  attribute float AspectRatio;
  attribute long bConstrainAspectRatio;
  attribute long bUseFieldOfViewForLOD;
  [Value] attribute TEnumAsByteECameraProjectionModeType ProjectionMode;
  attribute float PostProcessBlendWeight;
  [Value] attribute FPostProcessSettings PostProcessSettings;
  [Value] attribute FVector2D OffCenterProjectionOffset;

  void FMinimalViewInfo();
  boolean Equals([Const, Ref] FMinimalViewInfo OtherInfo);
  void BlendViewInfo([Ref] FMinimalViewInfo OtherInfo, float OtherWeight);
  void ApplyBlendWeight([Const] float Weight);
  void AddWeightedViewInfo([Const,Ref] FMinimalViewInfo OtherView, [Const] float Weight);
  static void CalculateProjectionMatrixGivenView(
      [Ref] FMinimalViewInfo ViewInfo,
      [Ref] TEnumAsByteEAspectRatioAxisConstraint AspectRatioAxisConstraint,
      FViewport Viewport,
      [Ref] FSceneViewProjectionData InOutProjectionData);
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TArrayFPostProcessSettings {
  void TArrayFPostProcessSettings();
};

interface TEnumAsByteECameraProjectionModeType {
  void TEnumAsByteECameraProjectionModeType();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface UCameraComponent {
  [Value] attribute TEnumAsByteECameraProjectionModeType ProjectionMode;
  attribute float PostProcessBlendWeight;
  [Value] attribute FPostProcessSettings PostProcessSettings;
  attribute long bUseControllerViewRotation_DEPRECATED;

  void SetProjectionMode(ECameraProjectionMode_Type InProjectionMode);
  void SetPostProcessBlendWeight(float InPostProcessBlendWeight);
  void OnRegister();
  void PostLoad();
  void Serialize([Ref] FArchive Ar);
  void GetCameraView(float DeltaTime, [Ref] FMinimalViewInfo DesiredView);
  void AddOrUpdateBlendable([Ref] TScriptInterfaceIBlendableInterface InBlendableObject, float InWeight);
  void AddAdditiveOffset([Const, Ref] FTransform Transform, float FOV);
  void ClearAdditiveOffset();
  void AddExtraPostProcessBlend([Const, Ref] FPostProcessSettings PPSettings, float PPBlendWeight);
  void ClearExtraPostProcessBlends();
  void GetExtraPostProcessBlends([Ref] TArrayFPostProcessSettings OutSettings, [Ref] TArrayfloat OutWeights);
  void NotifyCameraCut();
};

UCameraComponent implements USceneComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRuntimeFloatCurve {
};
enum EMaxConcurrentResolutionRule_Type {
  "EMaxConcurrentResolutionRule::PreventNew",
  "EMaxConcurrentResolutionRule::StopOldest",
  "EMaxConcurrentResolutionRule::StopFarthestThenPreventNew",
  "EMaxConcurrentResolutionRule::StopFarthestThenOldest",
  "EMaxConcurrentResolutionRule::StopLowestPriority",
  "EMaxConcurrentResolutionRule::StopQuietest",
  "EMaxConcurrentResolutionRule::StopLowestPriorityThenPreventNew"
};

interface USoundConcurrency {
  [Value] attribute FSoundConcurrencySettings Concurrency;
};
USoundConcurrency implements UObject;

interface FSoundConcurrencySettings {
  attribute long MaxCount;
  attribute unsigned long bLimitToOwner;
  [Value] attribute TEnumAsByteEMaxConcurrentResolutionRule ResolutionRule;
  attribute float VolumeScale;

  void FSoundConcurrencySettings();
};

interface FConcurrencyGroup {
  void FConcurrencyGroup();
  void FConcurrencyGroup(FActiveSound ActiveSound);
  [Ref] TArrayFActiveSoundPtr GetActiveSounds();
  [Const] long GetNumActiveSounds();
  [Const] long GetGeneration();
  void AddActiveSound(FActiveSound ActiveSound);
  void StopQuietSoundsDueToMaxConcurrency();

  unsigned long GetID();

  // TODO: not supported operator
  //FConcurrencyGroup& operator=([Const, Ref] FConcurrencyGroup Other);
  //FConcurrencyGroup& operator=([Const, Ref] FConcurrencyGroup& Other);
  // TODO: constructor override
  //FConcurrencyGroup(const FConcurrencyGroup&& Other);
  //void FConcurrencyGroup([Const, Ref] FConcurrencyGroup Other);
};

interface FSoundInstanceEntry {
  [Value] attribute TMapuint32uint32 SoundInstanceToConcurrencyGroup;
  void FSoundInstanceEntry(unsigned long SoundObjectID, unsigned long GroupID);
};

interface FOwnerConcurrencyMapEntry {
  [Value] attribute TMapuint32uint32 ConcurrencyObjectToConcurrencyGroup;
  void FOwnerConcurrencyMapEntry(unsigned long ConcurrencyObjectID,
                                 unsigned long GroupID);
};

interface FSoundConcurrencyManager {
  void FSoundConcurrencyManager(FAudioDevice InAudioDevice);
  FActiveSound CreateNewActiveSound([Const, Ref] FActiveSound NewActiveSound);
  void RemoveActiveSound(FActiveSound ActiveSound);
  void StopQuietSoundsDueToMaxConcurrency();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteEMaxConcurrentResolutionRule {
};
interface USoundEffectBase {
  boolean IsActive();
  void Disable();
  void Enable();
  void SetPreset(USoundEffectPreset InPreset);
};
USoundEffectBase implements UObject;
interface FPresetSettings {
  attribute VoidPtr Data;
  attribute unsigned long Size;
  attribute UScriptStruct Struct;

  void FPresetSettings();
};

interface USoundEffectPreset {
  void GetSettings();
  unsigned long GetSettingsSize();
  UScriptStruct GetSettingsStruct();
  UClass GetEffectClass();
  [Value] FText GetAssetActionName();

  [Const, Ref] FPresetSettings GetPresetSettings();

  // TODO: unresolved symbol
  //void RegisterAssetTypeAction();
};
USoundEffectPreset implements UObject;
interface UReverbEffect {
  attribute float Density;
  attribute float Diffusion;
  attribute float Gain;
  attribute float GainHF;
  attribute float DecayTime;
  attribute float DecayHFRatio;
  attribute float ReflectionsGain;
  attribute float ReflectionsDelay;
  attribute float LateGain;
  attribute float LateDelay;
  attribute float AirAbsorptionGainHF;
  attribute float RoomRolloffFactor;
};
UReverbEffect implements UObject;
interface FSoundEffectSourceInitData {
  attribute VoidPtr PresetSettings;
  attribute float SampleRate;
  attribute long NumSourceChannels;
  attribute float SourceDuration;
  attribute double AudioClock;
  [Value] attribute FVector SourcePosition;
  [Value] attribute FVector ListenerPosition;
};

interface FSoundEffectSourceInputData {
  attribute VoidPtr PresetData;
  [Value] attribute TArrayfloat AudioBuffer;
  attribute long NumSourceChannels;
  [Value] attribute FVector SourcePosition;
  [Value] attribute FVector LeftChannelPosition;
  [Value] attribute FVector RightChannelPosition;
  [Value] attribute FVector ListenerPosition;
  attribute float CurrentVolume;
  attribute float CurrentPitch;
  attribute float CurrentPlayTime;
  attribute float Duration;
  attribute float Distance;
  attribute double AudioClock;
  attribute long CurrentLoopCount;
  attribute long MaxLoopCount;
  attribute unsigned long bLooping;
  attribute unsigned long bIsSpatialized;
};

interface FSoundEffectSourceOutputData {
  [Value] attribute TArrayfloat AudioBuffer;
  attribute long OutputChannels;
  attribute unsigned short bIsSpatialized;
};

interface USoundEffectSource {
  void Init([Const, Ref] FSoundEffectSourceInitData InSampleRate);
  void OnProcessAudio([Const, Ref] FSoundEffectSourceInputData InData,
                      [Ref] FSoundEffectSourceOutputData OutData);
};
USoundEffectSource implements USoundEffectBase;

interface USoundEffectSourcePreset {
  USoundEffectSource CreateNewEffect();
};
USoundEffectSourcePreset implements USoundEffectPreset;

interface TArrayUSoundEffectSourcePreset {
};

interface TArrayUSoundEffectSourcePresetPtr {
};
enum ESoundSpatializationAlgorithm {
  "SPATIALIZATION_Default",
  "SPATIALIZATION_HRTF"
};

enum ESoundDistanceModel {
  "ATTENUATION_Linear",
  "ATTENUATION_Logarithmic",
  "ATTENUATION_Inverse",
  "ATTENUATION_LogReverse",
  "ATTENUATION_NaturalSound",
  "ATTENUATION_Custom",
  "ATTENUATION_MAX"
};

enum ESoundDistanceCalc {
  "SOUNDDISTANCE_Normal",
  "SOUNDDISTANCE_InfiniteXYPlane",
  "SOUNDDISTANCE_InfiniteXZPlane",
  "SOUNDDISTANCE_InfiniteYZPlane",
  "SOUNDDISTANCE_MAX"
};

enum EAttenuationShape_Type {
  "EAttenuationShape::Sphere",
  "EAttenuationShape::Capsule",
  "EAttenuationShape::Box",
  "EAttenuationShape::Cone"
};

interface FAttenuationSettings {
  attribute unsigned long bAttenuate;
  attribute unsigned long bSpatialize;
  attribute unsigned long bAttenuateWithLPF;
  attribute unsigned long bEnableListenerFocus;
  attribute unsigned long bEnableOcclusion;
  attribute unsigned long bUseComplexCollisionForOcclusion;
  [Value] attribute TEnumAsByteESoundDistanceModel DistanceAlgorithm;
  [Value] attribute FRuntimeFloatCurve CustomAttenuationCurve;
  [Value] attribute TEnumAsByteESoundDistanceCalc DistanceType_DEPRECATED;
  [Value] attribute TEnumAsByteEAttenuationShapeType AttenuationShape;
  attribute float dBAttenuationAtMax;
  attribute float OmniRadius;
  attribute float StereoSpread;
  [Value] attribute TEnumAsByteESoundSpatializationAlgorithm
      SpatializationAlgorithm;
  attribute float RadiusMin_DEPRECATED;
  attribute float RadiusMax_DEPRECATED;
  [Value] attribute FVector AttenuationShapeExtents;
  attribute float ConeOffset;
  attribute float FalloffDistance;
  attribute float LPFRadiusMin;
  attribute float LPFRadiusMax;
  attribute float LPFFrequencyAtMin;
  attribute float LPFFrequencyAtMax;
  attribute float FocusAzimuth;
  attribute float NonFocusAzimuth;
  attribute float FocusDistanceScale;
  attribute float NonFocusDistanceScale;
  attribute float FocusPriorityScale;
  attribute float NonFocusPriorityScale;
  attribute float FocusVolumeAttenuation;
  attribute float NonFocusVolumeAttenuation;
  [Value] attribute TEnumAsByteECollisionChannel OcclusionTraceChannel;
  attribute float OcclusionLowPassFilterFrequency;
  attribute float OcclusionVolumeAttenuation;
  attribute float OcclusionInterpolationTime;

  void FAttenuationSettings();

  [Operator="=="] boolean equal([Const, Ref] FAttenuationSettings Other);
  void PostSerialize([Const, Ref] FArchive Ar);

  void CollectAttenuationShapesForVisualization(
      [Ref] TMultiMapEAttenuationShapeTypeFAttenuationSettingsAttenuationShapeDetails ShapeDetailsMap);
  float GetMaxDimension();
  float GetFocusPriorityScale([Const, Ref] FGlobalFocusSettings FocusSettings,
                              float FocusFactor);
  float GetFocusAttenuation([Const, Ref] FGlobalFocusSettings FocusSettings,
                            float FocusFactor);
  float GetFocusDistanceScale([Const, Ref] FGlobalFocusSettings FocusSettings,
                              float FocusFactor);
  float AttenuationEval([Const] float Distance,
                        [Const] float Falloff,
                        [Const] float DistanceScale);
  float AttenuationEvalBox([Const, Ref] FTransform SoundLocation,
                           [Const, Ref] FVector ListenerLocation,
                           [Const] float DistanceScale);
  float AttenuationEvalCapsule([Const, Ref] FTransform SoundLocation,
                               [Const, Ref] FVector ListenerLocation,
                               [Const] float DistanceScale);
  float AttenuationEvalCone([Const, Ref] FTransform SoundLocation,
                            [Const, Ref] FVector ListenerLocation,
                            [Const] float DistanceScale);
};

[Prefix="FAttenuationSettings::"]
interface AttenuationShapeDetails {
  [Value] attribute FVector Extents;
  attribute float Falloff;
  attribute float ConeOffset;
};

interface USoundAttenuation {
	[Value] attribute FAttenuationSettings Attenuation;
};
USoundAttenuation implements UObject;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TMultiMapEAttenuationShapeTypeFAttenuationSettingsAttenuationShapeDetails {
};

interface TEnumAsByteESoundDistanceModel {
};

interface TEnumAsByteESoundDistanceCalc {
};

interface TEnumAsByteEAttenuationShapeType {
};

interface TEnumAsByteESoundSpatializationAlgorithm {
};
enum EDecompressionType {
  "DTYPE_Setup",
  "DTYPE_Invalid",
  "DTYPE_Preview",
  "DTYPE_Native",
  "DTYPE_RealTime",
  "DTYPE_Procedural",
  "DTYPE_Xenon",
  "DTYPE_Streaming",
  "DTYPE_MAX"
};

interface FStreamedAudioChunk {
  attribute long DataSize;
  [Value] attribute FByteBulkData BulkData;

  void FStreamedAudioChunk();
  void Serialize([Ref] FArchive Ar, UObject Owner, long ChunkIndex);
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FStreamedAudioPlatformData {
};

interface USoundWave {
};
USoundWave implements USoundBase;

interface USoundWavePtr {
};
interface USoundSubmix {
  [Value] attribute TArrayUSoundSubmixPtr ChildSubmixes;
  attribute USoundSubmix ParentSubmix;
  [Value] attribute TArrayUSoundEffectSubmixPresetPtr SubmixEffectChain;
  attribute float OutputWetLevel;
};
USoundSubmix implements UObject;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayUSoundSubmix {
};

interface TArrayUSoundSubmixPtr {
};
enum EAudioOutputTarget_Type {
  "EAudioOutputTarget::Speaker",
  "EAudioOutputTarget::Controller",
  "EAudioOutputTarget::ControllerFallbackToSpeaker"
};

interface FSoundClassEditorData {
  attribute long NodePosX;
  attribute long NodePosY;
  void FSoundClassEditorData();
  // TODO: not supported operator
  //friend FArchive& operator<<(FArchive& Ar,FSoundClassEditorData& MySoundClassEditorData)
};

interface FSoundClassProperties {
  attribute float Volume;
  attribute float Pitch;
  attribute float StereoBleed;
  attribute float LFEBleed;
  attribute float VoiceCenterChannelVolume;
  attribute float RadioFilterVolume;
  attribute float RadioFilterVolumeThreshold;
  attribute unsigned long bApplyEffects;
  attribute unsigned long bAlwaysPlay;
  attribute unsigned long bIsUISound;
  attribute unsigned long bIsMusic;
  attribute unsigned long bReverb;
  attribute unsigned long bCenterChannelOnly;
  attribute unsigned long bApplyAmbientVolumes;
  [Value] attribute TEnumAsByteEAudioOutputTargetType OutputTarget;

  void FSoundClassProperties();
};

interface FPassiveSoundMixModifier {
  attribute USoundMix SoundMix;
  attribute float MinVolumeThreshold;
  attribute float MaxVolumeThreshold;

  void FPassiveSoundMixModifier();
};

interface USoundClass {
  [Value] attribute FSoundClassProperties Properties;
  [Value] attribute TArrayUSoundClassPtr ChildClasses;
  [Value] attribute TArrayFPassiveSoundMixModifier PassiveSoundMixModifiers;

  attribute USoundClass ParentClass;

  void Interpolate(float InterpValue,
                   [Ref] FSoundClassProperties Current,
                   [Const, Ref] FSoundClassProperties Start,
                   [Const, Ref] FSoundClassProperties End);
};
USoundClass implements UObject;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteEAudioOutputTargetType
 {
};

interface TArrayFPassiveSoundMixModifier {
};

interface TArrayUSoundClass {
};

interface TArrayUSoundClassPtr {
};
interface USoundEffectSubmixPreset {
  USoundEffectSubmix CreateNewEffect();
};
USoundEffectSubmixPreset implements USoundEffectPreset;

interface FSoundEffectSubmixInitData {
  attribute VoidPtr PresetSettings;
  attribute float SampleRate;
  attribute long NumOutputChannels;
};

interface FSoundEffectSubmixInputData {
  attribute VoidPtr PresetData;
  attribute TArrayfloat AudioBuffer;
  attribute long NumChannels;
  attribute double AudioClock;
};

interface FSoundEffectSubmixOutputData {
  attribute TArrayfloat AudioBuffer;
};

interface USoundEffectSubmix {
  void Init([Const, Ref] FSoundEffectSubmixInitData InSampleRate);
  void Tick();
  void OnProcessAudio([Const, Ref] FSoundEffectSubmixInputData InData,
                      [Ref] FSoundEffectSubmixOutputData OutData);
  void ProcessAudio([Ref] FSoundEffectSubmixInputData InData,
                    [Ref] FSoundEffectSubmixOutputData OutData);
};
USoundEffectSubmix implements USoundEffectBase;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayUSoundEffectSubmixPreset {
};

interface TArrayUSoundEffectSubmixPresetPtr{
};
interface USoundNode {
  [Const] static readonly attribute long MAX_ALLOWED_CHILD_NODES;
  [Value] attribute TArrayUSoundNodePtr ChildNodes;

  boolean NotifyWaveInstanceFinished(FWaveInstance WaveInstance);
  float MaxAudibleDistance(float CurrentMaxDistance);
  float GetDuration();

  void ParseNodes(FAudioDevice AudioDevice, [Const, Ref] UPTRINT NodeWaveInstanceHash, [Ref] FActiveSound ActiveSound, [Const, Ref] FSoundParseParameters ParseParams, [Ref] TArrayFWaveInstancePtr WaveInstances);
  void GetAllNodes([Ref] TArrayUSoundNodePtr SoundNodes);
  long GetMaxChildNodes();
  long GetMinChildNodes();
  long GetNumSounds([Const, Ref] UPTRINT NodeWaveInstanceHash, [Ref] FActiveSound ActiveSound);
  void CreateStartingConnectors();
  void InsertChildNode(long Index);
  void RemoveChildNode(long Index);
  [Value] static UPTRINT GetNodeWaveInstanceHash([Const, Ref] UPTRINT ParentWaveInstanceHash, [Const] USoundNode ChildNode, [Const] unsigned long ChildIndex);
  // TODO: overriding is not supported
  //[Value] static UPTRINT GetNodeWaveInstanceHash([Const, Ref] UPTRINT ParentWaveInstanceHash, [Const, Ref] UPTRINT ChildNodeHash, [Const] unsigned long ChildIndex);
};
USoundNode implements UObject;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayUSoundNode {
};

interface TArrayUSoundNodePtr {
};
interface USoundBase {
  static attribute USoundClass DefaultSoundClassObject;
  static attribute USoundConcurrency DefaultSoundConcurrencyObject;
  static attribute USoundSubmix DefaultSoundSubmixObject;

  attribute USoundSubmix SoundSubmixObject;
  attribute unsigned long bDebug;
  attribute unsigned long bOverrideConcurrency;
  attribute unsigned long bIgnoreFocus;
  attribute USoundConcurrency SoundConcurrencySettings;
  [Value] attribute FSoundConcurrencySettings ConcurrencyOverrides;

  [Value] attribute TEnumAsByteEMaxConcurrentResolutionRule
      MaxConcurrentResolutionRule_DEPRECATED;
  attribute long MaxConcurrentPlayCount_DEPRECATED;
  attribute float Duration;
  attribute USoundAttenuation AttenuationSettings;
  attribute float Priority;
  [Value] attribute TArrayUSoundEffectSourcePresetPtr SourceEffectChain;

  attribute long CurrentPlayCount;
  boolean IsPlayable();
  [Const] FAttenuationSettings GetAttenuationSettingsToApply();
  float GetMaxAudibleDistance();
  float GetDuration();

  float GetVolumeMultiplier();
  float GetPitchMultiplier();
  float GetSubtitlePriority();
  boolean ShouldApplyInteriorVolumes();
  boolean IsLooping();
  void Parse(FAudioDevice AudioDevice,
             [Const, Ref] UPTRINT NodeWaveInstanceHash,
             [Ref] FActiveSound ActiveSound,
             [Const, Ref] FSoundParseParameters ParseParams,
             [Ref] TArrayFWaveInstancePtr WaveInstances);
  USoundClass GetSoundClass();
  USoundSubmix GetSoundSubmix();
  [Const] FSoundConcurrencySettings GetSoundConcurrencySettingsToApply();
  float GetPriority();
  unsigned long GetSoundConcurrencyObjectID();
};
USoundBase implements UObject;
interface FInteriorSettings {
  attribute unsigned long bIsWorldSettings;
  attribute float ExteriorVolume;
  attribute float ExteriorTime;
  attribute float ExteriorLPF;
  attribute float ExteriorLPFTime;
  attribute float InteriorVolume;
  attribute float InteriorTime;
  attribute float InteriorLPF;
  attribute float InteriorLPFTime;

  void FInteriorSettings();
  [Operator="=="] boolean equal([Const, Ref] FInteriorSettings Other);
  [Operator="!="] boolean not_equal([Const, Ref] FInteriorSettings Other);

  void PostSerialize([Const, Ref] FArchive Ar);
};

enum ReverbPreset {
  "REVERB_Default",
  "REVERB_Bathroom",
  "REVERB_StoneRoom",
  "REVERB_Auditorium",
  "REVERB_ConcertHall",
  "REVERB_Cave",
  "REVERB_Hallway",
  "REVERB_StoneCorridor",
  "REVERB_Alley",
  "REVERB_Forest",
  "REVERB_City",
  "REVERB_Mountains",
  "REVERB_Quarry",
  "REVERB_Plain",
  "REVERB_ParkingLot",
  "REVERB_SewerPipe",
  "REVERB_Underwater",
  "REVERB_SmallRoom",
  "REVERB_MediumRoom",
  "REVERB_LargeRoom",
  "REVERB_MediumHall",
  "REVERB_LargeHall",
  "REVERB_Plate",
  "REVERB_MAX"
};

interface FReverbSettings {
  attribute unsigned long bApplyReverb;
  [Value] attribute TEnumAsByteReverbPreset ReverbType_DEPRECATED;
  attribute UReverbEffect ReverbEffect;
  attribute float Volume;
  attribute float FadeTime;

  void FReverbSettings();

  [Operator="=="] boolean equal([Const, Ref] FReverbSettings Other);
  [Operator="!="] boolean not_equal([Const, Ref] FReverbSettings Other);
  void PostSerialize([Const, Ref] FArchive Ar);
};

interface FAudioVolumeProxy {
  void FAudioVolumeProxy();
  void FAudioVolumeProxy([Const] AAudioVolume AudioVolume);

  attribute unsigned long AudioVolumeID;
  attribute unsigned long WorldID;
  attribute float Priority;
  [Value] attribute FReverbSettings ReverbSettings;
  [Value] attribute FInteriorSettings InteriorSettings;
  attribute FBodyInstance BodyInstance;
};

interface AAudioVolume {
  float GetPriority();
  void SetPriority(float NewPriority);
  boolean GetEnabled();
  void SetEnabled(boolean bNewEnabled);
  [Const, Ref] FReverbSettings GetReverbSettings();
  void SetReverbSettings([Const, Ref] FReverbSettings NewReverbSettings);
  [Const, Ref] FInteriorSettings GetInteriorSettings();
  void SetInteriorSettings([Const, Ref] FInteriorSettings NewInteriorSettings);
};
AAudioVolume implements AVolume;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteReverbPreset {
};

interface TSetAAudioVolumePtr {
};
interface FAudioEQEffect {
  attribute double RootTime;
  attribute float FrequencyCenter0;
  attribute float Gain0;
  attribute float Bandwidth0;
  attribute float FrequencyCenter1;
  attribute float Gain1;
  attribute float Bandwidth1;
  attribute float FrequencyCenter2;
  attribute float Gain2;
  attribute float Bandwidth2;
  attribute float FrequencyCenter3;
  attribute float Gain3;
  attribute float Bandwidth3;

  void FAudioEQEffect();
  void Interpolate(float InterpValue,
                   [Const, Ref] FAudioEQEffect Start,
                   [Const, Ref] FAudioEQEffect End);
  void ClampValues();

};

interface FSoundClassAdjuster {
  attribute USoundClass SoundClassObject;
  attribute float VolumeAdjuster;
  attribute float PitchAdjuster;
  attribute unsigned long bApplyToChildren;
  attribute float VoiceCenterChannelVolumeAdjuster;

  void FSoundClassAdjuster();
};

interface USoundMix {
  attribute unsigned long bApplyEQ;
  attribute float EQPriority;
  [Value] attribute FAudioEQEffect EQSettings;
  [Value] attribute TArrayFSoundClassAdjuster SoundClassEffects;
  attribute float InitialDelay;
  attribute float FadeInTime;
  attribute float Duration;
  attribute float FadeOutTime;
};
USoundMix implements UObject;

interface TArrayFSoundClassAdjuster {
};
interface UPointLightComponent {
  attribute float Radius_DEPRECATED;
  attribute float AttenuationRadius;
  attribute unsigned long bUseInverseSquaredFalloff;
  attribute float LightFalloffExponent;
  attribute float SourceRadius;
  attribute float SourceLength;
  [Value] attribute FLightmassPointLightSettings LightmassSettings;

  void SetAttenuationRadius(float NewRadius);
  void SetLightFalloffExponent(float NewLightFalloffExponent);
  void SetSourceRadius(float bNewValue);
  void SetSourceLength(float NewValue);
};
UPointLightComponent implements ULightComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UCapsuleComponent {
};

UCapsuleComponent implements UShapeComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UInputComponent {
};

UInputComponent implements UActorComponent;
interface UStaticMeshComponent {
  void UStaticMeshComponent();
  UStaticMesh GetStaticMesh();
  boolean SetStaticMesh(UStaticMesh NewMesh);
  UMaterialInterface GetMaterial(long ElementIndex);
  void SetMaterial(long ElementIndex, UMaterialInterface Material);
  void RegisterComponent();
};
UStaticMeshComponent implements UMeshComponent;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UShapeComponent {
};

UShapeComponent implements UPrimitiveComponent;
interface ULightComponentBase {
  [Value] attribute FGuid LightGuid;
  attribute float Brightness_DEPRECATED;
  attribute float Intensity;
  [Value] attribute FColor LightColor;
  attribute long bAffectsWorld;
  attribute long CastShadows;
  attribute long CastStaticShadows;
  attribute long CastDynamicShadows;
  attribute long bAffectTranslucentLighting;
  attribute float IndirectLightingIntensity;

  void SetCastShadows(boolean bNewValue);
  [Value] FLinearColor GetLightColor();
  void Serialize([Ref] FArchive Ar);
  void PostDuplicate(EDuplicateMode_Type DuplicateMode);
  void ValidateLightGUIDs();
  void UpdateLightGUIDs();
  boolean IsMovable();
  boolean HasStaticLighting();
  boolean HasStaticShadowing();
  boolean ShouldCollideWhenPlacing();
  [Value] FBoxSphereBounds GetPlacementExtent();
};
ULightComponentBase implements USceneComponent;
interface FAudioComponentParam {
  [Value] attribute FName ParamName;
  attribute float FloatParam;
  attribute boolean BoolParam;
  attribute long IntParam;
  attribute USoundWave SoundWaveParam;

  void FAudioComponentParam([Const, Ref] FName Name);
  void FAudioComponentParam();
};

interface TArrayFAudioComponentParam {
};

interface UAudioComponent {
  attribute USoundBase Sound;
  [Value] attribute TArrayFAudioComponentParam InstanceParameters;
  attribute USoundClass SoundClassOverride;
  attribute octet bAutoDestroy;
  attribute octet bStopWhenOwnerDestroyed;
  attribute octet bShouldRemainActiveIfDropped;
  attribute octet bAllowSpatialization;
  attribute octet bOverrideAttenuation;
  attribute unsigned long bOverrideSubtitlePriority;
  attribute octet bIsUISound;
  attribute octet bEnableLowPassFilter;
  attribute octet bOverridePriority;
  attribute octet bSuppressSubtitles;
  attribute octet bPreviewComponent;
  attribute octet bIgnoreForFlushing;
  attribute octet bEQFilterApplied;
  attribute octet bAlwaysPlay;
  attribute octet bIsMusic;
  attribute octet bReverb;
  attribute octet bCenterChannelOnly;
  attribute octet bIsPreviewSound;
  attribute octet bIsPaused;
  attribute unsigned long AudioDeviceHandle;
  attribute float PitchModulationMin;
  attribute float PitchModulationMax;
  attribute float VolumeModulationMin;
  attribute float VolumeModulationMax;
  attribute float VolumeMultiplier;
  attribute float Priority;
  attribute float SubtitlePriority;
  attribute float VolumeWeightedPriorityScale_DEPRECATED;
  attribute float PitchMultiplier;
  attribute float HighFrequencyGainMultiplier_DEPRECATED;
  attribute float LowPassFilterFrequency;
  attribute USoundAttenuation AttenuationSettings;
  [Value] attribute FAttenuationSettings AttenuationOverrides;
  attribute USoundConcurrency ConcurrencySettings;
  attribute float OcclusionCheckInterval;
  [Value] attribute FOnAudioFinished OnAudioFinished;
  [Value] attribute FOnAudioFinishedNative OnAudioFinishedNative;
  [Value] attribute FOnAudioPlaybackPercent OnAudioPlaybackPercent;
  [Value] attribute FOnAudioPlaybackPercentNative OnAudioPlaybackPercentNative;
  [Value] attribute FOnQueueSubtitles OnQueueSubtitles;

  void SetSound(USoundBase NewSound);
  void FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime);
  void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
  void Play(float StartTime);
  void Stop();
  void SetPaused(boolean bPause);
  boolean IsPlaying();
  void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
  void SetFloatParameter([Ref] FName InName, float InFloat);
  void SetWaveParameter([Ref] FName InName, USoundWave InWave);
  void SetBoolParameter([Ref] FName InName, boolean InBool);
  void SetIntParameter([Ref] FName InName, long InInt);
  void SetVolumeMultiplier(float NewVolumeMultiplier);
  void SetPitchMultiplier(float NewPitchMultiplier);
  void SetUISound(boolean bInUISound);
  void AdjustAttenuation(
      [Const, Ref] FAttenuationSettings InAttenuationSettings);
  static void PlaybackCompleted(unsigned long AudioComponentID,
                                boolean bFailedToStart);

  void SetSoundParameter([Const, Ref] FAudioComponentParam Param);

  [Const] FAttenuationSettings GetAttenuationSettingsToApply();
  boolean BP_GetAttenuationSettingsToApply(
      [Ref] FAttenuationSettings OutAttenuationSettings);
  void CollectAttenuationShapesForVisualization(
      [Ref] TMultiMapEAttenuationShapeTypeFAttenuationSettingsAttenuationShapeDetails ShapeDetailsMap);
  FAudioDevice GetAudioDevice();
  unsigned long GetAudioComponentID();
  static UAudioComponent GetAudioComponentFromID(
      unsigned long AudioComponentID);

  // TODO: unresolved symbol
  //void UpdateInteriorSettings(boolean bFullUpdate);
};
UAudioComponent implements USceneComponent;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FOnAudioFinished {
};

interface FOnAudioFinishedNative {
};

interface FOnAudioPlaybackPercent {
};

interface FOnAudioPlaybackPercentNative {
};

interface FOnQueueSubtitles {
};
interface FOverlapInfo {
  void FOverlapInfo();
  void FOverlapInfo([Const, Ref] FHitResult InSweepResult);
  void FOverlapInfo(UPrimitiveComponent InComponent, long InBodyIndex);

  long GetBodyIndex();
  attribute boolean bFromSweep;
  [Value] attribute FHitResult OverlapInfo;
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface USceneComponent {
  void USceneComponent();
};
USceneComponent implements UActorComponent;

interface FSceneComponentInstanceData {
  void FSceneComponentInstanceData([Const] USceneComponent SourceComponent);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UMeshComponent {
};
UMeshComponent implements UPrimitiveComponent;
interface TEnumAsByteSkyLightSourceType {
};

enum ESkyLightSourceType {
  "ESkyLightSourceType::SLS_CapturedScene",
  "ESkyLightSourceType::SLS_SpecifiedCubemap",
  "ESkyLightSourceType::SLS_MAX"
};

interface USkyLightComponent {
  [Value] attribute TEnumAsByteSkyLightSourceType SourceType;
  attribute UTextureCube Cubemap;
  attribute float SourceCubemapAngle;
  attribute long CubemapResolution;
  attribute float SkyDistanceThreshold;
  attribute boolean bLowerHemisphereIsBlack;
  [Value] attribute FLinearColor LowerHemisphereColor;
  attribute float OcclusionMaxDistance;
  attribute float Contrast;
  attribute float MinOcclusion;
  [Value] attribute FColor OcclusionTint;

  FSkyLightSceneProxy CreateSceneProxy();
  void PostInitProperties();
  void PostLoad() ;
  void PostInterpChange(UProperty PropertyThatChanged);
  void BeginDestroy() ;
  boolean IsReadyForFinishDestroy();
  FActorComponentInstanceData GetComponentInstanceData();
  void CaptureEmissiveIrradianceEnvironmentMap([Ref] FSHVectorRGB3 OutIrradianceMap);
  void SetIntensity(float NewIntensity);
  void SetIndirectLightingIntensity(float NewIntensity);
  void SetLightColor([Ref] FLinearColor NewLightColor);
  void SetCubemap(UTextureCube NewCubemap);
  void SetCubemapBlend(UTextureCube SourceCubemap, UTextureCube DestinationCubemap, float InBlendFraction);
  void SetOcclusionTint([Ref, Const] FColor InTint);
  void SetMinOcclusion(float InMinOcclusion);
  void SetVisibility(boolean bNewVisibility, boolean bPropagateToChildren);
  void SetCaptureIsDirty();
  void SetBlendDestinationCaptureIsDirty();
  void SanitizeCubemapSize();
  void RecaptureSky();
  void SetIrradianceEnvironmentMap([Const, Ref] FSHVectorRGB3 InIrradianceEnvironmentMap);

  static void UpdateSkyCaptureContents(UWorld WorldToUpdate);

  // TODO: need to figure out how to easily export such complicated constructs...
  // void ApplyComponentInstanceData(FPrecomputedSkyLightInstanceData ComponentInstanceData);
  // static void UpdateSkyCaptureContentsArray(UWorld WorldToUpdate, TArray<USkyLightComponent*>& ComponentArray, bool bBlendSources);
};
USkyLightComponent implements ULightComponentBase;
enum ESplinePointType_Type {
  "ESplinePointType::Linear",
  "ESplinePointType::Curve",
  "ESplinePointType::Constant",
  "ESplinePointType::CurveClamped",
  "ESplinePointType::CurveCustomTangent"
};

enum ESplineCoordinateSpace_Type {
  "ESplineCoordinateSpace::Local",
  "ESplineCoordinateSpace::World"
};

interface FSplineCurves {
  [Value] attribute FInterpCurveVector Position;
  [Value] attribute FInterpCurveQuat Rotation;
  [Value] attribute FInterpCurveVector Scale;
  [Value] attribute FInterpCurveFloat ReparamTable;

  [Operator="=="] boolean equal([Const, Ref] FSplineCurves Other);
  [Operator="!="] boolean not_equal([Const, Ref] FSplineCurves Other);
};

interface FSplinePoint {
  attribute float InputKey;
  [Value] attribute FVector Position;
  [Value] attribute FVector ArriveTangent;
  [Value] attribute FVector LeaveTangent;
  [Value] attribute FRotator Rotation;
  [Value] attribute FVector Scale;
  [Value] attribute TEnumAsByteESplinePointType Type;

  void FSplinePoint();
  void FSplinePoint(float InInputKey, [Const, Ref] FVector InPosition);
  void FSplinePoint(float InInputKey,
                    [Const, Ref] FVector InPosition,
                    ESplinePointType_Type InType,
                    [Const, Ref] FRotator InRotation,
                    [Const, Ref] FVector InScale);
  void FSplinePoint(float InInputKey,
                    [Const, Ref] FVector InPosition,
                    [Const, Ref] FVector InArriveTangent,
                    [Const, Ref] FVector InLeaveTangent,
                    [Const, Ref] FRotator InRotation,
                    [Const, Ref] FVector InScale,
                    ESplinePointType_Type InType);
};

interface USplineComponent {
  [Value] attribute FSplineCurves SplineCurves;
  [Value] attribute FInterpCurveVector SplineInfo_DEPRECATED;
  [Value] attribute FInterpCurveQuat SplineRotInfo_DEPRECATED;
  [Value] attribute FInterpCurveVector SplineScaleInfo_DEPRECATED;
  [Value] attribute FInterpCurveFloat SplineReparamTable_DEPRECATED;
  attribute boolean bAllowSplineEditingPerInstance_DEPRECATED;
  attribute long ReparamStepsPerSegment;
  attribute float Duration;
  attribute boolean bStationaryEndpoints;
  attribute boolean bSplineHasBeenEdited;
  attribute boolean bModifiedByConstructionScript;
  attribute boolean bInputSplinePointsToConstructionScript;
  attribute boolean bDrawDebug;
  [Value] attribute FVector DefaultUpVector;

  [Value] FInterpCurveVector GetSplinePointsPosition();
  [Value] FInterpCurveQuat GetSplinePointsRotation();
  [Value] FInterpCurveVector GetSplinePointsScale();

  void ApplyComponentInstanceData(FSplineInstanceData ComponentInstanceData,
                                  [Const] boolean bPostUCS);
  void UpdateSpline();
  [Value] FVector GetLocationAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetTangentAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetDirectionAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FRotator GetRotationAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FQuat GetQuaternionAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetUpVectorAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetRightVectorAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FTransform GetTransformAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace, boolean bUseScale);
  float GetRollAtSplineInputKey(float InKey,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetScaleAtSplineInputKey(float InKey);

  void SetUnselectedSplineSegmentColor([Const, Ref] FLinearColor SegmentColor);
  void SetSelectedSplineSegmentColor([Const, Ref] FLinearColor SegmentColor);
  void SetDrawDebug(boolean bShow);
  void SetClosedLoop(boolean bInClosedLoop, boolean bUpdateSpline);
  void SetClosedLoopAtPosition(boolean bInClosedLoop,
                               float Key,
                               boolean bUpdateSpline);
  boolean IsClosedLoop();
  void ClearSplinePoints(boolean bUpdateSpline);
  void AddPoint([Const, Ref] FSplinePoint Point, boolean bUpdateSpline);
  void AddPoints([Const, Ref] TArrayFSplinePoint Points, boolean bUpdateSpline);
  void AddSplinePoint([Const, Ref] FVector Position,
                      ESplineCoordinateSpace_Type CoordinateSpace,
                      boolean bUpdateSpline);
  void AddSplinePointAtIndex([Const, Ref] FVector Position,
                             long Index,
                             ESplineCoordinateSpace_Type CoordinateSpace,
                             boolean bUpdateSpline);
  void AddSplineWorldPoint([Const, Ref] FVector Position);
  void AddSplineLocalPoint([Const, Ref] FVector Position);
  void SetSplinePoints([Const, Ref] TArrayFVector Points,
                       ESplineCoordinateSpace_Type CoordinateSpace,
                       boolean bUpdateSpline);
  void SetSplineWorldPoints([Const, Ref] TArrayFVector Points);
  void SetSplineLocalPoints([Const, Ref] TArrayFVector Points);
  void SetLocationAtSplinePoint(long PointIndex,
                                [Const, Ref] FVector InLocation,
                                ESplineCoordinateSpace_Type CoordinateSpace,
                                boolean bUpdateSpline);
  void SetWorldLocationAtSplinePoint(long PointIndex,
                                     [Const, Ref] FVector InLocation);
  void SetTangentAtSplinePoint(long PointIndex,
                               [Const, Ref] FVector InTangent,
                               ESplineCoordinateSpace_Type CoordinateSpace,
                               boolean bUpdateSpline);
  void SetTangentsAtSplinePoint(long PointIndex,
                                [Const, Ref] FVector InArriveTangent,
                                [Const, Ref] FVector InLeaveTangent,
                                ESplineCoordinateSpace_Type CoordinateSpace,
                                boolean bUpdateSpline);
  void SetUpVectorAtSplinePoint(long PointIndex,
                                [Const, Ref] FVector InUpVector,
                                ESplineCoordinateSpace_Type CoordinateSpace,
                                boolean bUpdateSpline);
  ESplinePointType_Type GetSplinePointType(long PointIndex);
  void SetSplinePointType(long PointIndex,
                          ESplinePointType_Type Type,
                          boolean bUpdateSpline);
  long GetNumberOfSplinePoints();
  [Value] FVector GetLocationAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetWorldLocationAtSplinePoint(long PointIndex);
  [Value] FVector GetDirectionAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetTangentAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetArriveTangentAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetLeaveTangentAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FQuat GetQuaternionAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FRotator GetRotationAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetUpVectorAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetRightVectorAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace);
  float GetRollAtSplinePoint(long PointIndex,
                             ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetScaleAtSplinePoint(long PointIndex);
  [Value] FTransform GetTransformAtSplinePoint(
      long PointIndex,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseScale);
  void GetLocationAndTangentAtSplinePoint(
      long PointIndex,
      [Ref] FVector Location,
      [Ref] FVector Tangent,
      ESplineCoordinateSpace_Type CoordinateSpace);
  void GetLocalLocationAndTangentAtSplinePoint(long PointIndex,
                                               [Ref] FVector LocalLocation,
                                               [Ref] FVector LocalTangent);
  float GetDistanceAlongSplineAtSplinePoint(long PointIndex);
  float GetSplineLength();
  void SetDefaultUpVector([Const, Ref] FVector UpVector,
                          ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetDefaultUpVector(
      ESplineCoordinateSpace_Type CoordinateSpace);
  float GetInputKeyAtDistanceAlongSpline(float Distance);
  [Value] FVector GetLocationAtDistanceAlongSpline(
     float Distance,
     ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetWorldLocationAtDistanceAlongSpline(float Distance);
  [Value] FVector GetDirectionAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetWorldDirectionAtDistanceAlongSpline(float Distance);
  [Value] FVector GetTangentAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetWorldTangentAtDistanceAlongSpline(float Distance);
  [Value] FQuat GetQuaternionAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FRotator GetRotationAtDistanceAlongSpline(float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FRotator GetWorldRotationAtDistanceAlongSpline(float Distance);
  [Value] FVector GetUpVectorAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetRightVectorAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  float GetRollAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector GetScaleAtDistanceAlongSpline(float Distance);
  [Value] FTransform GetTransformAtDistanceAlongSpline(
      float Distance,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseScale);
  [Value] FVector GetLocationAtTime(float Time,
                                    ESplineCoordinateSpace_Type CoordinateSpace,
                                    boolean bUseConstantVelocity);
  [Value] FVector GetWorldLocationAtTime(float Time,
                                         boolean bUseConstantVelocity);
  [Value] FVector GetDirectionAtTime(
      float Time,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseConstantVelocity);
  [Value] FVector GetWorldDirectionAtTime(float Time,
                                          boolean bUseConstantVelocity);
  [Value] FVector GetTangentAtTime(float Time,
                                   ESplineCoordinateSpace_Type CoordinateSpace,
                                   boolean bUseConstantVelocity);
  [Value] FQuat GetQuaternionAtTime(float Time,
                                    ESplineCoordinateSpace_Type CoordinateSpace,
                                    boolean bUseConstantVelocity);
  [Value] FRotator GetRotationAtTime(
      float Time,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseConstantVelocity);
  [Value] FRotator GetWorldRotationAtTime(float Time,
                                          boolean bUseConstantVelocity);
  [Value] FVector GetUpVectorAtTime(float Time,
                                    ESplineCoordinateSpace_Type CoordinateSpace,
                                    boolean bUseConstantVelocity);
  [Value] FVector GetRightVectorAtTime(
      float Time,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseConstantVelocity);
  [Value] FTransform GetTransformAtTime(
      float Time,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseConstantVelocity,
      boolean bUseScale);
  float GetRollAtTime(float Time,
                      ESplineCoordinateSpace_Type CoordinateSpace,
                      boolean bUseConstantVelocity);
  [Value] FVector GetScaleAtTime(float Time, boolean bUseConstantVelocity);
  float FindInputKeyClosestToWorldLocation([Const, Ref] FVector WorldLocation);
  [Value] FVector FindLocationClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector FindDirectionClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector FindTangentClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FQuat FindQuaternionClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FRotator FindRotationClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector FindUpVectorClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector FindRightVectorClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  float FindRollClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace);
  [Value] FVector FindScaleClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation);
  [Value] FTransform FindTransformClosestToWorldLocation(
      [Const, Ref] FVector WorldLocation,
      ESplineCoordinateSpace_Type CoordinateSpace,
      boolean bUseScale);
};
USplineComponent implements UPrimitiveComponent;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteESplinePointType {
};

interface TArrayFSplinePoint {
};

// class declared in private sub folder
[NoDelete]
interface FSplineInstanceData {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UActorComponent {
  void UActorComponent();
};
UActorComponent implements UObject;
interface USkeletalMeshComponent {
  [Value] attribute TSubclassOfUAnimInstance AnimClass;
  attribute UAnimInstance AnimScriptInstance;
  [Value] attribute TArrayUAnimInstancePtr SubInstances;
  attribute UAnimInstance PostProcessAnimInstance;
  [Value] attribute FSingleAnimationPlayData AnimationData;
  [Value] attribute TArrayFTransform BoneSpaceTransforms;
  [Value] attribute TArrayFTransform CachedBoneSpaceTransforms;
  [Value] attribute TArrayFTransform CachedComponentSpaceTransforms;
  [Value] attribute FBlendedHeapCurve CachedCurve;
  attribute float GlobalAnimRateScale;
  [Value] attribute TEnumAsByteEKinematicBonesUpdateToPhysicsType KinematicBonesUpdateType;
  [Value] attribute TEnumAsByteEPhysicsTransformUpdateModeType PhysicsTransformUpdateMode;
  attribute float TeleportDistanceThreshold;
  attribute float TeleportRotationThreshold;
  attribute float ClothBlendWeight;
  [Value] attribute FVector RootBoneTranslation;
  attribute boolean bUseRefPoseOnInitAnim;
  attribute UBodySetup BodySetup;
  void CreateBodySetup();
  attribute unsigned short CachedAnimCurveUidVersion;
  [Value] attribute FVector LineCheckBoundsScale;
  attribute long RagdollAggregateThreshold;
  [Value] attribute FConstraintBrokenSignature OnConstraintBroken;
  void SetAnimInstanceClass(UClass NewClass);
  UAnimInstance GetAnimInstance();
  UAnimInstance GetPostProcessInstance();
  void PlayAnimation(UAnimationAsset NewAnimToPlay, boolean bLooping);
  void SetAnimation(UAnimationAsset NewAnimToPlay);
  void Play(boolean bLooping);
  void Stop();
  boolean IsPlaying();
  void SetPosition(float InPos, optional boolean bFireNotifies = true);
  float GetPosition();
  void SetPlayRate(float Rate);
  float GetPlayRate();
  void OverrideAnimationData(UAnimationAsset InAnimToPlay, optional boolean bIsLooping = true, optional boolean bIsPlaying = true, optional float Position = 0.0, optional float PlayRate = 1.0);
  void SetMorphTarget([Const] FName MorphTargetName, float Value, optional boolean bRemoveZeroWeight = true);
  void ClearMorphTargets();
  float GetMorphTarget([Const] FName MorphTargetName);
  float GetClothMaxDistanceScale();
  void SetClothMaxDistanceScale(float Scale);
  void ForceClothNextUpdateTeleport();
  void ForceClothNextUpdateTeleportAndReset();
  void ResetClothTeleportMode();
  void BindClothToMasterPoseComponent();
  void UnbindClothFromMasterPoseComponent(optional boolean bRestoreSimulationSpace = true);
  void SkelMeshCompOnParticleSystemFinished(UParticleSystemComponent PSC);
  UAnimSingleNodeInstance GetSingleNodeInstance();
  boolean InitializeAnimScriptInstance(optional boolean bForceReinit = true);
  boolean IsWindEnabled();
  [Value] attribute TArrayFBoneIndexType RequiredBones;
  [Value] attribute TArrayFBoneIndexType FillComponentSpaceTransformsRequiredBones;
  void SetRootBodyIndex(long InBodyIndex);
  void ResetRootBodyIndex();
  [Value] attribute TArrayFBodyInstancePtr Bodies;
  [Value] attribute TArrayFConstraintInstancePtr Constraints;
  [Value] attribute FSkeletalMeshComponentClothTickFunction ClothTickFunction;
  [Const, Ref] TMapFNamefloat GetMorphTargetCurves();
  void InitAnim(boolean bForceReinit);
  void TickAnimation(float DeltaTime, boolean bNeedsValidRootMotion);
  void TickClothing(float DeltaTime, [Ref] FTickFunction ThisTickFunction);
  void GetUpdateClothSimulationData([Ref] TMapint32FClothSimulData OutClothSimData, optional USkeletalMeshComponent? OverrideLocalRootComponent = null);
  boolean IsValidClothingActor([Const, Ref] FClothingActor ClothingActor);
  void DrawClothingNormals(FPrimitiveDrawInterface PDI);
  void DrawClothingTangents(FPrimitiveDrawInterface PDI);
  void DrawClothingCollisionVolumes(FPrimitiveDrawInterface PDI);
  void DrawClothingMaxDistances(FPrimitiveDrawInterface PDI);
  void DrawClothingBackstops(FPrimitiveDrawInterface PDI);
  void DrawClothingPhysicalMeshWire(FPrimitiveDrawInterface PDI);
  void DrawClothingFixedVertices(FPrimitiveDrawInterface PDI);
  void LoadClothingVisualizationInfo([Ref] FClothingAssetData ClothAssetData);
  void LoadAllClothingVisualizationInfos();
  void FreezeClothSection(boolean bFreeze);
  void SetNotifyRigidBodyCollision(boolean bNewNotifyRigidBodyCollision);
  void SetBodyNotifyRigidBodyCollision(boolean bNewNotifyRigidBodyCollision, [Const] FName BoneName);
  void SetNotifyRigidBodyCollisionBelow(boolean bNewNotifyRigidBodyCollision, [Const] FName BoneName, optional boolean bIncludeSelf = true);
  void RecalcRequiredBones(long LODIndex);
  void RecalcRequiredCurves();
  void Serialize([Ref] FArchive Ar);
  void GetResourceSizeEx([Ref] FResourceSizeEx CumulativeResourceSize);
  void InitializeComponent();
  void RegisterEndPhysicsTick(boolean bRegister);
  void RegisterClothTick(boolean bRegister);
  [Value] FBoxSphereBounds CalcBounds([Const, Ref] FTransform LocalToWorld);
  boolean IsAnySimulatingPhysics();
  void UpdateOverlaps([Const] optional TArrayFOverlapInfo? PendingOverlaps=null, optional boolean bDoNotifies=true, [Const] optional TArrayFOverlapInfo? OverlapsAtEndLocation=null);
  UBodySetup GetBodySetup();
  boolean CanEditSimulatePhysics();
  FBodyInstance GetBodyInstance([Const] FName BoneName, optional boolean bGetWelded = true);
  void UpdatePhysicsToRBChannels();
  void SetAllPhysicsAngularVelocity([Const, Ref] FVector NewVel, optional boolean bAddToCurrent = false);
  void SetAllPhysicsPosition([Const] FVector NewPos);
  void SetAllPhysicsRotation([Const, Ref] FQuat NewRot);
  void WakeAllRigidBodies();
  void PutAllRigidBodiesToSleep();
  boolean IsAnyRigidBodyAwake();
  void SetEnableGravity(boolean bGravityEnabled);
  boolean IsGravityEnabled();
  void OnComponentCollisionSettingsChanged();
  void SetPhysMaterialOverride(UPhysicalMaterial NewPhysMaterial);
  void SetEnableBodyGravity(boolean bEnableGravity, [Const] FName BoneName);
  boolean IsBodyGravityEnabled([Const] FName BoneName);
  void SetEnableGravityOnAllBodiesBelow(boolean bEnableGravity, [Const] FName BoneName, optional boolean bIncludeSelf=true);
  boolean GetClosestPointOnPhysicsAsset([Const, Ref] FVector WorldPosition, [Ref] FClosestPointOnPhysicsAsset ClosestPointOnPhysicsAsset, boolean bApproximate);
  boolean LineTraceComponent([Ref] FHitResult OutHit, [Const] FVector Start, [Const] FVector End, [Const, Ref] FCollisionQueryParams Params);
  boolean SweepComponent([Ref] FHitResult OutHit, [Const] FVector Start, [Const] FVector End, [Const, Ref] FQuat ShapRotation, [Const, Ref] FCollisionShape CollisionShape, optional boolean bTraceComplex=false);
  boolean OverlapComponent([Const, Ref] FVector Pos, [Const, Ref] FQuat Rot, [Const, Ref] FCollisionShape CollisionShape);
  void SetSimulatePhysics(boolean bEnabled);
  void AddRadialImpulse([Const] FVector Origin, float Radius, float Strength, [Ref] ERadialImpulseFalloff Falloff, optional boolean bVelChange=false);
  void AddRadialForce([Const] FVector Origin, float Radius, float Strength, [Ref] ERadialImpulseFalloff Falloff, optional boolean bAccelChange=false);
  void SetAllPhysicsLinearVelocity([Const] FVector NewVel, optional boolean bAddToCurrent = false);
  void SetAllMassScale(optional float InMassScale = 1.0);
  float GetMass();
  float GetBoneMass([Const] FName BoneName, optional boolean bScaleMass = true);
  [Value] FVector GetSkeletalCenterOfMass();
  float CalculateMass([Const] FName BoneName);
  void AddForceToAllBodiesBelow([Const] FVector Force, [Const] FName BoneName, optional boolean bAccelChange = false, optional boolean bIncludeSelf = true);
  boolean UpdateLODStatus();
  void RefreshBoneTransforms(optional FActorComponentTickFunction? TickFunction = null);
  void TickPose(float DeltaTime, boolean bNeedsValidRootMotion);
  void UpdateSlaveComponent();
  boolean ShouldUpdateTransform(boolean bLODHasChanged);
  boolean ShouldTickPose();
  boolean AllocateTransformData();
  void DeallocateTransformData();
  void HideBone(long BoneIndex, [Const] EPhysBodyOp PhysBodyOption);
  void UnHideBone(long BoneIndex);
  void SetPhysicsAsset(UPhysicsAsset NewPhysicsAsset, optional boolean bForceReInit = false);
  void SetSkeletalMesh(USkeletalMesh NewMesh, optional boolean bReinitPose = true);
  [Value] FVector GetSkinnedVertexPosition(long VertexIndex);
  void SetSkeletalMeshWithoutResettingAnimation(USkeletalMesh NewMesh);
  boolean IsPlayingRootMotion();
  boolean IsPlayingRootMotionFromEverything();
  void FinalizeBoneTransform();
  void UpdateRBJointMotors();
  void PerformAnimationEvaluation([Const] USkeletalMesh InSkeletalMesh, UAnimInstance InAnimInstance, [Ref] TArrayFTransform OutSpaceBases, [Ref] TArrayFTransform OutBoneSpaceTransforms, [Ref] FVector OutRootBoneTranslation, [Ref] FBlendedHeapCurve OutCurve);
  void EvaluatePostProcessMeshInstance([Ref] TArrayFTransform OutBoneSpaceTransforms, [Ref] FBlendedHeapCurve OutCurve, [Const] USkeletalMesh InSkeletalMesh, [Ref] FVector OutRootBoneTranslation);
  void PostAnimEvaluation([Ref] FAnimationEvaluationContext EvaluationContext);
  void BlendPhysicsBones([Ref] TArrayFBoneIndexType Bones);
  void BlendInPhysics([Ref] FTickFunction ThisTickFunction);
  void InitArticulated(FPhysScene PhysScene);
  void TermArticulated();
  long FindRootBodyIndex();
  void TermBodiesBelow([Const] FName ParentBoneName);
  FConstraintInstance FindConstraintInstance([Const] FName ConName);
  float GetTotalMassBelowBone([Const] FName InBoneName);
  void SetAllBodiesCollisionObjectType([Const] ECollisionChannel NewChannel);
  void SetAllBodiesNotifyRigidBodyCollision(boolean bNewNotifyRigidBodyCollision);
  void SetAllBodiesSimulatePhysics(boolean bNewSimulate);
  void SetPhysicsBlendWeight(float PhysicsBlendWeight);
  void SetEnablePhysicsBlending(boolean bNewBlendPhysics);
  void SetAllBodiesBelowSimulatePhysics([Const, Ref] FName InBoneName, boolean bNewSimulate, optional boolean bIncludeSelf = true);
  void ResetAllBodiesSimulatePhysics();
  void SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, optional boolean bSkipCustomPhysicsType = false);
  void SetAllBodiesBelowPhysicsBlendWeight([Const, Ref] FName InBoneName, float PhysicsBlendWeight, optional boolean bSkipCustomPhysicsType = false, optional boolean bIncludeSelf = true);
  void AccumulateAllBodiesBelowPhysicsBlendWeight([Const, Ref] FName InBoneName, float AddPhysicsBlendWeight, optional boolean bSkipCustomPhysicsType = false);
  void SetAllMotorsAngularPositionDrive(boolean bEnableSwingDrive, boolean bEnableTwistDrive, optional boolean bSkipCustomPhysicsType = false);
  void SetAllMotorsAngularVelocityDrive(boolean bEnableSwingDrive, boolean bEnableTwistDrive, optional boolean bSkipCustomPhysicsType = false);
  void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, optional boolean bSkipCustomPhysicsType = false);
  void SetConstraintProfile([Const] FName JointName, [Const] FName ProfileName, optional boolean bDefaultIfNotFound = false);
  void SetConstraintProfileForAll([Const] FName ProfileName, optional boolean bDefaultIfNotFound = false);
  void SetNamedMotorsAngularPositionDrive(boolean bEnableSwingDrive, boolean bEnableTwistDrive, [Const, Ref] TArrayFName BoneNames, optional boolean bSetOtherBodiesToComplement = false);
  void SetNamedMotorsAngularVelocityDrive(boolean bEnableSwingDrive, boolean bEnableTwistDrive, [Const, Ref] TArrayFName BoneNames, optional boolean bSetOtherBodiesToComplement = false);
  void GetWeldedBodies([Ref] TArrayFBodyInstancePtr OutWeldedBodies, [Ref] TArrayFName OutChildrenLabels, optional boolean bIncludingAutoWeld = false);
  void SetForceRefPose(boolean bNewForceRefPose);
  void UpdateHasValidBodies();
  void UpdateBoneBodyMapping();
  long  FindConstraintIndex([Const] FName ConstraintName);
  [Value] FName  FindConstraintBoneName(long ConstraintIndex);
  void UpdateMeshForBrokenConstraints();
  void NotifySkelControlBeyondLimit(USkelControlLookAt LookAt);
  void BreakConstraint([Const] FVector Impulse, [Const] FVector HitLocation, [Const] FName InBoneName);
  void SetAngularLimits([Const] FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle);
  [Value] FVector GetClosestCollidingRigidBodyLocation([Const, Ref] FVector TestLocation);
  void ApplyDeltaToAllPhysicsTransforms([Const, Ref] FVector DeltaLocation, [Const, Ref] FQuat DeltaRotation);


  boolean IsAnimBlueprintInstanced();
  void DebugDrawBones(UCanvas Canvas, boolean bSimpleBones);
  void ParallelAnimationEvaluation();
  void CompleteParallelAnimationEvaluation(boolean bDoPostAnimEvaluation);
  boolean IsRunningParallelEvaluation();
  boolean HandleExistingParallelEvaluationTask(boolean bBlockOnTask, boolean bPerformPostAnimEvaluation);
  void ApplyAnimationCurvesToComponent([Const] TMapFNamefloat InMaterialParameterCurves, [Const] TMapFNamefloat InAnimationMorphCurves);
  attribute float LastPoseTickTime;
  boolean PoseTickedThisFrame();
  [Value] FTransform ConvertLocalRootMotionToWorld([Const, Ref] FTransform InTransform);
  [Value] FRootMotionMovementParams ConsumeRootMotion();
  boolean CanHaveStaticMobility();
  [Value] FDelegateHandle RegisterOnPhysicsCreatedDelegate([Const, Ref] FOnSkelMeshPhysicsCreated Delegate);
  void UnregisterOnPhysicsCreatedDelegate([Const, Ref] FDelegateHandle DelegateHandle);

/* TODO */
/* not enabled in our build */
  // #if WITH_APEX_CLOTHING
  // attribute float ClothTeleportCosineThresholdInRad;
  // attribute float ClothTeleportDistThresholdSquared;
  // FClothingActor::TeleportMode ClothTeleportMode;
  // boolean IsClothBoundToMasterComponent();
  // [Const, Ref] TArrayFClothingActor GetClothingActors();
  // attribute float ClothMaxDistanceScale;
  // attribute boolean bPreparedClothMorphTargets;
  // [Value] attribute TArrayFClothMorphTargetData ClothMorphTargets;
  // #if WITH_CLOTH_COLLISION_DETECTION
  // attribute unsigned long ClothingCollisionRevision;
  // TArray<nvidia::apex::ClothingCollision*>  ParentCollisions;
  // TArray<nvidia::apex::ClothingCollision*>  EnvironmentCollisions;
  // TArray<nvidia::apex::ClothingCollision*>  ChildrenCollisions;
  // TMap<TWeakObjectPtr<UPrimitiveComponent>, FApexClothCollisionInfo> ClothOverlappedComponentsMap;
  // #endif // WITH_CLOTH_COLLISION_DETECTION
  // #endif // WITH_APEX_CLOTHING
  // #if WITH_APEX_CLOTHING
  // bool CreateClothingActor(int32 AssetIndex, nvidia::apex::ClothingAsset* ClothingAsset, optional TArray<FVector>* BlendedDelta? = null);
  // void RecreateClothingActors();
  // void AddClothingBounds(FBoxSphereBounds& InOutBounds, const FTransform& LocalToWorld) const;
  // void SetClothingLOD(int32 LODIndex);
  // virtual void CheckClothTeleport();
  // void PrepareClothMorphTargets();
  // void ChangeClothMorphTargetMapping(FClothMorphTargetData& MorphData, FName CurrentActivatedMorphName);
  // void UpdateClothMorphTarget();
  // void UpdateClothStateAndSimulate(float DeltaTime, FTickFunction& ThisTickFunction);
  // void UpdateClothTransform(ETeleportType TeleportType);
  // bool HasValidClothingActors() const;
  // void GetClothRootBoneMatrix(int32 AssetIndex, FMatrix& OutRootBoneMatrix) const;
  // bool GetClothSimulatedPosition(int32 AssetIndex, int32 VertexIndex, FVector& OutSimulPos) const;
  // #if WITH_CLOTH_COLLISION_DETECTION
  // void DrawDebugClothCollisions();
  // void DrawDebugConvexFromPlanes(FClothCollisionPrimitive& CollisionPrimitive, FColor& Color, bool bDrawWithPlanes=true);
  // void ReleaseClothingCollision(nvidia::apex::ClothingCollision* Collision);
  // FApexClothCollisionInfo* CreateNewClothingCollsions(UPrimitiveComponent* PrimitiveComponent);
  // void RemoveAllOverlappedComponentMap();
  // void UpdateOverlappedComponent(UPrimitiveComponent* PrimComp, FApexClothCollisionInfo* Info);
  // void ReleaseAllParentCollisions();
  // void ReleaseAllChildrenCollisions();
  // void ProcessClothCollisionWithEnvironment();
  // void CopyClothCollisionsToChildren();
  // void CopyChildrenClothCollisionsToParent();
  // bool GetClothCollisionDataFromStaticMesh(UPrimitiveComponent* PrimComp, TArray<FClothCollisionPrimitive>& ClothCollisionPrimitives);
  // void FindClothCollisions(TArray<FApexClothCollisionVolumeData>& OutCollisions);
  // void CreateInternalClothCollisions(TArray<FApexClothCollisionVolumeData>& InCollisions, TArray<nvidia::apex::ClothingCollision*>& OutCollisions);
  // void ReleaseAllClothingResources();
  // void RemoveAllClothingActors();
  // #endif // WITH_CLOTH_COLLISION_DETECTION
  // #endif // WITH_APEX_CLOTHING

/* missing source code */
  // void InitSkelControls();

/* bitfields not supported */
  //uint32 bHasValidBodies:1;
  //uint32 bDeferredKinematicUpdate:1;
  //uint32 bBlendPhysics:1;
  //uint32 bEnablePhysicsOnDedicatedServer:1;
  //uint32 bUpdateJointsFromAnimation:1;
  //uint32 bDisableClothSimulation:1;
  //uint32 bCollideWithEnvironment:1;
  //uint32 bCollideWithAttachedChildren:1;
  //uint32 bLocalSpaceSimulation : 1;
  //uint32 bClothMorphTarget : 1;
  //uint32 bResetAfterTeleport:1;
  //uint32 bDisplayClothingNormals:1;
  //uint32 bDisplayClothingTangents:1;
  //uint32 bDisplayClothingCollisionVolumes:1;
  //uint32 bDisplayClothPhysicalMeshWire:1;
  //uint32 bDisplayClothMaxDistances:1;
  //uint32 bDisplayClothBackstops:1;
  //uint32 bPrevDisableClothSimulation:1;
  //uint32 bDisplayClothFixedVertices:1;
  //uint32 bNoSkeletonUpdate:1;
  //uint32 bPauseAnims:1;
  //uint32 bEnablePerPolyCollision:1;
  //uint32 bAutonomousTickPose : 1;
  //uint32 bForceRefpose:1;
  //uint32 bOldForceRefPose:1;
  //uint32 bShowPrePhysBones:1;
  //uint32 bRequiredBonesUpToDate:1;
  //uint32 bAnimTreeInitialised:1;
  //uint32 bIncludeComponentLocationIntoBounds : 1;
  //uint32 bEnableLineCheckWithBounds:1;

/* too tedious to do */
  //void UpdateKinematicBonesToAnim(const TArray<FTransform>& InComponentSpaceTransforms, ETeleportType Teleport, bool bNeedsSkinning, optional EAllowKinematicDeferral DeferralAllowed = EAllowKinematicDeferral::AllowDeferral);
  //void SetAnimationMode(EAnimationMode::Type InAnimationMode);
  //EAnimationMode::Type GetAnimationMode() const;
  // class physx::PxAggregate* Aggregate; // TODO(l.bialek) #if WITH_PHYSX
  //void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction ThisTickFunction);
  //void OnUpdateTransform(EUpdateTransformFlags UpdateTransformFlags, optional ETeleportType Teleport = ETeleportType::None);
  // void SetAllPhysicsRotation([Const] FRotator NewRot); // overload
  //boolean GetSquaredDistanceToCollision([Const, Ref] FVector Point, [Ref] float OutSquaredDistance, [Ref] FVector OutClosestPointOnCollision);
  //boolean K2_GetClosestPointOnPhysicsAsset([Const, Ref] FVector WorldPosition, [Ref] FVector ClosestWorldPosition, [Ref] FVector Normal, [Ref] FName BoneName, [Ref] float Distance);
  //long ForEachBodyBelow(FName BoneName, boolean bIncludeSelf, boolean bSkipCustomType, TFunctionRef<void(FBodyInstance*)> Func);
  //void GetCurrentJointAngles(FName InBoneName,float& Swing1Angle, float& TwistAngle, float& Swing2Angle) ;
};
USkeletalMeshComponent implements USkinnedMeshComponent;
USkeletalMeshComponent implements IInterface_CollisionDataProvider;

interface USkinnedMeshComponent { };
interface TSubclassOfUAnimInstance { };
interface TArrayUAnimInstancePtr { };
interface FSingleAnimationPlayData { };
interface TArrayFTransform { };
interface FBlendedHeapCurve { };
interface TEnumAsByteEKinematicBonesUpdateToPhysicsType { };
interface TEnumAsByteEPhysicsTransformUpdateModeType { };
interface FConstraintBrokenSignature { };
interface UClass { };
interface UParticleSystemComponent { };
interface UAnimSingleNodeInstance { };
interface TArrayFBoneIndexType { };
interface TArrayFConstraintInstancePtr { };
interface FSkeletalMeshComponentClothTickFunction { };
interface TArrayFClothingActor { };
interface TArrayFClothMorphTargetData { };
interface TMapFNamefloat { };
interface TMapint32FClothSimulData { };
interface FClothingActor { };
[NoDelete]
interface FPrimitiveDrawInterface { };
interface FClothingAssetData { };
interface ELevelTick { };
interface FActorComponentTickFunction { };
interface TArrayFOverlapInfo { };
interface FClosestPointOnPhysicsAsset { };
interface ERadialImpulseFalloff { };
interface EPhysBodyOp { };
interface FAnimationEvaluationContext { };
interface FPhysScene { };
[NoDelete]
interface USkelControlLookAt { };
interface FDelegateHandle { };
interface FOnSkelMeshPhysicsCreated { };
interface UPhysicalMaterial { };
interface FCollisionShape { };
interface FConstraintInstance { };
interface ULightComponent {
  attribute FLightSceneProxy SceneProxy;
  [Value] attribute FStaticShadowDepthMap StaticShadowDepthMap;
  [Value] attribute FRenderCommandFence DestroyFence;

  void SetIntensity(float NewIntensity);
  void SetIndirectLightingIntensity(float NewIntensity);
  void SetLightColor([Ref] FLinearColor NewLightColor, boolean bSRGB);
  void SetTemperature(float NewTemperature);
  void SetLightFunctionMaterial(UMaterialInterface NewLightFunctionMaterial);
  void SetLightFunctionScale([Ref] FVector NewLightFunctionScale);
  void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
  void SetLightFunctionDisabledBrightness(float NewValue);
  void SetAffectDynamicIndirectLighting(boolean bNewValue);
  void SetAffectTranslucentLighting(boolean bNewValue);
  void SetEnableLightShaftBloom(boolean bNewValue);
  void SetBloomScale(float NewValue);
  void SetBloomThreshold(float NewValue);
  void SetBloomTint([Ref] FColor NewValue);
  void SetIESTexture(UTextureLightProfile NewValue);

  boolean AffectsPrimitive([Const] UPrimitiveComponent Primitive);

  boolean AffectsBounds([Const, Ref] FBoxSphereBounds InBounds);
  [Value] FBox GetBoundingBox();
  [Value] FSphere GetBoundingSphere();
  [Value] FVector4 GetLightPosition();
  ELightComponentType GetLightType();
  [Value] FLightmassLightSettings GetLightmassSettings();
  float GetUniformPenumbraSize();
  void UpdateLightGUIDs();
  boolean IsShadowCast(UPrimitiveComponent Primitive);
  boolean IsUsedAsAtmosphereSunLight();
  float ComputeLightBrightness();
  void Serialize([Ref] FArchive Ar);
  void PostLoad();
  void BeginDestroy();
  boolean IsReadyForFinishDestroy();
  FActorComponentInstanceData GetComponentInstanceData();
  void ApplyComponentInstanceData(FPrecomputedLightInstanceData ComponentInstanceData);
  void PropagateLightingScenarioChange();
  boolean IsPrecomputedLightingValid();
  long GetNumMaterials();
  UMaterialInterface GetMaterial(long ElementIndex);
  void SetMaterial(long ElementIndex, UMaterialInterface InMaterial);
  FLightSceneProxy CreateSceneProxy();
  void InvalidateLightingCacheDetailed(boolean bInvalidateBuildEnqueuedLighting, boolean bTranslationOnly);
  void PostInterpChange(UProperty PropertyThatChanged);

  void InvalidateLightingCacheInner(boolean bRecreateLightGuids);
  [Value] FVector GetDirection();
  void UpdateColorAndBrightness();
  [Const] FLightComponentMapBuildData GetLightComponentMapBuildData();
  void InitializeStaticShadowDepthMap();

  static void ReassignStationaryLightChannels(UWorld TargetWorld, boolean bAssignForLightingBuild, ULevel LightingScenario);
};
ULightComponent implements ULightComponentBase;

interface FPrecomputedLightInstanceData {
  [Value] attribute FTransform Transform;
  [Value] attribute FGuid LightGuid;
  attribute long PreviewShadowMapChannel;

  void FPrecomputedLightInstanceData([Const] ULightComponent SourceComponent);
  void ApplyToComponent(UActorComponent Component, [Const, Ref] ECacheApplyPhase CacheApplyPhase);
};

FPrecomputedLightInstanceData implements FSceneComponentInstanceData;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FStaticShadowDepthMap {
  void FStaticShadowDepthMap();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ULineBatchComponent {
};
enum ECanBeCharacterBase {
  "ECB_No",
  "ECB_Yes",
  "ECB_Owner",
  "ECB_MAX",
};

enum EHasCustomNavigableGeometry_Type {
  "EHasCustomNavigableGeometry::No",
  "EHasCustomNavigableGeometry::Yes",
  "EHasCustomNavigableGeometry::EvenIfNotCollidable",
  "EHasCustomNavigableGeometry::DontExport"
};

interface FSpriteCategoryInfo {
  [Value] attribute FName Category;
  [Value] attribute FText DisplayName;
  [Value] attribute FText Description;
};


interface UPrimitiveComponent {
  attribute float MinDrawDistance;
  attribute float LDMaxDrawDistance;
  attribute float CachedMaxDrawDistance;
  [Value] attribute TEnumAsByteESceneDepthPriorityGroup DepthPriorityGroup;
  [Value] attribute TEnumAsByteESceneDepthPriorityGroup ViewOwnerDepthPriorityGroup;
  attribute unsigned long bAlwaysCreatePhysicsState;
  attribute unsigned long bGenerateOverlapEvents;
  attribute unsigned long bMultiBodyOverlap;
  attribute unsigned long bCheckAsyncSceneOnMove;
  attribute unsigned long bTraceComplexOnMove;
  attribute unsigned long bReturnMaterialOnMove;
  attribute unsigned long bUseViewOwnerDepthPriorityGroup;
  attribute unsigned long bAllowCullDistanceVolume;
  attribute unsigned long bHasMotionBlurVelocityMeshes;
  attribute unsigned long bVisibleInReflectionCaptures;
  attribute unsigned long bRenderInMainPass;
  attribute unsigned long bReceivesDecals;
  attribute unsigned long bOwnerNoSee;
  attribute unsigned long bOnlyOwnerSee;
  attribute unsigned long bTreatAsBackgroundForOcclusion;
  attribute unsigned long bUseAsOccluder;
  attribute unsigned long bSelectable;
  attribute unsigned long bForceMipStreaming;
  attribute unsigned long bHasPerInstanceHitProxies;
  attribute unsigned long CastShadow;
  attribute unsigned long bAffectDynamicIndirectLighting;
  attribute unsigned long bAffectDistanceFieldLighting;
  attribute unsigned long bCastDynamicShadow;
  attribute unsigned long bCastStaticShadow;
  attribute unsigned long bCastVolumetricTranslucentShadow;
  attribute unsigned long bSelfShadowOnly;
  attribute unsigned long bCastFarShadow;
  attribute unsigned long bCastInsetShadow;
  attribute unsigned long bCastCinematicShadow;
  attribute unsigned long bCastHiddenShadow;
  attribute unsigned long bCastShadowAsTwoSided;
  attribute unsigned long bLightAsIfStatic;
  attribute unsigned long bLightAttachmentsAsGroup;
  [Value] attribute TEnumAsByteEIndirectLightingCacheQuality IndirectLightingCacheQuality;
  attribute unsigned long bReceiveCombinedCSMAndStaticShadowsFromStationaryLights;
  attribute unsigned long bSingleSampleShadowFromStationaryLights;
  [Value] attribute FLightingChannels LightingChannels;
  attribute unsigned long bIgnoreRadialImpulse;
  attribute unsigned long bIgnoreRadialForce;
  attribute unsigned long AlwaysLoadOnClient;
  attribute unsigned long AlwaysLoadOnServer;
  attribute unsigned long bUseEditorCompositing;
  attribute unsigned long bRenderCustomDepth;
  attribute long CustomDepthStencilValue;
  attribute long TranslucencySortPriority;
  attribute long VisibilityId;
  [Value] attribute FPrimitiveComponentId ComponentId;
  attribute float LpvBiasMultiplier;
  [Value] attribute FBodyInstance BodyInstance;

  attribute float BoundsScale;
  attribute float LastSubmitTime;
  attribute float LastRenderTime;

  [Value] attribute TEnumAsByteECanBeCharacterBase CanCharacterStepUpOn;
  [Value] attribute TArrayAActorPtr MoveIgnoreActors;
  void IgnoreActorWhenMoving(AActor Actor, boolean bShouldIgnore);
  [Value] TArrayAActorPtr CopyArrayOfMoveIgnoreActors();
  [Const, Value] TArrayAActorPtr GetMoveIgnoreActors();
  void ClearMoveIgnoreActors();
  [Value] attribute TArrayUPrimitiveComponentPtr MoveIgnoreComponents;
  void IgnoreComponentWhenMoving(UPrimitiveComponent Component, boolean bShouldIgnore);
  [Value] TArrayUPrimitiveComponentPtr CopyArrayOfMoveIgnoreComponents();
  [Const, Value] TArrayUPrimitiveComponentPtr GetMoveIgnoreComponents();
  void ClearMoveIgnoreComponents();
  void SetMoveIgnoreMask(octet InMoveIgnoreMask);
  octet GetMoveIgnoreMask();
  void SetMaskFilterOnBodyInstance(octet InMaskFilter);
  octet GetMaskFilterOnBodyInstance(octet InMaskFilter);

  void BeginComponentOverlap([Const, Ref] FOverlapInfo OtherOverlap, boolean bDoNotifies);
  void EndComponentOverlap([Const, Ref] FOverlapInfo OtherOverlap, boolean bDoNotifies, boolean bSkipNotifySelf);
  boolean IsOverlappingComponent([Const] UPrimitiveComponent OtherComp);
  boolean IsOverlappingActor([Const] AActor Other);
  boolean GetOverlapsWithActor([Const] AActor Actor, [Ref] TArrayFOverlapInfo OutOverlaps);
  void GetOverlappingActors([Ref] TArrayAActorPtr OverlappingActors, [Ref] TSubclassOfAActor ClassFilter);
  void GetOverlappingComponents([Ref] TArrayUPrimitiveComponentPtr InOverlappingComponents);
  [Value] TArrayFOverlapInfo GetOverlapInfos();
  boolean ComponentOverlapMulti([Ref] TArrayFOverlapResult OutOverlaps, [Const] UWorld InWorld, [Const, Ref] FVector Pos, [Const, Ref] FQuat Rot, ECollisionChannel TestChannel, [Const, Ref] FComponentQueryParams Params, [Const, Ref] FCollisionObjectQueryParams ObjectQueryParams);

  [Value] attribute FComponentHitSignature OnComponentHit;
  [Value] attribute FComponentBeginOverlapSignature OnComponentBeginOverlap;
  [Value] attribute FComponentEndOverlapSignature OnComponentEndOverlap;
  [Value] attribute FComponentWakeSignature OnComponentWake;
  [Value] attribute FComponentSleepSignature OnComponentSleep;
  [Value] attribute FComponentBeginCursorOverSignature OnBeginCursorOver;
  [Value] attribute FComponentEndCursorOverSignature OnEndCursorOver;
  [Value] attribute FComponentOnClickedSignature OnClicked;
  [Value] attribute FComponentOnReleasedSignature OnReleased;
  [Value] attribute FComponentOnInputTouchBeginSignature OnInputTouchBegin;
  [Value] attribute FComponentOnInputTouchEndSignature OnInputTouchEnd;
  [Value] attribute FComponentBeginTouchOverSignature OnInputTouchEnter;
  [Value] attribute FComponentEndTouchOverSignature OnInputTouchLeave;

  void SetBoundsScale(float NewBoundsScale);
  UMaterialInterface GetMaterial(long ElementIndex);
  void SetMaterial(long ElementIndex, UMaterialInterface Material);
  void SetMaterialByName([Ref] FName MaterialSlotName, UMaterialInterface Material);
  UMaterialInstanceDynamic CreateAndSetMaterialInstanceDynamic(long ElementIndex);
  UMaterialInstanceDynamic CreateAndSetMaterialInstanceDynamicFromMaterial(long ElementIndex, UMaterialInterface Parent);
  UMaterialInstanceDynamic CreateDynamicMaterialInstance(long ElementIndex, UMaterialInterface SourceMaterial);
  [Const, Ref] FWalkableSlopeOverride GetWalkableSlopeOverride();
  void SetWalkableSlopeOverride([Const, Ref] FWalkableSlopeOverride NewOverride);
  void SetSimulatePhysics(boolean bSimulate);
  boolean CanEditSimulatePhysics();

  void SetConstraintMode(EDOFMode_Type ConstraintMode);
  void AddImpulse([Ref] FVector Impulse, [Ref] FName BoneName, boolean bVelChange);
  void AddAngularImpulse([Ref] FVector Impulse, [Ref] FName BoneName, boolean bVelChange);
  void AddImpulseAtLocation([Ref] FVector Impulse, [Ref] FVector Location, [Ref] FName BoneName);
  void AddRadialImpulse([Ref] FVector Origin, float Radius, float Strength,[Ref] ERadialImpulseFalloff Falloff, boolean bVelChange);
  void AddForce([Ref] FVector Force, [Ref] FName BoneName, boolean bAccelChange);
  void AddForceAtLocation([Ref] FVector Force, [Ref] FVector Location, [Ref] FName BoneName);
  void AddRadialForce([Ref] FVector Origin, float Radius, float Strength,[Ref] ERadialImpulseFalloff Falloff, boolean bAccelChange);
  void AddTorque([Ref] FVector Torque, [Ref] FName BoneName, boolean bAccelChange);
  void SetPhysicsLinearVelocity([Ref] FVector NewVel, boolean bAddToCurrent, [Ref] FName BoneName);
  [Value] FVector GetPhysicsLinearVelocity([Ref] FName BoneName);
  [Value] FVector GetPhysicsLinearVelocityAtPoint([Ref] FVector Point, [Ref] FName BoneName);
  void SetAllPhysicsLinearVelocity([Ref] FVector NewVel, boolean bAddToCurrent);
  void SetPhysicsAngularVelocity([Ref] FVector NewAngVel, boolean bAddToCurrent, [Ref] FName BoneName);
  void SetPhysicsMaxAngularVelocity(float NewMaxAngVel, boolean bAddToCurrent, [Ref] FName BoneName);
  [Value] FVector GetPhysicsAngularVelocity([Ref] FName BoneName);
  [Value] FVector GetCenterOfMass([Ref] FName BoneName);
  void SetCenterOfMass([Ref] FVector CenterOfMassOffset, [Ref] FName BoneName);
  void WakeRigidBody([Ref] FName BoneName);
  void PutRigidBodyToSleep([Ref] FName BoneName);
  void SetNotifyRigidBodyCollision(boolean bNewNotifyRigidBodyCollision);
  void SetOwnerNoSee(boolean bNewOwnerNoSee);
  void SetOnlyOwnerSee(boolean bNewOnlyOwnerSee);
  void SetCastShadow(boolean NewCastShadow);
  void SetTranslucentSortPriority(long NewTranslucentSortPriority);
  void SetCollisionEnabled(ECollisionEnabled_Type NewType);
  void SetCollisionProfileName([Ref] FName InCollisionProfileName);
  [Value] FName GetCollisionProfileName();
  void SetCollisionObjectType(ECollisionChannel Channel);
  boolean K2_LineTraceComponent([Ref] FVector TraceStart, [Ref] FVector TraceEnd, boolean bTraceComplex, boolean bShowTrace, [Ref] FVector HitLocation, [Ref] FVector HitNormal, [Ref] FName BoneName);
  void SetRenderCustomDepth(boolean bValue);
  void SetCustomDepthStencilValue(long Value);
  void SetRenderInMainPass(boolean bValue);

  static attribute long CurrentTag;
  attribute FPrimitiveSceneProxy SceneProxy;
  [Value] attribute FRenderCommandFence DetachFence;
  [Value] readonly attribute FThreadSafeCounter AttachmentCounter;

  void SetLODParentPrimitive(UPrimitiveComponent InLODParentPrimitive);
  UPrimitiveComponent GetLODParentPrimitive();

  boolean ShouldRenderSelected();
  boolean IsComponentIndividuallySelected();
  boolean HasStaticLighting();
  boolean HasValidSettingsForStaticLighting(boolean bOverlookInvalidComponents);
  boolean UsesOnlyUnlitMaterials();
  boolean GetLightMapResolution(long Width, long Height);
  long GetStaticLightMapResolution();
  void GetLightAndShadowMapMemoryUsage(long LightMapMemoryUsage, long ShadowMapMemoryUsage);

  ELightMapInteractionType GetStaticLightingType();
  void GetStreamingTextureInfo([Ref] FStreamingTextureLevelContext LevelContext, [Ref] TArrayFStreamingTexturePrimitiveInfo OutStreamingTextures);
  void GetStreamingTextureInfoWithNULLRemoval([Ref] FStreamingTextureLevelContext LevelContext, [Ref] TArrayFStreamingTexturePrimitiveInfo OutStreamingTextures);
  boolean RequiresStreamingTextureData();
  boolean HasTextureStreamingMaterialData(boolean bCheckForScales, long TextureIndex, FMaterialTextureInfo OutTextureData);
  boolean HasStreamingTextureData();
  void UpdateTextureStreamingMaterialData([Const, Ref] FTexCoordScaleMap TexCoordScales);
  void UpdateStreamingTextureData([Ref] TArrayUTexture2DPtr LevelTextures, [Const, Ref] FTexCoordScaleMap TexCoordScales, EMaterialQualityLevel_Type QualityLevel, ERHIFeatureLevel_Type FeatureLevel);
  octet GetStaticDepthPriorityGroup();
  void GetUsedMaterials([Ref] TArrayUMaterialInterfacePtr OutMaterials);
  void GetUsedTextures([Ref] TArrayUTexturePtr OutTextures, EMaterialQualityLevel_Type QualityLevel);

  [Value] attribute FPrimitiveComponentPostPhysicsTickFunction PostPhysicsComponentTick;
  UBodySetup GetBodySetup();

  void SyncComponentToRBPhysics();
  [Value] FMatrix GetRenderMatrix();
  long GetNumMaterials();

  FBodyInstance GetBodyInstance([Ref] FName BoneName, boolean bGetWelded);
  boolean GetSquaredDistanceToCollision([Const, Ref] FVector Point, float OutSquaredDistance, [Ref] FVector OutClosestPointOnCollision);
  float GetDistanceToCollision([Const, Ref] FVector Point, [Ref] FVector ClosestPointOnCollision);
  float GetClosestPointOnCollision([Const, Ref] FVector Point, [Ref] FVector OutPointOnBody, [Ref] FName BoneName);
  FPrimitiveSceneProxy CreateSceneProxy();
  boolean ShouldRecreateProxyOnUpdateTransform();
  boolean IsZeroExtent();
  void ReceiveComponentDamage(float DamageAmount, [Ref] FDamageEvent DamageEvent, AController EventInstigator, AActor DamageCauser);
  void WeldTo(USceneComponent InParent, [Ref] FName InSocketName);
  boolean WeldToImplementation(USceneComponent InParent, [Ref] FName ParentSocketName, boolean bWeldSimulatedChild);
  void UnWeldFromParent();
  void UnWeldChildren();
  void GetWeldedBodies([Ref] TArrayFBodyInstancePtr OutWeldedBodies, [Ref] TArrayFName OutLabels, boolean bIncludingAutoWeld);
  boolean IsWelded();

  boolean K2_IsCollisionEnabled();
  boolean K2_IsQueryCollisionEnabled();
  boolean K2_IsPhysicsCollisionEnabled();
  void DispatchBlockingHit([Ref] AActor OutOwner, [Ref] FHitResult BlockingHit);
  void DispatchWakeEvents(long WakeEvent, [Ref] FName BoneName);
  void InitSweepCollisionParams([Ref] FCollisionQueryParams OutParams, [Ref] FCollisionResponseParams OutResponseParam);
  [Value] FCollisionShape GetCollisionShape(float Inflation);
  boolean AreSymmetricRotations([Const, Ref] FQuat A, [Const, Ref] FQuat B, [Const, Ref] FVector Scale3D);
  void PushSelectionToProxy();
  void PushHoveredToProxy([Const] boolean bInHovered);
  void PushEditorVisibilityToProxy(unsigned long InVisibility);
  float GetEmissiveBoost(long ElementIndex);
  float GetDiffuseBoost(long ElementIndex);
  boolean GetShadowIndirectOnly();

  void SetAllPhysicsAngularVelocity([Const, Ref] FVector NewAngVel, boolean bAddToCurrent);
  void SetAllPhysicsPosition([Ref] FVector NewPos);
  void SetAllPhysicsRotation([Ref] FRotator NewRot);
  void WakeAllRigidBodies();
  void SetEnableGravity(boolean bGravityEnabled);
  boolean IsGravityEnabled();
  void SetLinearDamping(float InDamping);
  float GetLinearDamping();
  void SetAngularDamping(float InDamping);
  float GetAngularDamping();
  void SetMassScale([Ref] FName BoneName, float InMassScale);
  float GetMassScale([Ref] FName BoneName);
  void SetAllMassScale(float InMassScale);
  void SetMassOverrideInKg([Ref] FName BoneName, float MassInKg, boolean bOverrideMass);
  float GetMass();
  [Value] FVector GetInertiaTensor([Ref] FName BoneName);
  [Value] FVector ScaleByMomentOfInertia([Ref] FVector InputVector, [Ref] FName BoneName);
  float CalculateMass([Ref] FName BoneName);
  void PutAllRigidBodiesToSleep();
  boolean RigidBodyIsAwake([Ref] FName BoneName);
  boolean IsAnyRigidBodyAwake();
  void SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse);
  void SetCollisionResponseToAllChannels(ECollisionResponse NewResponse);
  void SetCollisionResponseToChannels([Const, Ref] FCollisionResponseContainer NewReponses);

  boolean ConditionalApplyRigidBodyState([Ref] FRigidBodyState UpdatedState, [Const, Ref] FRigidBodyErrorCorrection ErrorCorrection, [Ref] FVector OutDeltaPos, [Ref] FName BoneName);
  boolean GetRigidBodyState([Ref] FRigidBodyState OutState, [Ref] FName BoneName);
  void SetPhysMaterialOverride(UPhysicalMaterial NewPhysMaterial);
  boolean ShouldComponentAddToScene();
  void SetCullDistance(float NewCullDistance);
  void SetCachedMaxDrawDistance([Const] float NewCachedMaxDrawDistance);
  void SetDepthPriorityGroup(ESceneDepthPriorityGroup NewDepthPriorityGroup);
  void SetViewOwnerDepthPriorityGroup(boolean bNewUseViewOwnerDepthPriorityGroup, ESceneDepthPriorityGroup NewViewOwnerDepthPriorityGroup);
  boolean LineTraceComponent([Ref] FHitResult OutHit, [Const, Ref] FVector Start, [Const, Ref] FVector End, [Const, Ref] FCollisionQueryParams Params);
  boolean SweepComponent([Ref] FHitResult OutHit, [Const, Ref] FVector Start, [Const, Ref] FVector End, [Const, Ref] FQuat ShapeWorldRotation, [Const, Ref] FCollisionShape CollisionShape, boolean bTraceComplex);
  boolean ComponentOverlapComponent(UPrimitiveComponent PrimComp, [Const, Ref] FVector Pos, [Const, Ref] FQuat Rot, [Const, Ref] FCollisionQueryParams Params);

  boolean OverlapComponent([Const, Ref] FVector Pos, [Const, Ref] FQuat Rot, [Const, Ref] FCollisionShape CollisionShape);
  boolean ComputePenetration([Ref] FMTDResult OutMTD, [Const, Ref] FCollisionShape CollisionShape, [Const, Ref] FVector Pos, [Const, Ref] FQuat Rot);
  boolean CanCharacterStepUp(APawn Pawn);
  EHasCustomNavigableGeometry_Type HasCustomNavigableGeometry();
  void SetCustomNavigableGeometry([Const] EHasCustomNavigableGeometry_Type InType);
  boolean DoCustomNavigableGeometryExport([Ref] FNavigableGeometryExport GeomExport);

  void DispatchMouseOverEvents(UPrimitiveComponent CurrentComponent, UPrimitiveComponent NewComponent);
  void DispatchTouchOverEvents( ETouchIndex_Type FingerIndex, UPrimitiveComponent CurrentComponent, UPrimitiveComponent NewComponent);
  void DispatchOnClicked([Ref] FKey ButtonClicked);
  void DispatchOnReleased([Ref] FKey ButtonReleased);
  void DispatchOnInputTouchBegin([Const] ETouchIndex_Type Key);
  void DispatchOnInputTouchEnd([Const] ETouchIndex_Type Key);

  // TODO: cannot create constructor with parameters when NewObject is used
  //void UPrimitiveComponent([Const, Ref] FObjectInitializer ObjectInitializer);
  // TODO: cannot overload functions
  //void GetOverlappingActors([Ref] TSetAActorPtr OverlappingActors, [Ref] TSubclassOfAActor ClassFilter);
  //boolean IsOverlappingComponent([Const, Ref] FOverlapInfo Overlap);
  //boolean ComponentOverlapMulti([Ref] TArrayFOverlapResult OutOverlaps, [Const] UWorld InWorld, [Const, Ref] FVector Pos, [Const, Ref] FRotator Rot, ECollisionChannel TestChannel, [Const, Ref] FComponentQueryParams Params, [Const, Ref] FCollisionObjectQueryParams ObjectQueryParams);
  //void SetAllPhysicsRotation([Const, Ref] FQuat NewRot);
  //boolean ComponentOverlapComponent(UPrimitiveComponent PrimComp, [Const, Ref] FVector Pos, [Const, Ref] FRotator Rot, [Const, Ref] FCollisionQueryParams Params);
};
UPrimitiveComponent implements USceneComponent;
UPrimitiveComponent implements INavRelevantInterface;

interface FPrimitiveComponentInstanceData {
  void FPrimitiveComponentInstanceData([Const] UPrimitiveComponent SourceComponent);
  boolean ContainsData();
};
FPrimitiveComponentInstanceData implements FSceneComponentInstanceData;

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteECanBeCharacterBase {
};

interface TArrayUPrimitiveComponent {
};

interface TArrayUPrimitiveComponentPtr {
};

interface FComponentHitSignature {
};

interface FComponentBeginOverlapSignature {
};

interface FComponentEndOverlapSignature {
};

interface FComponentWakeSignature {
};

interface FComponentSleepSignature {
};

interface FComponentBeginCursorOverSignature {
};

interface FComponentEndCursorOverSignature {
};

interface FComponentOnClickedSignature {
};

interface FComponentOnReleasedSignature {
};

interface FComponentOnInputTouchBeginSignature {
};

interface FComponentOnInputTouchEndSignature {
};

interface FComponentBeginTouchOverSignature {
};

interface FComponentEndTouchOverSignature {
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TArrayTArrayFVector2D {
  void TArrayTArrayFVector2D();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FBodySetupUVInfo {
  [Value] attribute TArrayint32 IndexBuffer;
  [Value] attribute TArrayFVector VertPositions;
  [Value] attribute TArrayTArrayFVector2D VertUVs;

  void GetResourceSizeEx([Ref] FResourceSizeEx CumulativeResourceSize);
  long GetResourceSizeBytes();

  // TODO: not supported operator
  // friend FArchive operator<<(FArchive& Ar, FBodySetupUVInfo& UVInfo)
};

interface UBodySetup {
  attribute FFormatContainer CookedFormatDataOverride;
  [Value] attribute FBodySetupUVInfo UVInfo;
  attribute boolean bCreatedPhysicsMeshes;
  attribute boolean bHasCookedCollisionData;
  attribute boolean bNeverNeedsCookedCollisionData;

  void Serialize([Ref] FArchive Ar);
  void BeginDestroy();
  void FinishDestroy();
  void PostLoad();
  void PostInitProperties();
  void GetResourceSizeEx([Ref] FResourceSizeEx CumulativeResourceSize);
  void CopyBodyPropertiesFrom([Const] UBodySetup FromSetup);
  void AddCollisionFrom([Const] UBodySetup FromSetup);
  void CreatePhysicsMeshes();
  float GetVolume([Const, Ref] FVector Scale);
  void ClearPhysicsMeshes();
  float CalculateMass([Const] UPrimitiveComponent Component);
  UPhysicalMaterial GetPhysMaterial();
  void UpdateTriMeshVertices([Const, Ref] TArrayFVector NewPositions);
  float GetShortestDistanceToPoint([Const, Ref] FVector WorldPosition, [Const, Ref] FTransform BodyToWorldTM);
  float GetClosestPointAndNormal([Const, Ref] FVector WorldPosition, [Const, Ref] FTransform BodyToWorldTM, [Ref] FVector ClosestWorldPosition, [Ref] FVector FeatureNormal);
  FByteBulkData GetCookedData([Ref] FName Format, boolean bRuntimeOnlyOptimizedVersion);
  boolean CalcUVAtLocation([Const, Ref] FVector BodySpaceLocation, long FaceIndex, long UVChannel, [Ref] FVector2D UV);

  // TODO: "overloading must differentiate by # of arguments"
  // void AddCollisionFrom([Const, Ref] FKAggregateGeom FromAggGeom);
};

UBodySetup implements UObject;
interface UPhysicsCollisionHandler {
  attribute float ImpactThreshold;
  attribute float ImpactReFireDelay;
  attribute USoundBase DefaultImpactSound;
  attribute float LastImpactSoundTime;

  void HandlePhysicsCollisions_AssumesLocked([Ref] TArrayFCollisionNotifyInfo PendingCollisionNotifies);
  void DefaultHandleCollision_AssumesLocked([Const, Ref] FRigidBodyCollisionInfo MyInfo, [Const, Ref] FRigidBodyCollisionInfo OtherInfo, [Const, Ref] FCollisionImpactData RigidCollisionData);

  void InitCollisionHandler();
};
UPhysicsCollisionHandler implements UObject;
enum EDOFMode_Type {
  "EDOFMode::Default",
  "EDOFMode::SixDOF",
  "EDOFMode::YZPlane",
  "EDOFMode::XZPlane",
  "EDOFMode::XYPlane",
  "EDOFMode::CustomPlane",
  "EDOFMode::None"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FBodyInstance {
};

interface TArrayFBodyInstancePtr {
};

interface FCollisionResponse {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FArchive {
  void FArchive();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TStatId {
  void TStatId();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/
interface FSimpleMulticastDelegate {
};
interface IModularFeature {
  // class is empty
};
interface IModuleInterface {
  void StartupModule();
  void PreUnloadCallback();
  void PostLoadCallback();
  void ShutdownModule();
  boolean SupportsDynamicReloading();
  boolean SupportsAutomaticShutdown();
  boolean IsGameModule();
};
interface TArrayModuleStatus {
  void TArrayModuleStatus();
  VoidPtr GetData();
  long Num();
};

interface TSharedPtrModuleInterface {
};

interface FModuleStatus
{
  void FModuleStatus();
  [Value] attribute FString Name;
  [Value] attribute FString FilePath;
  attribute boolean bIsLoaded;
  attribute boolean bIsGameModule;
};

enum EModuleLoadResult {
  "EModuleLoadResult::Success",
  "EModuleLoadResult::FileNotFound",
  "EModuleLoadResult::FileIncompatible",
  "EModuleLoadResult::CouldNotBeLoadedByOS",
  "EModuleLoadResult::FailedToInitialize"
};

interface FModuleManager {
  [Ref] static FModuleManager Get();
  void AbandonModule([Const, Ref] FName InModuleName);
  void AddModule([Const, Ref] FName InModuleName);
  [Value] TSharedPtrModuleInterface GetModule([Const, Ref] FName InModuleName);
  boolean IsModuleLoaded([Const, Ref] FName InModuleName);
  [Value] TSharedPtrModuleInterface LoadModule([Const, Ref] FName InModuleName, [Const] boolean bWasReloaded);
  [Value] TSharedPtrModuleInterface LoadModuleChecked([Const, Ref] FName InModuleName, [Const] boolean bWasReloaded);
  boolean LoadModuleWithCallback([Const, Ref] FName InModuleName, [Ref] FOutputDevice Ar);
  [Value] TSharedPtrModuleInterface LoadModuleWithFailureReason([Const, Ref] FName InModuleName, EModuleLoadResult OutFailureReason, [Const] boolean bWasReloaded);
  boolean QueryModule([Const, Ref] FName InModuleName, [Ref] FModuleStatus OutModuleStatus);
  void QueryModules([Ref] TArrayModuleStatus OutModuleStatuses);
  boolean UnloadModule([Const, Ref] FName InModuleName, boolean bIsShutdown);
  void UnloadOrAbandonModuleWithCallback([Const, Ref] FName InModuleName, [Ref] FOutputDevice Ar);
  void AbandonModuleWithCallback([Const, Ref] FName InModuleName);

  void FindModules([Const] DOMString WildcardWithoutExtension, [Ref] TArrayFName OutModules );
  boolean ModuleExists([Const] DOMString ModuleName);
  long GetModuleCount();
  void UnloadModulesAtShutdown();
  void StartProcessingNewlyLoadedObjects();
  void AddBinariesDirectory([Const] DOMString InDirectory, boolean bIsGameDirectory);
  void SetGameBinariesDirectory([Const] DOMString InDirectory);
  [Value] FString GetGameBinariesDirectory();
  boolean IsModuleUpToDate([Const, Ref] FName InModuleName);
  boolean DoesLoadedModuleHaveUObjects([Const, Ref] FName ModuleName);
  [Const] static VoidPtr GetUBTConfiguration();
  [Value] FString GetModuleFilename([Ref] FName ModuleName);
  void SetModuleFilename([Ref] FName ModuleName, [Const, Ref] FString Filename);
  [Value] static FString GetCleanModuleFilename([Ref] FName ModuleName, boolean bIsGameModule);
  //[Ref] FModulesChangedEvent OnModulesChanged();
  [Ref] FSimpleMulticastDelegate OnProcessLoadedObjectsCallback();
  //[Ref] FIsPackageLoadedCallback IsPackageLoadedCallback();
  boolean Exec(UWorld Inworld, [Const] DOMString Cmd, [Ref] FOutputDevice Ar);
  void MakeUniqueModuleFilename([Const, Ref] FName InModuleName, [Ref] FString UniqueSuffix, [Ref] FString UniqueModuleFileName);
  void ResetModulePathsCache();

  //TODO
  //void RegisterStaticallyLinkedModule([Const] FName InModuleName, [Const] FInitializeStaticallyLinkedModule InInitializerDelegate);
  //void AddModuleToModulesList([Const] FName InModu
  //[Value] attribute FQueryModulesDelegate QueryModulesDelegate;

  //template<typename TModuleInterface>
  //static TModuleInterface& GetModuleChecked( const FName ModuleName )
  //template<typename TModuleInterface>
  //static TModuleInterface* GetModulePtr( const FName ModuleName )
  //template<typename TModuleInterface>
  //static TModuleInterface& LoadModuleChecked( const FName ModuleName )
  //template<typename TModuleInterface>
  //static TModuleInterface* LoadModulePtr( const FName ModuleName )leName, [Ref] TSharedRefModuleInfo ModuleInfo);
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum TextBiDi_ETextDirection {
  "TextBiDi_ETextDirection::LeftToRight",
  "TextBiDi_ETextDirection::RightToLeft",
  "TextBiDi_ETextDirection::Mixed"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FText {
};
interface TArrayuint8 {
  void TArrayuint8();
  VoidPtr GetData();
  long Num();
};

interface TArrayint8 {
  void TArrayint8();
  VoidPtr GetData();
  long Num();
};

interface TArrayint32 {
  void TArrayint32();
  VoidPtr GetData();
  long Num();
};

interface TArrayfloat {
  void TArrayfloat();
  VoidPtr GetData();
  long Num();
};
interface FString {
  void FString();
  void FString(long InCount, [Const] DOMString InSrc);
  [Const] DOMString Get();
};

interface TArrayFString {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FTexture2DResourceMem {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TMapUPTRINTuint32 {
};

interface TMapuint32uint32 {
};
enum ECompressionFlags {
  "COMPRESS_None",
  "COMPRESS_ZLIB",
  "COMPRESS_GZIP",
  "COMPRESS_BiasMemory",
  "COMPRESS_BiasSpeed"
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FOutputDevice {
};
enum EGuidFormats {
  "EGuidFormats::Digits",
  "EGuidFormats::DigitsWithHyphens",
  "EGuidFormats::DigitsWithHyphensInBraces",
  "EGuidFormats::DigitsWithHyphensInParentheses",
  "EGuidFormats::HexValuesInBraces",
  "EGuidFormats::UniqueObjectGuid"
};

interface FGuid {
  attribute long A;
  attribute long B;
  attribute long C;
  attribute long D;

  void FGuid();
  void FGuid(long InA, long InB, long InC, long InD);
  boolean Serialize([Ref] FArchive Ar );
  boolean ExportTextItem(
    [Ref] FString ValueStr,
    [Const, Ref] FGuid DefaultValue,
    UObject Parent,
    long PortFlags,
    UObject ExportRootScope
  );
  void Invalidate();
  boolean IsValid();
  [Value] FString ToString();
  [Value] FString ToString(EGuidFormats Format);
  [Value] static FGuid NewGuid();
  static boolean Parse([Const, Ref] FString GuidString, [Ref] FGuid OutGuid );
  static boolean ParseExact([Const, Ref] FString GuidString, EGuidFormats Format, [Ref] FGuid OutGuid );

  // TODO: how can we handle "Object*&" in first argument?
  //boolean ImportTextItem(
  //  [Const, Ref] DOMString Buffer,
  //  long PortFlags,
  //  UObject Parent,
  //  FOutputDevice ErrorText
  //);
};
interface FUrlConfig {
  void FUrlConfig();

  [Value] attribute FString DefaultProtocol;
  [Value] attribute FString DefaultName;
  [Value] attribute FString DefaultHost;
  [Value] attribute FString DefaultPortal;
  [Value] attribute FString DefaultSaveExt;
  attribute long DefaultPort;

  void Init();
  void Reset();
};
interface FVector {
  void FVector();
  void FVector(float InF);
  void FVector([Const, Ref] FVector2D V, float InZ);
  void FVector(float InX, float InY, float InZ);
  attribute float X;
  attribute float Y;
  attribute float Z;

  [Value, Const] static readonly attribute FVector ZeroVector;
  [Value, Const] static readonly attribute FVector UpVector;
  [Value, Const] static readonly attribute FVector ForwardVector;
  [Value, Const] static readonly attribute FVector RightVector;

  void DiagnosticCheckNaN();
  void DiagnosticCheckNaN([Const] DOMString Message);
  [Value] static FVector CrossProduct([Const, Ref] FVector A,
                                      [Const, Ref] FVector B);
  static float DotProduct([Const, Ref] FVector A, [Const, Ref] FVector B);
  boolean Equals([Const, Ref] FVector V, float Tolerance);
  boolean AllComponentsEqual(float Tolerance);

  [Operator="=="] boolean equal([Const, Ref] FVector V);
  [Operator="!="] boolean not_equal([Const, Ref] FVector V);
  [Operator="+=", Value] FVector add([Const, Ref] FVector V);
  [Operator="-=", Value] FVector subtract([Const, Ref] FVector V);
  [Operator="*=", Value] FVector multiply([Const, Ref] FVector V);
  [Operator="*=", Value] FVector multiply_scalar(float Scale);
  [Operator="/=", Value] FVector divide([Const, Ref] FVector V);
  [Operator="/=", Value] FVector divide_scalar(float V);
  [Operator="[]"] float at(long Index);
  float Component(long Index);

  void Set(float InX, float InY, float InZ);
  float GetMax();
  float GetAbsMax();
  float GetMin();
  float GetAbsMin();
  [Value] FVector ComponentMin([Const, Ref] FVector Other);
  [Value] FVector ComponentMax([Const, Ref] FVector Other);
  [Value] FVector GetAbs();
  float Size();
  float SizeSquared();
  float Size2D();
  float SizeSquared2D();
  boolean IsNearlyZero(float Tolerance);
  boolean IsZero();
  boolean Normalize(float Tolerance);
  boolean IsNormalized();
  void ToDirectionAndLength([Ref] FVector OutDir, float OutLength);
  [Value] FVector GetSignVector();
  [Value] FVector Projection();
  [Value] FVector GetUnsafeNormal();
  [Value] FVector GridSnap([Const] float GridSz);
  [Value] FVector BoundToCube(float Radius);
  [Value] FVector GetClampedToSize(float Min, float Max);
  [Value] FVector GetClampedToSize2D(float Min, float Max);
  [Value] FVector GetClampedToMaxSize(float MaxSize);
  [Value] FVector GetClampedToMaxSize2D(float MaxSize);

  void AddBounded([Const, Ref] FVector V, float Radius);
  [Value] FVector Reciprocal();
  boolean IsUniform(float Tolerance);
  [Value] FVector MirrorByVector([Const, Ref] FVector MirrorNormal);
  [Value] FVector MirrorByPlane([Const, Ref] FPlane Plane);
  [Value] FVector RotateAngleAxis([Const] float AngleDeg,
                                  [Const, Ref] FVector Axis);
  [Value] FVector GetSafeNormal(float Tolerance);
  [Value] FVector GetSafeNormal2D(float Tolerance);

  float CosineAngle2D([Ref] FVector B);
  [Value] FVector ProjectOnTo([Const, Ref] FVector A);
  [Value] FVector ProjectOnToNormal([Const, Ref] FVector Normal);

  [Value] FRotator ToOrientationRotator();
  [Value] FQuat ToOrientationQuat();
  [Value] FRotator Rotation();
  void FindBestAxisVectors([Ref] FVector Axis1, [Ref] FVector Axis2);
  void UnwindEuler();

  boolean ContainsNaN();
  boolean IsUnit(float LengthSquaredTolerance);
  [Value] FString ToString();
  [Value] FText ToText();
  [Value] FString ToCompactString();
  [Value] FText ToCompactText();
  boolean InitFromString([Const, Ref] FString InSourceString);
  [Value] FVector2D UnitCartesianToSpherical();
  float HeadingAngle();

  static void CreateOrthonormalBasis([Ref] FVector XAxis,
                                     [Ref] FVector YAxis,
                                     [Ref] FVector ZAxis);
  static boolean PointsAreSame([Const, Ref] FVector P, [Const, Ref] FVector Q);
  static boolean PointsAreNear([Const, Ref] FVector Point1,
                               [Const, Ref] FVector Point2,
                               float Dist);
  static float PointPlaneDist([Const, Ref] FVector Point,
                              [Const, Ref] FVector PlaneBase,
                              [Const, Ref] FVector PlaneNormal);
  [Value] static FVector PointPlaneProject([Const, Ref] FVector Point,
                                           [Const, Ref] FPlane Plane);
  [Value] static FVector PointPlaneProject([Const, Ref] FVector Point,
                                           [Const, Ref] FVector A,
                                           [Const, Ref] FVector B,
                                           [Const, Ref] FVector C);
  [Value] static FVector PointPlaneProject([Const, Ref] FVector Point,
                                           [Const, Ref] FVector PlaneBase,
                                           [Const, Ref] FVector PlaneNormal);
  [Value] static FVector VectorPlaneProject([Const, Ref] FVector V,
                                            [Const, Ref] FVector PlaneNormal);

  static float Dist([Const, Ref] FVector V1, [Const, Ref] FVector V2);
  static float DistSquared([Const, Ref] FVector V1, [Const, Ref] FVector V2);
  static float DistSquaredXY([Const, Ref] FVector V1, [Const, Ref] FVector V2);

  static float BoxPushOut([Const, Ref] FVector Normal,
                          [Const, Ref] FVector Size);
  static boolean Parallel([Const, Ref] FVector Normal1,
                          [Const, Ref] FVector Normal2,
                          float ParallelCosineThreshold);
  static boolean Coincident([Const, Ref] FVector Normal1,
                            [Const, Ref] FVector Normal2,
                            float ParallelCosineThreshold);
  static boolean Orthogonal([Const, Ref] FVector Normal1,
                            [Const, Ref] FVector Normal2,
                            float OrthogonalCosineThreshold);
  static boolean Coplanar([Const, Ref] FVector Base1,
                          [Const, Ref] FVector Normal1,
                          [Const, Ref] FVector Base2,
                          [Const, Ref] FVector Normal2,
                          float ParallelCosineThreshold);
  static float Triple([Const, Ref] FVector X,
                      [Const, Ref] FVector Y,
                      [Const, Ref] FVector Z);
  static float EvaluateBezier([Const] FVector ControlPoints,
                              long NumPoints,
                              [Ref] TArrayFVector OutPoints);
  [Value] static FVector RadiansToDegrees([Const, Ref] FVector RadVector);
  [Value] static FVector DegreesToRadians([Const, Ref] FVector DegVector);
  static void GenerateClusterCenters([Ref] TArrayFVector Clusters,
                                     [Const, Ref] TArrayFVector Points,
                                     long NumIterations,
                                     long NumConnectionsToBeValid);
  boolean Serialize([Ref] FArchive Ar);
  boolean NetSerialize([Ref] FArchive Ar, UPackageMap Map, boolean bOutSuccess);

  // TODO: constructor override
  //void FVector([Const, Ref] FLinearColor InColor);
  //void FVector([Const, Ref] FVector4 V);
  //void FVector([Ref] FIntVector InVector);
  //void FVector([Ref] FIntPoint A);

  // TODO: operators not supported
  //FORCEINLINE FVector& operator=(const FVector& Other);
  //FORCEINLINE FVector operator^(const FVector& V) const;
  //FORCEINLINE float operator|(const FVector& V) const;
  //FORCEINLINE FVector operator+(const FVector& V) const;
  //FORCEINLINE FVector operator-(const FVector& V) const;
  //FORCEINLINE FVector operator-(float Bias) const;
  //FORCEINLINE FVector operator+(float Bias) const;
  //FORCEINLINE FVector operator*(float Scale) const;
  //FVector operator/(float Scale) const;
  //FORCEINLINE FVector operator*(const FVector& V) const;
  //FORCEINLINE FVector operator/(const FVector& V) const;
  //FORCEINLINE FVector operator-() const;
  //friend FArchive& operator<<(FArchive& Ar, FVector& V)
};

interface TArrayFVector {
  void TArrayFVector();
  VoidPtr GetData();
  long Num();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FSphere {
  void FSphere();
};
interface FMatrix {
  void FMatrix();
  void FMatrix([Const, Ref] FVector InX,
               [Const, Ref] FVector InY,
               [Const, Ref] FVector InZ,
               [Const, Ref] FVector InW);
  void SetIdentity();

  [Operator="*="] void multiply_matrix([Const, Ref] FMatrix Other);
  [Operator="+="] void add([Const, Ref] FMatrix Other);
  [Operator="*="] void multiply(float Other);

  boolean Equals([Const, Ref] FMatrix Other, float Tolerance);
  [Operator="!="] boolean not_equal([Const, Ref] FMatrix Other);

  [Value] FVector4 TransformFVector4([Const, Ref] FVector4 V);
  [Value] FVector4 TransformPosition([Const, Ref] FVector V);
  [Value] FVector InverseTransformPosition([Const, Ref] FVector V);
  [Value] FVector4 TransformVector([Const, Ref] FVector V);
  [Value] FVector InverseTransformVector([Const, Ref] FVector V);
  [Value] FMatrix GetTransposed();
  float Determinant();
  float RotDeterminant();

  [Value] FMatrix InverseFast();
  [Value] FMatrix Inverse();
  [Value] FMatrix TransposeAdjoint();

  void RemoveScaling(float Tolerance);
  [Value] FMatrix GetMatrixWithoutScale(float Tolerance);
  [Value] FVector ExtractScaling(float Tolerance);
  [Value] FVector GetScaleVector(float Tolerance);
  [Value] FMatrix RemoveTranslation();
  [Value] FMatrix ConcatTranslation([Const, Ref] FVector Translation);

  boolean ContainsNaN();
  void ScaleTranslation([Const, Ref] FVector Scale3D);
  float GetMaximumAxisScale();
  [Value] FMatrix ApplyScale(float Scale);
  [Value] FVector GetOrigin();
  [Value] FVector GetScaledAxis(EAxis_Type Axis);
  void GetScaledAxes([Ref] FVector X, [Ref] FVector Y, [Ref] FVector Z);

  [Value] FVector GetUnitAxis(EAxis_Type Axis);
  void GetUnitAxes([Ref] FVector X, [Ref] FVector Y, [Ref] FVector Z);
  void SetAxis(long i, [Const, Ref] FVector Axis);
  void SetOrigin([Const, Ref] FVector NewOrigin);
  void SetAxes(FVector Axis0, FVector Axis1, FVector Axis2, FVector Origin);
  [Value] FVector GetColumn(long i);

  [Value] FRotator Rotator();
  [Value] FQuat ToQuat();

  boolean GetFrustumNearPlane([Ref] FPlane OutPlane);
  boolean GetFrustumFarPlane([Ref] FPlane OutPlane);
  boolean GetFrustumLeftPlane([Ref] FPlane OutPlane);
  boolean GetFrustumRightPlane([Ref] FPlane OutPlane);
  boolean GetFrustumTopPlane([Ref] FPlane OutPlane);
  boolean GetFrustumBottomPlane([Ref] FPlane OutPlane);

  void Mirror(EAxis_Type MirrorAxis, EAxis_Type FlipAxis);
  [Value] FString ToString();
  void DebugPrint();
  long ComputeHash();
  boolean Serialize([Ref] FArchive Ar);
  void To3x4MatrixTranspose(float[] Out);
  // TODO: override constructor with same args number
  //void FMatrix([Const, Ref] FPlane InX, [Const, Ref] FPlane InY, [Const, Ref] FPlane InZ, [Const, Ref] FPlane InW);

  // TODO: operators not supported
  //FMatrix operator* (const FMatrix& Other) const;
  //FMatrix operator+ (const FMatrix& Other) const;
  //FMatrix operator* (float Other) const;
  //inline bool operator==(const FMatrix& Other) const;
  //friend CORE_API FArchive& operator<<(FArchive& Ar,FMatrix& M);
};

interface FBasisVectorMatrix {
  void FBasisVectorMatrix([Const, Ref] FVector XAxis,
                          [Const, Ref] FVector YAxis,
                          [Const, Ref] FVector ZAxis,
                          [Const, Ref] FVector Origin);
};
FBasisVectorMatrix implements FMatrix;

interface FLookAtMatrix {
  void FLookAtMatrix([Const, Ref] FVector EyePosition,
                     [Const, Ref] FVector LookAtPosition,
                     [Const, Ref] FVector UpVector);
};
FLookAtMatrix implements FMatrix;
interface FVector2D {
  void FVector2D();
  void FVector2D(float InX,float InY);
  void FVector2D([Const, Ref] FVector V);

  [Operator="+=", Value] FVector2D add([Const, Ref] FVector2D V);
  [Operator="-=", Value] FVector2D subtract([Const, Ref] FVector2D V);
  [Operator="*=", Value] FVector2D multiply([Const, Ref] FVector2D V);
  [Operator="/=", Value] FVector2D divide([Const, Ref] FVector2D V);

  float Component(long Index);
  boolean Equals([Const, Ref] FVector2D V, float Tolerance);
  void Set(float InX, float InY);
  float GetMax();
  float GetAbsMax();
  float GetMin();
  float Size();
  float SizeSquared();
  [Value] FVector2D GetRotated(float AngleDeg);
  [Value] FVector2D GetSafeNormal(float Tolerance);
  void Normalize(float Tolerance);
  boolean IsNearlyZero(float Tolerance);
  void ToDirectionAndLength([Ref] FVector2D OutDir, float OutLength);
  boolean IsZero();
  [Value] FIntPoint IntPoint();
  [Value] FVector2D ClampAxes(float MinAxisVal, float MaxAxisVal);
  [Value] FVector2D GetSignVector();
  [Value] FVector2D GetAbs();
  [Value] FString ToString();
  boolean InitFromString([Const, Ref] FString InSourceString);
  boolean Serialize([Ref] FArchive Ar);
  void DiagnosticCheckNaN();
  boolean ContainsNaN();
  boolean NetSerialize([Ref] FArchive Ar, UPackageMap Map, boolean bOutSuccess);
  [Value] FVector SphericalToUnitCartesian();

  [Const, Value] static readonly attribute FVector2D ZeroVector;
  [Const, Value] static readonly attribute FVector2D UnitVector;
  static float DotProduct([Const, Ref] FVector2D A, [Const, Ref] FVector2D B);
  static float DistSquared([Const, Ref] FVector2D V1, [Const, Ref] FVector2D V2);
  static float Distance([Const, Ref] FVector2D V1, [Const, Ref] FVector2D V2);
  static float CrossProduct([Const, Ref] FVector2D A, [Const, Ref] FVector2D B);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/
interface FSHVectorRGB3 {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FIntRect {
  void FIntRect();
};
interface FVector4 {
  attribute float X;
  attribute float Y;
  attribute float Z;
  attribute float W;

  void FVector4([Const, Ref] FVector InVector, float InW);
  void FVector4([Const, Ref] FLinearColor InColor);
  void FVector4(float InX, float InY, float InZ, float InW);

  [Operator="+=", Value] FVector4 add([Const, Ref] FVector4 V);
  [Operator="*=", Value] FVector4 multiply([Const, Ref] FVector4 V);
  [Operator="/=", Value] FVector4 divide([Const, Ref] FVector4 V);

  float Component(long Index);
  boolean Equals([Const, Ref] FVector4 V, float Tolerance);
  boolean IsUnit3(float LengthSquaredTolerance);
  [Value] FString ToString();
  boolean InitFromString([Const, Ref] FString InSourceString);
  [Value] FRotator ToOrientationRotator();
  [Value] FQuat ToOrientationQuat();
  [Value] FRotator Rotation();
  void Set(float InX, float InY, float InZ, float InW);
  float Size3();
  float SizeSquared3();
  boolean ContainsNaN();
  boolean IsNearlyZero3(float Tolerance);
  [Value] FVector4 Reflect3([Const, Ref] FVector4 Normal);
  void FindBestAxisVectors3([Ref] FVector4 Axis1, [Ref] FVector4 Axis2);
  void DiagnosticCheckNaN();
  boolean Serialize([Ref] FArchive Ar);

  // TODO: some constructors missing due to lack of function overloading
  // void FVector4(FVector2D InXY, FVector2D InZW);
};
enum EInterpCurveMode {
  "CIM_Linear",
  "CIM_CurveAuto",
  "CIM_Constant",
  "CIM_CurveUser",
  "CIM_CurveBreak",
  "CIM_CurveAutoClamped",
  "CIM_Unknown"
};

interface FInterpCurvePointFloat {
  attribute float InVal;
  attribute float OutVal;
  attribute float ArriveTangent; 
  attribute float LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointFloat();
  void FInterpCurvePointFloat([Const] float In, [Const] float Out);
  void FInterpCurvePointFloat([Const] float In, [Const] float Out,
                              [Const] float InArriveTangent,
                              [Const] float InLeaveTangent,
                              [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal([Const] FInterpCurvePointFloat Point1,
                                [Const] FInterpCurvePointFloat Point2);
  [Operator="!="] boolean not_equal([Const] FInterpCurvePointFloat Point1,
                                    [Const] FInterpCurvePointFloat Point2);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointFloat& Point )
};

interface FInterpCurvePointVector2D {
  attribute float InVal;
  [Value] attribute FVector2D OutVal;
  [Value] attribute FVector2D ArriveTangent; 
  [Value] attribute FVector2D LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointVector2D();
  void FInterpCurvePointVector2D([Const] float In, [Const, Ref] FVector2D Out);
  void FInterpCurvePointVector2D([Const] float In, [Const, Ref] FVector2D Out,
                                 [Const, Ref] FVector2D InArriveTangent,
                                 [Const, Ref] FVector2D InLeaveTangent,
                                 [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal([Const, Ref] FInterpCurvePointVector2D Point1,
                                [Const, Ref] FInterpCurvePointVector2D Point2);
  [Operator="!="] boolean not_equal(
      [Const, Ref] FInterpCurvePointVector2D Point1,
      [Const, Ref] FInterpCurvePointVector2D Point2);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointVector2D & Point )
};
interface FInterpCurvePointVector {
  attribute float InVal;
  [Value] attribute FVector OutVal;
  [Value] attribute FVector ArriveTangent; 
  [Value] attribute FVector LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointVector();
  void FInterpCurvePointVector([Const] float In, [Const, Ref] FVector Out);
  void FInterpCurvePointVector([Const] float In, [Const, Ref] FVector Out,
                               [Const, Ref] FVector InArriveTangent,
                               [Const, Ref] FVector InLeaveTangent,
                               [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal([Const, Ref] FInterpCurvePointVector Point1,
                                [Const, Ref] FInterpCurvePointVector Point2);
  [Operator="!="] boolean not_equal(
      [Const, Ref] FInterpCurvePointVector Point1,
      [Const, Ref] FInterpCurvePointVector Point2);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointVector & Point )
};

interface FInterpCurvePointQuat {
  attribute float InVal;
  [Value] attribute FQuat OutVal;
  [Value] attribute FQuat ArriveTangent; 
  [Value] attribute FQuat LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointQuat();
  void FInterpCurvePointQuat([Const] float In, [Const, Ref] FQuat Out);
  void FInterpCurvePointQuat([Const] float In, [Const, Ref] FQuat Out,
                             [Const, Ref] FQuat InArriveTangent,
                             [Const, Ref] FQuat InLeaveTangent,
                             [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal([Const, Ref] FInterpCurvePointQuat Point1,
                                [Const, Ref] FInterpCurvePointQuat Point2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurvePointQuat Point1,
                                    [Const, Ref] FInterpCurvePointQuat Point2);
  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointQuat & Point )
};

interface FInterpCurvePointTwoVectors {
  attribute float InVal;
  [Value] attribute FTwoVectors OutVal;
  [Value] attribute FTwoVectors ArriveTangent; 
  [Value] attribute FTwoVectors LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointTwoVectors();
  void FInterpCurvePointTwoVectors([Const] float In,
                                    [Const, Ref] FTwoVectors Out);
  void FInterpCurvePointTwoVectors([Const] float In,
                                   [Const, Ref] FTwoVectors Out,
                                   [Const, Ref] FTwoVectors InArriveTangent,
                                   [Const, Ref] FTwoVectors InLeaveTangent,
                                   [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal(
      [Const, Ref] FInterpCurvePointTwoVectors Point1,
      [Const, Ref] FInterpCurvePointTwoVectors Point2);
  [Operator="!="] boolean not_equal(
      [Const, Ref] FInterpCurvePointTwoVectors Point1,
      [Const, Ref] FInterpCurvePointTwoVectors Point2);
  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointTwoVectors & Point )
};

interface FInterpCurvePointLinearColor {
  attribute float InVal;
  [Value] attribute FLinearColor OutVal;
  [Value] attribute FLinearColor ArriveTangent; 
  [Value] attribute FLinearColor LeaveTangent; 
  [Value] attribute TEnumAsByteEInterpCurveMode InterpMode; 
  void FInterpCurvePointLinearColor();
  void FInterpCurvePointLinearColor([Const] float In,
                                    [Const, Ref] FLinearColor Out);
  void FInterpCurvePointLinearColor([Const] float In,
                                    [Const, Ref] FLinearColor Out,
                                    [Const, Ref] FLinearColor InArriveTangent,
                                    [Const, Ref] FLinearColor InLeaveTangent,
                                    [Const] EInterpCurveMode InInterpMode);
  boolean IsCurveKey();
  [Operator="=="] boolean equal(
       [Const, Ref] FInterpCurvePointLinearColor Point1,
       [Const, Ref] FInterpCurvePointLinearColor Point2);
  [Operator="!="] boolean not_equal(
       [Const, Ref] FInterpCurvePointLinearColor Point1,
       [Const, Ref] FInterpCurvePointLinearColor Point2);
  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurvePointLinearColor & Point )
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteEInterpCurveMode {
};

interface TArrayFInterpCurvePointFloat {
};

interface TArrayFInterpCurvePointVector2D {
};

interface TArrayFInterpCurvePointVector {
};

interface TArrayFInterpCurvePointQuat {
};

interface TArrayFInterpCurvePointTwoVectors {
};

interface TArrayFInterpCurvePointLinearColor {
};
interface FColor {
  void FColor();
  void FColor(octet InR, octet InG, octet InB, octet InA);
  void FColor(long InColor);
  boolean Serialize([Ref] FArchive Ar);
  [Value] FLinearColor FromRGBE();
  [Value] FColor WithAlpha(octet Alpha);
  [Value] FLinearColor ReinterpretAsLinear();
  [Value] FString ToHex();
  [Value] FString ToString();
  boolean InitFromString([Const, Ref] FString InSourceString);
  long ToPackedARGB();
  long ToPackedABGR();
  long ToPackedRGBA();
  long ToPackedBGRA();
  long DWColor();

  [Operator="+="] void add([Const, Ref] FColor C);

  [Value] static FColor FromHex([Const, Ref] FString HexString);
  [Value] static FColor MakeRandomColor();
  [Value] static FColor MakeRedToGreenColorFromScalar(float Scalar);
  [Value] static FColor MakeFromColorTemperature(float Temp);
  [Const, Value] static readonly attribute FColor White;
  [Const, Value] static readonly attribute FColor Black;
  [Const, Value] static readonly attribute FColor Transparent;
  [Const, Value] static readonly attribute FColor Red;
  [Const, Value] static readonly attribute FColor Green;
  [Const, Value] static readonly attribute FColor Blue;
  [Const, Value] static readonly attribute FColor Yellow;
  [Const, Value] static readonly attribute FColor Cyan;
  [Const, Value] static readonly attribute FColor Magenta;
  [Const, Value] static readonly attribute FColor Orange;
  [Const, Value] static readonly attribute FColor Purple;
  [Const, Value] static readonly attribute FColor Turquoise;
  [Const, Value] static readonly attribute FColor Silver;
  [Const, Value] static readonly attribute FColor Emerald;

  // TODO: another problem with lack of overloading...
  // [Ref, Const] long DWColor();
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FLinearColor {
  void FLinearColor();
};
interface FTwoVectors {
  [Value] attribute FVector v1;
  [Value] attribute FVector v2;

  void FTwoVectors();
  void FTwoVectors([Ref] FVector In1, [Ref] FVector In2);

  [Operator="=="] boolean equal([Const, Ref] FTwoVectors V);
  [Operator="!="] boolean not_equal([Const, Ref] FTwoVectors V);
  boolean Equals([Const, Ref] FTwoVectors V, float Tolerance);
  [Operator="+=", Value] FTwoVectors add([Const, Ref] FTwoVectors V);
  [Operator="-=", Value] FTwoVectors subtract([Const, Ref] FTwoVectors V);
  [Operator="*=", Value] FTwoVectors multiply_scalar(float Scale);
  [Operator="/=", Value] FTwoVectors divide_scalar(float V);
  [Operator="*=", Value] FTwoVectors multiply([Const, Ref] FTwoVectors V);
  [Operator="/=", Value] FTwoVectors divide([Const, Ref] FTwoVectors V);
  [Operator="[]"] float at(long i);

  float GetMax();
  float GetMin();
  [Value] FString ToString();
  boolean Serialize([Ref] FArchive Ar);

  // TODO: not supported operators
  //FORCEINLINE FTwoVectors operator+( const FTwoVectors& V ) const;
  //FORCEINLINE FTwoVectors operator-( const FTwoVectors& V ) const;
  //FORCEINLINE FTwoVectors operator*( float Scale ) const;
  //FTwoVectors operator/( float Scale ) const;
  //FORCEINLINE FTwoVectors operator*( const FTwoVectors& V ) const;
  //FORCEINLINE FTwoVectors operator/( const FTwoVectors& V ) const;
  //FORCEINLINE FTwoVectors operator-() const;
  //friend FArchive& operator<<( FArchive& Ar, FTwoVectors& TwoVectors )
};
interface FPlane {
  boolean Equals([Const, Ref] FPlane V, float Tolerance);
  attribute float W;

  void FPlane();
  void FPlane([Const, Ref] FPlane P);
  void FPlane(float InX, float InY, float InZ, float InW);
  void FPlane([Ref] FVector InNormal, float InW);
  void FPlane([Ref] FVector A, [Ref] FVector B, [Ref] FVector C);

  float PlaneDot([Const, Ref] FVector P);
  [Value] FPlane Flip();
  [Value] FPlane TransformBy([Const, Ref] FMatrix M);
  [Value] FPlane TransformByUsingAdjointT([Const, Ref] FMatrix M,
                                          float DetM,
                                          [Const, Ref] FMatrix TA);

  [Operator="=="] boolean equal([Const, Ref] FPlane V);
  [Operator="!="] boolean not_equal([Const, Ref] FPlane V);
  [Operator="+=", Value] FPlane add([Const, Ref] FPlane V);
  [Operator="-=", Value] FPlane subtract([Const, Ref] FPlane V);
  [Operator="*=", Value] FPlane multiply_scalar(float Scale);
  [Operator="*=", Value] FPlane multiply([Const, Ref] FPlane V);
  [Operator="/=", Value] FPlane divide(float V);

  boolean Serialize([Ref] FArchive Ar);
  boolean NetSerialize([Ref] FArchive Ar,
                       UPackageMap PackageMap,
                       boolean bOutSuccess);

  // TODO: connot override constructor
  //void FPlane(const FVector4& V);
  //void FPlane([Ref] FVector InBase, [Const, Ref] FVector InNormal);
  // TODO: not supported operators
  //FPlane operator+(const FPlane& V) const;
  //FPlane operator-(const FPlane& V) const;
  //FPlane operator/(float Scale) const;
  //FPlane operator*(float Scale) const;
  //FPlane operator*(const FPlane& V);
  //float operator|(const FPlane& V) const;
  //friend FArchive& operator<<(FArchive& Ar, FPlane &P)
};
FPlane implements FVector;
interface FIntPoint
{
  void FIntPoint();
  void FIntPoint(long InX, long InY);
  attribute long X;
  attribute long Y;
  [Operator="!="] boolean not_equal([Const, Ref] FIntPoint Other);
  [Operator="*=", Ref] FIntPoint multiply(long Scale);
  [Operator="/=", Ref] FIntPoint divide(long Divisor);
  [Operator="+=", Ref] FIntPoint add([Const, Ref] FIntPoint Other);
  [Operator="-=", Ref] FIntPoint subtract([Const, Ref] FIntPoint Other);
  [Operator="[]"] long atat(long Index);

  [Value] FIntPoint ComponentMin([Const, Ref] FIntPoint Other);
  [Value] FIntPoint ComponentMax([Const, Ref] FIntPoint Other);
  long GetMax();
  long GetMin();
  long Size();
  long SizeSquared();
  [Value] FString ToString();

  //TODO
  //static FIntPoint DivideAndRoundUp(FIntPoint lhs, int32 Divisor);
  //static FIntPoint DivideAndRoundUp(FIntPoint lhs, FIntPoint Divisor);
  //static FIntPoint DivideAndRoundDown(FIntPoint lhs, int32 Divisor);
  //static long Num();
  //boolean Serialize(FArchive& Ar);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FBox {
  void FBox();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FIntVector {
};
interface FQuat {
  void FQuat();
  void FQuat(float InX, float InY, float InZ, float InW);
  void FQuat([Const, Ref] FQuat Q);
  void FQuat([Ref] FVector Axis, float AngleRad);
  attribute float X;
  attribute float Y;
  attribute float Z;
  attribute float W;

  boolean Equals([Const, Ref] FQuat Q, float Tolerance);
  boolean IsIdentity(float Tolerance);

  [Operator="+=", Value] FQuat add([Const, Ref] FQuat Q);
  [Operator="-=", Value] FQuat subtract([Const, Ref] FQuat Q);
  [Operator="*=", Value] FQuat multiply([Const, Ref] FQuat Q);
  [Operator="*=", Value] FQuat multiply_scalar([Const] float Scale);
  [Operator="/=", Value] FQuat divide([Const] float Scale);
  [Operator="=="] boolean equal([Const, Ref] FQuat Q);
  [Operator="!="] boolean not_equal([Const, Ref] FQuat Q);

  [Value] static FQuat MakeFromEuler([Const, Ref] FVector Euler);
  [Value] FVector Euler();
  void Normalize(float Tolerance);
  [Value] FQuat GetNormalized(float Tolerance);
  boolean IsNormalized();
  float Size();
  float SizeSquared();
  void ToAxisAndAngle([Ref] FVector Axis, float Angle);
  void ToSwingTwist([Const, Ref] FVector InTwistAxis,
                    [Ref] FQuat OutSwing,
                    [Ref] FQuat OutTwist);

  [Value] FVector RotateVector([Ref] FVector V);
  [Value] FVector UnrotateVector([Ref] FVector V);
  [Value] FQuat Log();
  [Value] FQuat Exp();
  [Value] FQuat Inverse();
  void EnforceShortestArcWith([Const, Ref] FQuat OtherQuat);
  [Value] FVector GetAxisX();
  [Value] FVector GetAxisY();
  [Value] FVector GetAxisZ();
  [Value] FVector GetForwardVector();
  [Value] FVector GetRightVector();
  [Value] FVector GetUpVector();
  [Value] FVector Vector();
  [Value] FRotator Rotator();
  [Value] FVector GetRotationAxis();
  float AngularDistance([Const, Ref] FQuat Q);
  boolean NetSerialize([Ref] FArchive Ar,
                       UPackageMap PackageMap,
                       boolean bOutSuccess);
  boolean ContainsNaN();
  [Value] FString ToString();

  void DiagnosticCheckNaN();
  void DiagnosticCheckNaN([Const] DOMString Message);

  [Value] static FQuat FindBetween([Const, Ref] FVector Vector1,
                                   [Const, Ref] FVector Vector2);
  [Value] static FQuat FindBetweenNormals([Const, Ref] FVector Normal1,
                                          [Const, Ref] FVector Normal2);
  [Value] static FQuat FindBetweenVectors([Const, Ref] FVector Vector1,
                                          [Const, Ref] FVector Vector2);
  static float Error([Const, Ref] FQuat Q1, [Const, Ref] FQuat Q2);
  static float ErrorAutoNormalize([Const, Ref] FQuat A, [Const, Ref] FQuat B);

  [Value] static FQuat FastLerp([Const, Ref] FQuat A,
                                [Const, Ref] FQuat B,
                                [Const] float Alpha);
  [Value] static FQuat FastBilerp([Const, Ref] FQuat P00,
                                  [Const, Ref] FQuat P10,
                                  [Const, Ref] FQuat P01,
                                  [Const, Ref] FQuat P11,
                                  float FracX,
                                  float FracY);
  [Value] static FQuat Slerp_NotNormalized([Const, Ref] FQuat Quat1,
                                           [Const, Ref] FQuat Quat2,
                                           float Slerp);
  [Value] static FQuat Slerp([Const, Ref] FQuat Quat1,
                             [Const, Ref] FQuat Quat2,
                             float Slerp);
  [Value] static FQuat SlerpFullPath_NotNormalized([Const, Ref] FQuat quat1,
                                                   [Const, Ref] FQuat quat2,
                                                   float Alpha);
  [Value] static FQuat SlerpFullPath([Const, Ref] FQuat quat1,
                                     [Const, Ref] FQuat quat2,
                                     float Alpha);
  [Value] static FQuat Squad([Const, Ref] FQuat quat1,
                             [Const, Ref] FQuat tang1,
                             [Const, Ref] FQuat quat2,
                             [Const, Ref] FQuat tang2,
                             float Alpha);
  [Value] static FQuat SquadFullPath([Const, Ref] FQuat quat1,
                                     [Const, Ref] FQuat tang1,
                                     [Const, Ref] FQuat quat2,
                                     [Const, Ref] FQuat tang2,
                                     float Alpha);
  static void CalcTangents([Const, Ref] FQuat PrevP,
                           [Const, Ref] FQuat P,
                           [Const, Ref] FQuat NextP,
                           float Tension,
                           [Ref] FQuat OutTan);
  boolean Serialize([Ref] FArchive Ar);

  // TODO: constructor override
  //explicit FQuat(const FMatrix& M);
  //explicit FQuat(const FRotator& R);
  // TODO: not supported operators
  //FORCEINLINE FQuat& operator=(const FQuat& Other);
  //FORCEINLINE FQuat operator+(const FQuat& Q) const;
  //FORCEINLINE FQuat operator-(const FQuat& Q) const;
  //FORCEINLINE FQuat operator*(const FQuat& Q) const;
  //FVector operator*(const FVector& V) const;
  //FMatrix operator*(const FMatrix& M) const;
  //FORCEINLINE FQuat operator*(const float Scale) const;
  //FORCEINLINE FQuat operator/(const float Scale) const;
  //float operator|(const FQuat& Q) const;
  //friend FArchive& operator<<(FArchive& Ar, FQuat& F)
};

interface TArrayFQuat {
  void TArrayFQuat();
  VoidPtr GetData();
  long Num();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface ScalarRegister {
};
interface FBoxSphereBounds {
  [Value] attribute FVector Origin;
  [Value] attribute FVector BoxExtent;
  attribute float SphereRadius;

  void FBoxSphereBounds();
  void FBoxSphereBounds([Const, Ref] FVector InOrigin, [Const, Ref] FVector InBoxExtent, float InSphereRadius);
  void FBoxSphereBounds([Const] FVector Points, long NumPoints);
  float ComputeSquaredDistanceFromBoxToPoint([Const, Ref] FVector Point);
  [Value] FVector GetBoxExtrema(long Extrema);
  [Value] FBoxSphereBounds ExpandBy(float ExpandAmount);
  [Value] FBoxSphereBounds TransformBy([Const, Ref] FTransform M );
  [Value] FString ToString();
  void DiagnosticCheckNaN();
  boolean ContainsNaN();
  [Value] FBox GetBox();
  [Value] FSphere GetSphere();

  static boolean SpheresIntersect([Const, Ref] FBoxSphereBounds A, [Const, Ref] FBoxSphereBounds B, float Tolerance);
  static boolean BoxesIntersect([Const, Ref] FBoxSphereBounds A, [Const, Ref] FBoxSphereBounds B);

  // TODO: some constructors missing due to lack of function overloading (which should be chosen?)
  // FBoxSphereBounds TransformBy([Const, Ref] FMatrix M );
  // void FBoxSphereBounds([Const, Ref] FBox Box, [Const, Ref] FSphere Sphere);
  // void FBoxSphereBounds([Const, Ref] FBox Box )
  // void FBoxSphereBounds([Const, Ref] FSphere Sphere )
};
interface FInterpCurveFloat {
  [Value] attribute TArrayFInterpCurvePointFloat Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveFloat();
  long AddPoint([Const] float InVal, [Const] float OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  float Eval([Const] float InVal, [Const] float Default);
  float EvalDerivative([Const] float InVal, [Const] float Default);
  float EvalSecondDerivative([Const] float InVal, [Const] float Default);

  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds(float OutMin, float OutMax, [Const] float Default);
  [Operator="=="] boolean equal([Const, Ref] FInterpCurveFloat Curve1,
                                [Const, Ref] FInterpCurveFloat Curve2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurveFloat Curve1,
                                    [Const, Ref] FInterpCurveFloat Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};

interface FInterpCurveVector2D {
  [Value] attribute TArrayFInterpCurvePointVector2D Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveVector2D ();
  long AddPoint([Const] float InVal, [Const, Ref] FVector2D OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  [Value] FVector2D Eval([Const] float InVal, [Const, Ref] FVector2D Default);
  [Value] FVector2D EvalDerivative([Const] float InVal,
                                   [Const, Ref] FVector2D Default);
  [Value] FVector2D EvalSecondDerivative([Const] float InVal,
                                         [Const, Ref] FVector2D Default);

  float InaccurateFindNearest([Const, Ref] FVector2D PointInSpace,
                              float OutDistanceSq);
  float InaccurateFindNearestOnSegment([Const, Ref] FVector2D PointInSpace,
                                       long PtIdx, float OutSquaredDistance);
  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds([Ref] FVector2D OutMin,
                  [Ref] FVector2D OutMax,
                  [Const, Ref] FVector2D Default);

  [Operator="=="] boolean equal([Const, Ref] FInterpCurveVector2D Curve1,
                                [Const, Ref] FInterpCurveVector2D Curve2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurveVector2D Curve1,
                                    [Const, Ref] FInterpCurveVector2D Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};

interface FInterpCurveVector {
  [Value] attribute TArrayFInterpCurvePointVector Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveVector ();
  long AddPoint([Const] float InVal, [Const, Ref] FVector OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  [Value] FVector Eval([Const] float InVal, [Const, Ref] FVector Default);
  [Value] FVector EvalDerivative([Const] float InVal,
                                 [Const, Ref] FVector Default);
  [Value] FVector EvalSecondDerivative([Const] float InVal,
                                       [Const, Ref] FVector Default);

  float InaccurateFindNearest([Const, Ref] FVector PointInSpace,
                              float OutDistanceSq);
  float InaccurateFindNearestOnSegment([Const, Ref] FVector PointInSpace,
                                       long PtIdx,
                                       float OutSquaredDistance);
  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds([Ref] FVector OutMin,
                  [Ref] FVector OutMax,
                  [Const, Ref] FVector Default);
  [Operator="=="] boolean equal([Const, Ref] FInterpCurveVector Curve1,
                                [Const, Ref] FInterpCurveVector Curve2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurveVector Curve1,
                                    [Const, Ref] FInterpCurveVector Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};

interface FInterpCurveQuat {
  [Value] attribute TArrayFInterpCurvePointQuat Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveQuat();
  long AddPoint([Const] float InVal, [Const, Ref] FQuat OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  [Value] FQuat Eval([Const] float InVal, [Const, Ref] FQuat Default);

  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds([Ref] FQuat OutMin,
                  [Ref] FQuat OutMax,
                  [Const, Ref] FQuat Default);
  [Operator="=="] boolean equal([Const, Ref] FInterpCurveQuat Curve1,
                                [Const, Ref] FInterpCurveQuat Curve2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurveQuat Curve1,
                                    [Const, Ref] FInterpCurveQuat Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};

interface FInterpCurveTwoVectors {
  [Value] attribute TArrayFInterpCurvePointTwoVectors Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveTwoVectors ();
  long AddPoint([Const] float InVal, [Const, Ref] FTwoVectors OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  [Value] FTwoVectors Eval([Const] float InVal,
                           [Const, Ref] FTwoVectors Default);
  [Value] FTwoVectors EvalDerivative([Const] float InVal,
                                     [Const, Ref] FTwoVectors Default);
  [Value] FTwoVectors EvalSecondDerivative([Const] float InVal,
                                           [Const, Ref] FTwoVectors Default);

  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds([Ref] FTwoVectors OutMin,
                  [Ref] FTwoVectors OutMax,
                  [Const, Ref] FTwoVectors Default);
  [Operator="=="] boolean equal([Const, Ref] FInterpCurveTwoVectors Curve1,
                                [Const, Ref] FInterpCurveTwoVectors Curve2);
  [Operator="!="] boolean not_equal([Const, Ref] FInterpCurveTwoVectors Curve1,
                                    [Const, Ref] FInterpCurveTwoVectors Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};

interface FInterpCurveLinearColor {
  [Value] attribute TArrayFInterpCurvePointLinearColor Points;
  attribute boolean bIsLooped;
  attribute float LoopKeyOffset;
  void FInterpCurveLinearColor ();
  long AddPoint([Const] float InVal, [Const, Ref] FLinearColor OutVal);
  long MovePoint(long PointIndex, float NewInVal);
  void Reset();
  void SetLoopKey(float InLoopKey);
  void ClearLoopKey();

  [Value] FLinearColor Eval([Const] float InVal,
                            [Const, Ref] FLinearColor Default);
  [Value] FLinearColor EvalDerivative([Const] float InVal,
                                      [Const, Ref] FLinearColor Default);
  [Value] FLinearColor EvalSecondDerivative([Const] float InVal,
                                            [Const, Ref] FLinearColor Default);

  void AutoSetTangents(float Tension, boolean bStationaryEndpoints);
  void CalcBounds([Ref] FLinearColor OutMin,
                  [Ref] FLinearColor OutMax,
                  [Const, Ref] FLinearColor Default);
  [Operator="=="] boolean equal([Const, Ref] FInterpCurveLinearColor Curve1,
                                [Const, Ref] FInterpCurveLinearColor Curve2);
  [Operator="!="] boolean not_equal(
      [Const, Ref] FInterpCurveLinearColor Curve1,
      [Const, Ref] FInterpCurveLinearColor Curve2);
  long GetPointIndexForInputValue([Const] float InValue);

  // TODO: not supported operator
  //friend FArchive& operator<<( FArchive& Ar, FInterpCurve& Curve )
};
interface FTransform {
  void FTransform();
  void FTransform([Const, Ref] FTransform InTransform);
  void FTransform([Const, Ref] FQuat InRotation,
                  [Const, Ref] FVector InTranslation,
                  [Const, Ref] FVector InScale3D);
  void FTransform([Const, Ref] FVector InX,
                  [Const, Ref] FVector InY,
                  [Const, Ref] FVector InZ,
                  [Const, Ref] FVector InTranslation);

  void DiagnosticCheckNaN_Translate();
  void DiagnosticCheckNaN_Rotate();
  void DiagnosticCheckNaN_Scale3D();
  void DiagnosticCheckNaN_All();
  void DiagnosticCheck_IsValid();

  void DebugPrint();
  boolean DebugEqualMatrix([Const, Ref] FMatrix Matrix);
  [Value] FString ToHumanReadableString();
  [Value] FString ToString();
  boolean InitFromString([Const, Ref] FString InSourceString);

  [Value] FMatrix ToMatrixWithScale();
  [Value] FMatrix ToInverseMatrixWithScale();
  [Value] FTransform Inverse();
  [Value] FMatrix ToMatrixNoScale();
  void Blend([Const, Ref] FTransform Atom1,
             [Const, Ref] FTransform Atom2,
             float Alpha);

  [Operator="+=", Ref] FTransform add([Const, Ref] FTransform Atom);
  [Operator="*=", Ref] FTransform multiply_scalar(
      [Const, Ref] ScalarRegister Mult);
  [Operator="*="] void multiply([Const, Ref] FTransform Other);
  [Operator="*="] void multiply_quat([Const, Ref] FQuat Other);

  void ScaleTranslation([Const, Ref] FVector InScale3D);
  void RemoveScaling(float Tolerance);
  float GetMaximumAxisScale();
  float GetMinimumAxisScale();
  [Value] FTransform GetRelativeTransform([Const, Ref] FTransform Other);
  [Value] FTransform GetRelativeTransformReverse([Const, Ref] FTransform Other);
  void SetToRelativeTransform([Const, Ref] FTransform ParentTransform);
  [Value] FVector4 TransformFVector4([Const, Ref] FVector4 V);
  [Value] FVector4 TransformFVector4NoScale([Const, Ref] FVector4 V);
  [Value] FVector TransformPosition([Const, Ref] FVector V);
  [Value] FVector TransformPositionNoScale([Const, Ref] FVector V);
  [Value] FVector InverseTransformPosition([Const, Ref] FVector V);
  [Value] FVector InverseTransformPositionNoScale([Const, Ref] FVector V);
  [Value] FVector TransformVector([Const, Ref] FVector V);
  [Value] FVector TransformVectorNoScale([Const, Ref] FVector V);
  [Value] FVector InverseTransformVector([Const, Ref] FVector V);
  [Value] FVector InverseTransformVectorNoScale([Const, Ref] FVector V);
  [Value] FTransform GetScaled([Ref] FVector Scale);
  [Value] FVector GetScaledAxis(EAxis_Type InAxis);
  [Value] FVector GetUnitAxis(EAxis_Type InAxis);
  void Mirror(EAxis_Type MirrorAxis, EAxis_Type FlipAxis);
  [Value] static FVector GetSafeScaleReciprocal([Const, Ref] FVector InScale,
                                                float Tolerance);
  [Value] FVector GetLocation();
  [Value] FRotator Rotator();
  float GetDeterminant();
  void SetLocation([Const, Ref] FVector Origin);
  boolean ContainsNaN();
  boolean IsValid();
  static boolean AreRotationsEqual([Const, Ref] FTransform A,
                                   [Const, Ref] FTransform B,
                                   float Tolerance);
  static boolean AreTranslationsEqual([Const, Ref] FTransform A,
                                      [Const, Ref] FTransform B,
                                      float Tolerance);
  static boolean AreScale3DsEqual([Const, Ref] FTransform A,
                                  [Const, Ref] FTransform B,
                                  float Tolerance);
  boolean RotationEquals([Const, Ref] FTransform Other, float Tolerance);
  boolean TranslationEquals([Const, Ref] FTransform Other, float Tolerance);
  boolean Scale3DEquals([Const, Ref] FTransform Other, float Tolerance);
  boolean Equals([Const, Ref] FTransform Other, float Tolerance);
  boolean EqualsNoScale([Const, Ref] FTransform Other, float Tolerance);
  static void Multiply(FTransform OutTransform,
                       [Const] FTransform A,
                       [Const] FTransform B);

  void SetComponents([Const, Ref] FQuat InRotation,
                     [Const, Ref] FVector InTranslation,
                     [Const, Ref] FVector InScale3D);
  void SetIdentity();
  void MultiplyScale3D([Const, Ref] FVector Scale3DMultiplier);
  void SetTranslation([Const, Ref] FVector NewTranslation);
  void CopyTranslation([Const, Ref] FTransform Other);
  void ConcatenateRotation([Const, Ref] FQuat DeltaRotation);
  void AddToTranslation([Const, Ref] FVector DeltaTranslation);
  [Value] static FVector AddTranslations([Const, Ref] FTransform A,
                                         [Const, Ref] FTransform B);
  [Value] static FVector SubtractTranslations([Const, Ref] FTransform A,
                                              [Const, Ref] FTransform B);
  void SetRotation([Const, Ref] FQuat NewRotation);
  void CopyRotation([Const, Ref] FTransform Other);
  void SetScale3D([Const, Ref] FVector NewScale3D);
  void CopyScale3D([Const, Ref] FTransform Other);
  void SetTranslationAndScale3D([Const, Ref] FVector NewTranslation,
                                [Const, Ref] FVector NewScale3D);
  void Accumulate([Const, Ref] FTransform SourceAtom);
  void Accumulate([Const, Ref] FTransform Atom,
                  [Const, Ref] ScalarRegister BlendWeight);
  void AccumulateWithShortestRotation([Const, Ref] FTransform DeltaAtom,
                                      [Const, Ref] ScalarRegister BlendWeight);
  void AccumulateWithAdditiveScale([Const, Ref] FTransform Atom,
                                   [Const, Ref] ScalarRegister BlendWeight);
  void LerpTranslationScale3D([Const, Ref] FTransform SourceAtom1,
                              [Const, Ref] FTransform SourceAtom2,
                              [Const, Ref] ScalarRegister Alpha);
  void NormalizeRotation();
  boolean IsRotationNormalized();
  static void BlendFromIdentityAndAccumulate(
      [Ref] FTransform FinalAtom,
      [Ref] FTransform SourceAtom,
      [Const, Ref] ScalarRegister BlendWeight);
  [Value] FQuat GetRotation();
  [Value] FVector GetTranslation();
  [Value] FVector GetScale3D();
  void CopyRotationPart([Const, Ref] FTransform SrcBA);
  void CopyTranslationAndScale3D([Const, Ref] FTransform SrcBA);
  void SetFromMatrix([Const, Ref] FMatrix InMatrix);

  // TODO: constructor override is not supported
  //FORCEINLINE explicit FTransform(const FQuat& InRotation)
  //FORCEINLINE explicit FTransform(const FRotator& InRotation)
  //void FTransform([Const, Ref] FVector InTranslation);
  //void explicit FTransform(const FMatrix& InMatrix)
  //void FTransform([Const, Ref] VectorRegister InRotation, [Const, Ref] VectorRegister InTranslation, [Const, Ref] VectorRegister InScale3D);
  //FORCEINLINE FTransform(const FRotator& InRotation, const FVector& InTranslation, const FVector& InScale3D = FVector(1.f))
  // TODO: not supported operators
  //FORCEINLINE FTransform& operator=(const FTransform& Other)
  //FORCEINLINE FTransform operator+(const FTransform& Atom) const
  //FORCEINLINE FTransform operator*(const ScalarRegister& Mult) const
  //FORCEINLINE FTransform		operator*(const FTransform& Other) const;
  //FORCEINLINE FTransform		operator*(const FQuat& Other) const;
  //inline friend FArchive& operator<<([Ref] FArchive Ar, [Ref] FTransform M);
  // TODO: function override is not supported
  //void ScaleTranslation([Const] float Scale);
  //[Value] FTransform GetScaled(float Scale);

};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TArrayFInt32Range {
};
interface FRotator {
  void FRotator();
  void FRotator([Const, Ref] FQuat Quat);
  void FRotator(float InPitch, float InYaw, float InRoll);
  attribute float Pitch;
  attribute float Roll;
  attribute float Yaw;

  void DiagnosticCheckNaN();
  void DiagnosticCheckNaN([Const] DOMString Message);

  [Operator="*=", Value] FRotator multiply(float Scale);
  [Operator="+=", Value] FRotator add([Const, Ref] FRotator R);
  [Operator="-=", Value] FRotator subtract([Const, Ref] FRotator R);
  [Operator="=="] boolean equal([Const, Ref] FRotator R);
  [Operator="!="] boolean not_equal([Const, Ref] FRotator V);

  boolean IsNearlyZero(float Tolerance);
  boolean IsZero();
  boolean Equals([Const, Ref] FRotator R, float Tolerance);
  [Value] FRotator Add(float DeltaPitch, float DeltaYaw, float DeltaRoll);
  [Value] FRotator GetInverse();
  [Value] FRotator GridSnap([Const, Ref] FRotator RotGrid);
  [Value] FVector Vector();
  [Value] FQuat Quaternion();
  [Value] FVector Euler();
  [Value] FVector RotateVector([Const, Ref] FVector V);
  [Value] FVector UnrotateVector([Const, Ref] FVector V);
  [Value] FRotator Clamp();
  [Value] FRotator GetNormalized();
  [Value] FString ToString();
  [Value] FString ToCompactString();
  boolean InitFromString([Const, Ref] FString InSourceString);
  boolean ContainsNaN();
  void SerializeCompressed([Ref] FArchive Ar);
  void SerializeCompressedShort([Ref] FArchive Ar);
  boolean NetSerialize([Ref] FArchive Ar,
                       UPackageMap PackageMap,
                       boolean bOutSuccess);

  static float ClampAxis(float Angle);
  static float NormalizeAxis(float Angle);
  static long CompressAxisToByte(float Angle);
  static float DecompressAxisFromByte(unsigned long Angle);
  static long CompressAxisToShort(float Angle);
  static float DecompressAxisFromShort(unsigned long Angle);
  [Value] static FRotator MakeFromEuler([Const, Ref] FVector Euler);

  boolean Serialize([Ref] FArchive Ar);

  // TODO: cannot override constructor
  //void FRotator(float InF);
  // TODO: not supported operators
  //FRotator operator+( const FRotator& R ) const;
  //FRotator operator-( const FRotator& R ) const;
  //FRotator operator*( float Scale ) const;
  //friend FArchive& operator<<( FArchive& Ar, FRotator& R )
};
enum EAxis_Type {
  "EAxis::None",
  "EAxis::X",
  "EAxis::Y",
  "EAxis::Z"
};

enum EAxisList_Type {
  "EAxisList::None",
  "EAxisList::X",
  "EAxisList::Y",
  "EAxisList::Z",
  "EAxisList::Screen",
  "EAxisList::XY",
  "EAxisList::XZ",
  "EAxisList::YZ",
  "EAxisList::XYZ",
  "EAxisList::All",
  "EAxisList::ZRotation",
  "EAxisList::Rotate2D"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface TEnumAsByteEAxisType {
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EWindowZone_Type {
  "EWindowZone::NotInWindow",
  "EWindowZone::TopLeftBorder",
  "EWindowZone::TopBorder",
  "EWindowZone::TopRightBorder",
  "EWindowZone::LeftBorder",
  "EWindowZone::ClientArea",
  "EWindowZone::RightBorder",
  "EWindowZone::BottomLeftBorder",
  "EWindowZone::BottomBorder",
  "EWindowZone::BottomRightBorder",
  "EWindowZone::TitleBar",
  "EWindowZone::MinimizeButton",
  "EWindowZone::MaximizeButton",
  "EWindowZone::CloseButton",
  "EWindowZone::SysMenu",
  "EWindowZone::Unspecified"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FWindowSizeLimits {
  void FWindowSizeLimits();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UPTRINT {
};

interface PTRINT {
};

interface SIZE_T {
};

interface SSIZE_T {
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EWindowMode_Type {
  "EWindowMode::Fullscreen",
  "EWindowMode::WindowedFullscreen",
  "EWindowMode::Windowed",
  "EWindowMode::NumWindowModes"
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum EWindowType {
  "EWindowType::Normal",
  "EWindowType::Menu",
  "EWindowType::ToolTip",
  "EWindowType::Notification",
  "EWindowType::CursorDecorator",
  "EWindowType::GameWindow"
};

enum EWindowTransparency {
  "EWindowTransparency::None",
  "EWindowTransparency::PerWindow"
};
interface TArrayFName {
  void TArrayFName();
  VoidPtr GetData();
  long Num();
};

interface TArrayFNamePtr {
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FName {
  void FName();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FThreadSafeCounter {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FThreadSafeBool {
};
enum EBulkDataLockFlags {
  "EBulkDataLockFlags::LOCK_READ_ONLY",
  "EBulkDataLockFlags::LOCK_READ_WRITE"
};

interface FUntypedBulkData {
  static void DumpBulkDataUsage([Ref] FOutputDevice Log);
  long GetElementCount();
  long GetElementSize();
  long GetBulkDataSize();
  long GetBulkDataSizeOnDisk();
  long GetBulkDataOffsetInFile();
  boolean IsStoredCompressedOnDisk();
  boolean CanLoadFromDisk();
  ECompressionFlags GetDecompressionFlags();
  boolean IsBulkDataLoaded();
  boolean IsAsyncLoadingComplete();
  boolean IsAvailableForUse();
  void SetBulkDataFlags(long BulkDataFlagsToSet);
  long GetBulkDataFlags();
  void SetBulkDataAlignment(long BulkDataAlignmentToSet);
  long GetBulkDataAlignment();
  void ClearBulkDataFlags(long BulkDataFlagsToClear);
  [Const, Value] FString GetFilename();

  void GetCopy(VoidPtr[] Dest, boolean bDiscardInternalCopy);
  VoidPtr Lock(long LockFlags);
  [Const] VoidPtr LockReadOnly();
  VoidPtr Realloc(long InElementCount);
  void Unlock();
  boolean IsLocked();
  void RemoveBulkData();
  void ForceBulkDataResident();
  void StoreCompressedOnDisk(ECompressionFlags CompressionFlags);
  //void Serialize( FArchive& Ar, UObject* Owner, int32 Idx=INDEX_NONE );
  //void SerializeBulkData( FArchive& Ar, void* Data );
};

interface FByteBulkData {
  void FByteBulkData();
  long GetElementSize();
};
FByteBulkData implements FUntypedBulkData;

interface FWordBulkData {
  void FWordBulkData();
  long GetElementSize();
};
FWordBulkData implements FUntypedBulkData;

interface FIntBulkData {
  void FIntBulkData();
  long GetElementSize();
};
FIntBulkData implements FUntypedBulkData;

interface FFloatBulkData {
  void FFloatBulkData();
  long GetElementSize();
};
FFloatBulkData implements FUntypedBulkData;

interface FFormatContainer {
  boolean Contains([Ref] FName Format);
  [Ref] FByteBulkData GetFormat([Ref] FName Format);
  void FlushData();
  void Serialize([Ref] FArchive Ar, UObject Owner, [Const] TArrayFName FormatsToSave, boolean bSingleUse, long InAlignment);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UPackageMap {
  void UPackageMap();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[NoDelete]
interface IRepChangedPropertyTracker {
  void SetCustomIsActiveOverride([Const] short RepIndex, [Const] boolean bIsActive);
  void SetExternalData([Const] octet[] Src, [Const] long NumBits);
  boolean IsReplay();

  // TODO: "allocating an object of abstract class type"
  // void IRepChangedPropertyTracker();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FGCObject {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UObject {
  void UObject();
  [Value] FString GetName();
};

interface TArrayUObjectFAssetRegistryTag {
  void TArrayUObjectFAssetRegistryTag ();
  VoidPtr GetData();
  long Num();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UProperty {
  void UProperty();
};
interface TObjectIteratorUObject {
  void TObjectIteratorUObject();
  boolean Next();
  UObject Current();
};

interface TObjectIteratorAActor {
  void TObjectIteratorAActor();
  boolean Next();
  AActor Current();
};

interface TObjectIteratorUWorld {
  void TObjectIteratorUWorld();
  boolean Next();
  UWorld Current();
};
enum EDuplicateMode_Type {
  "EDuplicateMode::Normal",
  "EDuplicateMode::World",
  "EDuplicateMode::PIE"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FObjectInitializer {
  void FObjectInitializer();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UScriptStruct {
};
enum EObjectFlags {
  "RF_NoFlags",
  "RF_Public",
  "RF_Standalone",
  "RF_MarkAsNative",
  "RF_Transactional",
  "RF_ClassDefaultObject",
  "RF_ArchetypeObject",
  "RF_Transient",
  "RF_MarkAsRootSet",
  "RF_TagGarbageTemp",
  "RF_NeedLoad",
  "RF_KeepForCooker",
  "RF_NeedPostLoad",
  "RF_NeedPostLoadSubobjects",
  "RF_BeginDestroyed",
  "RF_FinishDestroyed",
  "RF_BeingRegenerated",
  "RF_DefaultSubObject",
  "RF_WasLoaded",
  "RF_TextExportTransient",
  "RF_LoadCompleted",
  "RF_InheritableComponentTemplate",
  "RF_DuplicateTransient",
  "RF_StrongRefOnFrame",
  "RF_NonPIEDuplicateTransient",
  "RF_Dynamic"
};
interface FIKChain {
  [Value] attribute TArrayFIKChainLink Links;
  attribute float MinRotationAngleRadians;
  void FIKChain();
  void InitializeFromLegData([Const, Ref] FAnimLegIKData InLegData, USkeletalMeshComponent InSkelMeshComp);
  void ReachTarget([Const, Ref] FVector InTargetLocation, float InReachPrecision, long InMaxIterations);
  float GetMaximumReach();
};

interface FAnimLegIKData { };
interface TArrayFIKChainLink { };
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum ETextFlowDirection {
  "ETextFlowDirection::Auto",
  "ETextFlowDirection::LeftToRight",
  "ETextFlowDirection::RightToLeft"
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FUpdateTextureRegion2D {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FRHICommandList {
  void FRHICommandList();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FTextureRHIRef {
};

interface FSamplerStateRHIRef {
};
enum ERHIFeatureLevel_Type {
 "ERHIFeatureLevel::ES2",
 "ERHIFeatureLevel::ES3_1",
 "ERHIFeatureLevel::SM4",
 "ERHIFeatureLevel::SM5",
 "ERHIFeatureLevel::Num"
};
enum EImageFormat_Type {
  "EImageFormat_Type::Invalid",
  "EImageFormat_Type::PNG",
  "EImageFormat_Type::JPEG",
  "EImageFormat_Type::GrayscaleJPEG",
  "EImageFormat_Type::BMP",
  "EImageFormat_Type::ICO",
  "EImageFormat_Type::EXR",
  "EImageFormat_Type::ICNS"
};

enum ERGBFormat_Type {
  "ERGBFormat_Type::Invalid",
  "ERGBFormat_Type::RGBA",
  "ERGBFormat_Type::BGRA",
  "ERGBFormat_Type::Gray"
};

interface IImageWrapper {
  boolean SetCompressed([Const] VoidPtr InCompressedData, long InCompressedSize);
  boolean SetRaw([Const] VoidPtr InRawData, long InRawSize, [Const] long InWidth, [Const] long InHeight, [Const] ERGBFormat_Type InFormat, [Const] long InBitDepth);
  [Const, Value] TArrayuint8 GetCompressed(long Quality);
  boolean GetRaw([Const] ERGBFormat_Type InFormat, long InBitDepth, [Ref, Const] TArrayuint8 OutRawData);
  long GetWidth();
  long GetHeight();
  long GetBitDepth();
  ERGBFormat_Type GetFormat();
};

interface IImageWrapperPtr {
  IImageWrapper Get();
  boolean IsValid();
};
interface IImageWrapperModule {
  [Value] IImageWrapperPtr CreateImageWrapper([Const] EImageFormat_Type InFormat);
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

interface TEnumAsByteEButtonClickMethodType {
};

interface TEnumAsByteEButtonTouchMethodType {
};

interface FOnButtonClickedEvent {
};

interface FOnButtonPressedEvent {
};

interface FOnButtonReleasedEvent {
};

interface FOnButtonHoverEvent {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface UButton {
  [Value] attribute FButtonStyle WidgetStyle;
  [Value] attribute FLinearColor ColorAndOpacity;
  [Value] attribute FLinearColor BackgroundColor;
  [Value] attribute TEnumAsByteEButtonClickMethodType ClickMethod;
  [Value] attribute TEnumAsByteEButtonTouchMethodType TouchMethod;
  [Value] attribute FOnButtonClickedEvent OnClicked;
  [Value] attribute FOnButtonPressedEvent OnPressed;
  [Value] attribute FOnButtonReleasedEvent OnReleased;
  [Value] attribute FOnButtonHoverEvent OnHovered;
  [Value] attribute FOnButtonHoverEvent OnUnhovered;
  attribute boolean IsFocusable;

  void SetStyle([Ref] FButtonStyle InStyle);
  void SetColorAndOpacity([Ref] FLinearColor InColorAndOpacity);
  void SetBackgroundColor([Ref] FLinearColor InBackgroundColor);
  boolean IsPressed();
  void SynchronizeProperties();
  void ReleaseSlateResources(boolean bReleaseChildren);
  void PostLoad();
};

UButton implements UContentWidget;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UWidget {
};
interface UImage {
  attribute USlateBrushAsset Image_DEPRECATED;
  [Value] attribute FSlateBrush Brush;
  [Value] attribute FGetSlateBrush BrushDelegate;
  [Value] attribute FLinearColor ColorAndOpacity;
  [Value] attribute FGetLinearColor ColorAndOpacityDelegate;
  [Value] attribute FOnPointerEvent OnMouseButtonDownEvent;
  void SetColorAndOpacity([Ref] FLinearColor InColorAndOpacity);
  void SetOpacity(float InOpacity);
  void SetBrush([Const, Ref] FSlateBrush InBrush);
  void SetBrushFromAsset(USlateBrushAsset Asset);
  void SetBrushFromTexture(UTexture2D Texture, optional boolean bMatchSize = false);
  void SetBrushFromMaterial(UMaterialInterface Material);
  UMaterialInstanceDynamic GetDynamicMaterial();
  void SynchronizeProperties();
  void ReleaseSlateResources(boolean bReleaseChildren);
  void PostLoad();
};

UImage implements UWidget;

/* TODO */
interface USlateBrushAsset { };
interface FSlateBrush { };
[Prefix="UWidget::"]
interface FGetSlateBrush { };
[Prefix="UWidget::"]
interface FOnPointerEvent { };
interface UMaterialInstanceDynamic { };
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="UWidget::"]
interface FGetText {
};

[Prefix="UWidget::"]
interface FGetLinearColor {
};

[Prefix="UWidget::"]
interface FGetSlateColor {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum ETextJustify_Type {
  "ETextJustify::Left",
  "ETextJustify::Center",
  "ETextJustify::Right"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface UTextBlock {
  [Value] attribute FText Text;
  [Value] attribute FGetText TextDelegate;
  [Value] attribute FSlateColor ColorAndOpacity;
  [Value] attribute FSlateFontInfo Font;
  [Value] attribute FVector2D ShadowOffset;
  [Value] attribute FLinearColor ShadowColorAndOpacity;
  [Value] attribute FGetLinearColor ShadowColorAndOpacityDelegate;
  [Value] attribute FGetSlateColor ColorAndOpacityDelegate;
  attribute float MinDesiredWidth;
  attribute boolean bWrapWithInvalidationPanel;

  void SetColorAndOpacity([Ref] FSlateColor InColorAndOpacity);
  void SetOpacity(float InOpacity);
  void SetShadowColorAndOpacity([Ref] FLinearColor InShadowColorAndOpacity);
  void SetShadowOffset([Ref] FVector2D InShadowOffset);
  void SetFont([Ref] FSlateFontInfo InFontInfo);
  void SetJustification(ETextJustify_Type InJustification);
  void SetText([Ref] FText InText);
  void SynchronizeProperties();
  void ReleaseSlateResources(boolean bReleaseChildren);
  [Value] FText GetText();
};

UTextBlock implements UTextLayoutWidget;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UContentWidget {
  void UContentWidget();
};

// TODO: complicated and not needed now
// UContentWidget implements UPanelWidget;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface UTextLayoutWidget {
  // class body is "protected"
};

UTextLayoutWidget implements UWidget;

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FShapedTextOptions {
  void FShapedTextOptions();
  attribute unsigned long bOverride_TextShapingMethod;
  attribute unsigned long bOverride_TextFlowDirection;
  attribute ETextShapingMethod TextShapingMethod;
  attribute ETextFlowDirection TextFlowDirection;

  // TODO: function template
  // template <typename TWidgetType>
  // void SynchronizeShapedTextProperties(TWidgetType& InWidget)
};
enum ETouchIndex_Type {
  "ETouchIndex::Touch1",
  "ETouchIndex::Touch2",
  "ETouchIndex::Touch3",
  "ETouchIndex::Touch4",
  "ETouchIndex::Touch5",
  "ETouchIndex::Touch6",
  "ETouchIndex::Touch7",
  "ETouchIndex::Touch8",
  "ETouchIndex::Touch9",
  "ETouchIndex::Touch10"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

interface FKey {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

interface FHitResult
{
  [Value] attribute FVector_NetQuantizeNormal Normal;
  attribute float Time;
  attribute long Item;

  void FHitResult();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxBounds3 {
  void PxBounds3();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxI64 {
  void PxI64();
};

[Prefix="physx::"]
interface PxU64 {
  void PxU64();
};

[Prefix="physx::"]
interface PxI32 {
  void PxI32();
};

[Prefix="physx::"]
interface PxU32 {
  void PxU32();
};

[Prefix="physx::"]
interface PxI16 {
  void PxI16();
};

[Prefix="physx::"]
interface PxU16 {
  void PxU16();
};

[Prefix="physx::"]
interface PxI8 {
  void PxI8();
};

[Prefix="physx::"]
interface PxU8 {
  void PxU8();
};

[Prefix="physx::"]
interface PxF32 {
  void PxF32();
};

[Prefix="physx::"]
interface PxF64 {
  void PxF64();
};

[Prefix="physx::"]
interface PxReal {
  void PxReal();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxMat33 {
  void PxMat33();
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxTransform {
  [Value] attribute PxQuat q;
  [Value] attribute PxVec3 p;

  void PxTransform();
  void PxTransform([Const, Ref] PxVec3 position);
  void PxTransform(float x, float y, float z, [Ref] PxQuat aQ);
  void PxTransform([Const, Ref] PxVec3 p0, [Const, Ref] PxQuat q0);

  [Operator="*=", Value] PxTransform multiply([Ref] PxTransform V);

  [Value] PxTransform getInverse();
  [Value] PxVec3 transform([Const, Ref] PxVec3 input);
  [Value] PxVec3 transformInv([Const, Ref] PxVec3 input);
  [Value] PxVec3 rotate([Const, Ref] PxVec3 input);
  [Value] PxVec3 rotateInv([Const, Ref] PxVec3 input);

  boolean isValid();
  boolean isSane();
  boolean isFinite();
  [Value] PxPlane inverseTransform([Const, Ref] PxPlane plane);
  [Value] PxTransform getNormalized();

  // TODO: some constructors missing due to lack of function overloading
  // void PxTransform([Ref] PxIDENTITY r);
  // void PxTransform([Const, Ref] PxQuat orientation);
  // void PxTransform([Const, Ref] PxMat44 m);

  // TODO: emscripten do not support these operators...
  // bool operator==(const PxTransform& t);
  // PxTransform operator*(const PxTransform& x);

  // TODO: assert return_type == ret.name, 'overloads must have the same return type'
  // [Value] PxTransform transform([Const, Ref] PxTransform src);
  // [Value] PxTransform transformInv([Const, Ref] PxTransform src);
  // [Value] PxPlane transform([Const, Ref] PxPlane plane);
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxPlane {
  void PxPlane();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxQuat {
  void PxQuat();
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxEMPTY
{
  "physx_PxEMPTY::PxEmpty"
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxVec3 {
  void PxVec3();
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxConstraintConnector {
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxShapeFlags {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxShapeFlag_Enum {
  "physx_PxShapeFlag::eSIMULATION_SHAPE",
  "physx_PxShapeFlag::eSCENE_QUERY_SHAPE",
  "physx_PxShapeFlag::eTRIGGER_SHAPE",
  "physx_PxShapeFlag::eVISUALIZATION",
  "physx_PxShapeFlag::ePARTICLE_DRAIN"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxShape {
  attribute any userData;

  void release();
  void acquireReference();
  physx_PxGeometryType_Enum getGeometryType();
  void setGeometry([Const, Ref] PxGeometry geometry);
  [Value] PxGeometryHolder getGeometry();
  boolean getBoxGeometry([Ref] PxBoxGeometry geometry);
  boolean getSphereGeometry([Ref] PxSphereGeometry geometry);
  boolean getCapsuleGeometry([Ref] PxCapsuleGeometry geometry);
  boolean getPlaneGeometry([Ref] PxPlaneGeometry geometry);
  boolean getConvexMeshGeometry([Ref] PxConvexMeshGeometry geometry);
  boolean getTriangleMeshGeometry([Ref] PxTriangleMeshGeometry geometry);
  boolean getHeightFieldGeometry([Ref] PxHeightFieldGeometry geometry);
  PxRigidActor getActor();

  void setLocalPose([Const, Ref] PxTransform pose);
  [Value] PxTransform getLocalPose();
  void setSimulationFilterData([Const, Ref] PxFilterData data);
  [Value] PxFilterData getSimulationFilterData();
  void setQueryFilterData([Const, Ref] PxFilterData data);
  [Value] PxFilterData getQueryFilterData();
  void setMaterials(PxMaterial[] materials, [Ref] PxU16 materialCount);
  [Value] PxU16 getNbMaterials();
  [Value] PxU32 getMaterials(PxMaterial[] userBuffer, [Ref] PxU32 bufferSize, [Ref] PxU32 startIndex);
  PxMaterial getMaterialFromInternalFaceIndex([Ref] PxU32 faceIndex);
  void setContactOffset([Ref] PxReal contactOffset);
  [Value] PxReal getContactOffset();
  void setRestOffset([Ref] PxReal restOffset);
  [Value] PxReal getRestOffset();
  void setFlag(physx_PxShapeFlag_Enum flag, boolean value);
  void setFlags([Ref] PxShapeFlags inFlags);
  [Value] PxShapeFlags getFlags();
  boolean isExclusive();
  void setName([Const] DOMString name);
  [Const] DOMString getName();
  [Const] DOMString getConcreteTypeName();
};

PxShape implements PxBase;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxAggregate {
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxScene {
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxRigidActor {
  void release();
  [Value] PxTransform getGlobalPose();
  void setGlobalPose([Const, Ref] PxTransform pose, boolean autowake);
  void attachShape([Ref] PxShape shape);
  void detachShape([Ref] PxShape shape, boolean wakeOnLostTouch);
  [Value] PxU32 getNbShapes();
  [Value] PxU32 getShapes(PxShape[] userBuffer, [Ref] PxU32 bufferSize, [Ref] PxU32 startIndex);
  [Value] PxU32 getNbConstraints();
  [Value] PxU32 getConstraints(PxConstraint[] userBuffer, [Ref] PxU32 bufferSize, [Ref] PxU32 startIndex);
};

PxRigidActor implements PxActor;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxRigidBodyFlags {
  void PxRigidBodyFlags();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxRigidBodyFlag_Enum {
  "physx_PxRigidBodyFlag::eKINEMATIC",
  "physx_PxRigidBodyFlag::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES",
  "physx_PxRigidBodyFlag::eENABLE_CCD",
  "physx_PxRigidBodyFlag::eENABLE_CCD_FRICTION",
  "physx_PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW",
  "physx_PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxRigidBody {
  void setCMassLocalPose([Const, Ref] PxTransform pose);
  [Value] PxTransform getCMassLocalPose();
  void setMass([Ref] PxReal mass);
  [Value] PxReal getMass();
  [Value] PxReal getInvMass();
  void setMassSpaceInertiaTensor([Const, Ref] PxVec3 m);
  [Value] PxVec3 getMassSpaceInertiaTensor();
  [Value] PxVec3 getMassSpaceInvInertiaTensor();
  [Value] PxVec3 getLinearVelocity();
  void setLinearVelocity([Const, Ref] PxVec3 linVel, boolean autowake);
  [Value] PxVec3 getAngularVelocity();
  void setAngularVelocity([Const, Ref] PxVec3 angVel, boolean autowake);
  void addForce([Const, Ref] PxVec3 force, physx_PxForceMode_Enum mode, boolean autowake);
  void addTorque([Const, Ref] PxVec3 torque, physx_PxForceMode_Enum mode, boolean autowake);
  void clearForce(physx_PxForceMode_Enum mode);
  void clearTorque(physx_PxForceMode_Enum mode);
  void setRigidBodyFlag(physx_PxRigidBodyFlag_Enum flag, boolean value);
  void setRigidBodyFlags([Ref] PxRigidBodyFlags inFlags);
  [Value] PxRigidBodyFlags getRigidBodyFlags();
  void setMinCCDAdvanceCoefficient([Ref] PxReal advanceCoefficient);
  [Value] PxReal getMinCCDAdvanceCoefficient();
  void setMaxDepenetrationVelocity([Ref] PxReal biasClamp);
  [Value] PxReal getMaxDepenetrationVelocity();
  void setMaxContactImpulse([Ref] PxReal maxImpulse);
  [Value] PxReal getMaxContactImpulse();
};

PxRigidBody implements PxRigidActor;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxConstraintFlags {
  void PxConstraintFlags();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxConstraintFlag_Enum {
  "physx_PxConstraintFlag::eBROKEN",
  "physx_PxConstraintFlag::ePROJECT_TO_ACTOR0",
  "physx_PxConstraintFlag::ePROJECT_TO_ACTOR1",
  "physx_PxConstraintFlag::ePROJECTION",
  "physx_PxConstraintFlag::eCOLLISION_ENABLED",
  "physx_PxConstraintFlag::eVISUALIZATION",
  "physx_PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES",
  "physx_PxConstraintFlag::eIMPROVED_SLERP",
  "physx_PxConstraintFlag::eDISABLE_PREPROCESSING",
  "physx_PxConstraintFlag::eGPU_COMPATIBLE"
};

/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::"]
interface PxConstraintShaderTable {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxConstraint {
  void release();
  PxScene getScene();
  void getActors([Ref] PxRigidActor[] actor0, [Ref] PxRigidActor[] actor1);
  void setActors(PxRigidActor actor0, PxRigidActor actor1);
  void markDirty();
  void setFlags([Ref] PxConstraintFlags flags);
  [Value] PxConstraintFlags getFlags();
  void setFlag(physx_PxConstraintFlag_Enum flag, boolean value);
  void getForce([Ref] PxVec3 linear, [Ref] PxVec3 angular);
  boolean isValid();
  void setBreakForce([Ref] PxReal linear, [Ref] PxReal angular);
  void getBreakForce([Ref] PxReal linear, [Ref] PxReal angular);
  void setMinResponseThreshold([Ref] PxReal threshold);
  [Value] PxReal getMinResponseThreshold();
  any getExternalReference([Ref] PxU32 typeID);
  void setConstraintFunctions([Ref] PxConstraintConnector connector, [Const, Ref] PxConstraintShaderTable shaders);
  [Const] DOMString getConcreteTypeName();
};

PxConstraint implements PxBase;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxType {
};

[Prefix="physx::"]
interface PxBaseFlags {
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxBaseFlag_Enum {
  "physx_PxBaseFlag::eOWNS_MEMORY",
  "physx_PxBaseFlag::eIS_RELEASABLE"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxBase {
  void release();
  [Const] DOMString getConcreteTypeName();
  [Value] PxType getConcreteType();
  void setBaseFlag(physx_PxBaseFlag_Enum flag, boolean value);
  void setBaseFlags([Ref] PxBaseFlags inFlags);
  [Value] PxBaseFlags getBaseFlags();
  boolean isReleasable();

  // TODO: how can we handle that?
  // template<class T> T* is();
  // template<class T> const T* is();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxTriangleID {
  void PxTriangleID();
};

[Prefix="physx::"]
interface PxMaterialTableIndex {
  void PxMaterialTableIndex();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxMaterialFlags {
  void PxMaterialFlags();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxMaterialFlag_Enum {
  "physx_PxMaterialFlag::eDISABLE_FRICTION",
  "physx_PxMaterialFlag::eDISABLE_STRONG_FRICTION"
};

enum physx_PxCombineMode_Enum {
  "physx_PxCombineMode::eAVERAGE",
  "physx_PxCombineMode::eMIN",
  "physx_PxCombineMode::eMULTIPLY",
  "physx_PxCombineMode::eMAX",
  "physx_PxCombineMode::eN_VALUES",
  "physx_PxCombineMode::ePAD_32"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxMaterial {
  attribute any userData;

  void release();
  [Value] PxU32 getReferenceCount();
  void acquireReference();
  void setDynamicFriction([Ref] PxReal coef);
  [Value] PxReal getDynamicFriction();
  void setStaticFriction([Ref] PxReal coef);
  [Value] PxReal getStaticFriction();
  void setRestitution([Ref] PxReal rest);
  [Value] PxReal getRestitution();
  void setFlag(physx_PxMaterialFlag_Enum flag, boolean val);
  void setFlags([Ref] PxMaterialFlags inFlags);
  [Value] PxMaterialFlags getFlags();
  void setFrictionCombineMode(physx_PxCombineMode_Enum combMode);
  physx_PxCombineMode_Enum getFrictionCombineMode();
  void setRestitutionCombineMode(physx_PxCombineMode_Enum combMode);
  physx_PxCombineMode_Enum getRestitutionCombineMode();
  [Const] DOMString getConcreteTypeName();
};

PxMaterial implements PxBase;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxRigidDynamicLockFlags {
  void PxRigidDynamicLockFlags();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxRigidDynamicLockFlag_Enum {
  "physx_PxRigidDynamicLockFlag::eLOCK_LINEAR_X",
  "physx_PxRigidDynamicLockFlag::eLOCK_LINEAR_Y",
  "physx_PxRigidDynamicLockFlag::eLOCK_LINEAR_Z",
  "physx_PxRigidDynamicLockFlag::eLOCK_ANGULAR_X",
  "physx_PxRigidDynamicLockFlag::eLOCK_ANGULAR_Y",
  "physx_PxRigidDynamicLockFlag::eLOCK_ANGULAR_Z"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface  PxRigidDynamic {
  void setKinematicTarget([Const, Ref] PxTransform destination);
  boolean getKinematicTarget([Ref] PxTransform target);
  void setLinearDamping([Ref] PxReal linDamp);
  [Value] PxReal getLinearDamping();
  void setAngularDamping([Ref] PxReal angDamp);
  [Value] PxReal getAngularDamping();
  void setMaxAngularVelocity([Ref] PxReal maxAngVel);
  [Value] PxReal getMaxAngularVelocity();
  boolean isSleeping();
  void setSleepThreshold([Ref] PxReal threshold);
  [Value] PxReal getSleepThreshold();
  void setStabilizationThreshold([Ref] PxReal threshold);
  [Value] PxReal getStabilizationThreshold();
  [Value] PxRigidDynamicLockFlags getRigidDynamicLockFlags();
  void setRigidDynamicLockFlag(physx_PxRigidDynamicLockFlag_Enum flag, boolean value);
  void setRigidDynamicLockFlags([Ref] PxRigidDynamicLockFlags flags);
  void setWakeCounter([Ref] PxReal wakeCounterValue);
  [Value] PxReal getWakeCounter();
  void wakeUp();
  void putToSleep();
  void setSolverIterationCounts([Ref] PxU32 minPositionIters, [Ref] PxU32 minVelocityIters);
  [Value] PxReal getContactReportThreshold();
  void setContactReportThreshold([Ref] PxReal threshold);
  [Const] DOMString getConcreteTypeName();
};

PxRigidDynamic implements PxRigidBody;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxClientID {
  void PxClientID();
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxActorFlags {
  void PxActorFlags();
};

[Prefix="physx::"]
interface PxDominanceGroup {
  void PxDominanceGroup();
};

/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxActorType_Enum {
  "physx_PxActorType::eRIGID_STATIC",
  "physx_PxActorType::eRIGID_DYNAMIC",
  "physx_PxActorType::eARTICULATION_LINK",
  "physx_PxActorType::eACTOR_COUNT",
  "physx_PxActorType::eACTOR_FORCE_DWORD"
};

enum physx_PxActorFlag_Enum {
  "physx_PxActorFlag::eVISUALIZATION",
  "physx_PxActorFlag::eDISABLE_GRAVITY",
  "physx_PxActorFlag::eSEND_SLEEP_NOTIFIES",
  "physx_PxActorFlag::eDISABLE_SIMULATION"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxActor {
  attribute any userData;

  void release();
  physx_PxActorType_Enum getType();
  PxScene getScene();
  void setName([Const] DOMString name);
  [Const] DOMString getName();
  [Value] PxBounds3 getWorldBounds(float inflation);
  void setActorFlag(physx_PxActorFlag_Enum flag, boolean value);
  void setActorFlags([Ref] PxActorFlags inFlags);
  [Value] PxActorFlags getActorFlags();
  void setDominanceGroup([Ref] PxDominanceGroup dominanceGroup);
  [Value] PxDominanceGroup getDominanceGroup();
  void setOwnerClient([Ref] PxClientID inClient);
  [Value] PxClientID getOwnerClient();
  PxAggregate getAggregate();
};

PxActor implements PxBase;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxFilterData {
  [Value] attribute PxU32 word0;
  [Value] attribute PxU32 word1;
  [Value] attribute PxU32 word2;
  [Value] attribute PxU32 word3;

  void PxFilterData();
  void PxFilterData([Const] physx_PxEMPTY arg);
  void PxFilterData([Ref] PxU32 w0, [Ref] PxU32 w1, [Ref] PxU32 w2, [Ref] PxU32 w3);
  void setToDefault();

  // TODO: emscripten do not support these operators...
  // boolean operator == ([Const, Ref] PxFilterData a);
  // boolean operator != ([Const, Ref] PxFilterData a);
};
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxForceMode_Enum {
  "physx_PxForceMode::eFORCE",
  "physx_PxForceMode::eIMPULSE",
  "physx_PxForceMode::eVELOCITY_CHANGE",
  "physx_PxForceMode::eACCELERATION"
};
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxHeightField {
};

PxHeightField implements PxBase;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxHeightFieldGeometry {
  attribute PxHeightField heightField;
  [Value] attribute PxReal heightScale;
  [Value] attribute PxReal rowScale;
  [Value] attribute PxReal columnScale;
  [Value] attribute PxMeshGeometryFlags heightFieldFlags;
  [Value] attribute PxPadding3 paddingFromFlags;

  void PxHeightFieldGeometry();
  void PxHeightFieldGeometry(PxHeightField hf, [Ref] PxMeshGeometryFlags flags, [Ref] PxReal heightScale_, [Ref] PxReal rowScale_, [Ref] PxReal columnScale_);
  boolean isValid();
};

PxHeightFieldGeometry implements PxGeometry;

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxBoxGeometry {
  [Value] attribute PxVec3 halfExtents;

  void PxBoxGeometry();
  void PxBoxGeometry([Ref] PxReal hx, [Ref] PxReal hy, [Ref] PxReal hz);
  void PxBoxGeometry([Ref] PxVec3 halfExtents_);
  boolean isValid();
};

PxBoxGeometry implements PxGeometry;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxPlaneGeometry {
  void PxPlaneGeometry();
  boolean isValid();
};

PxPlaneGeometry implements PxGeometry;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxMeshScale {
  [Value] attribute PxVec3 scale;
  [Value] attribute PxQuat rotation;

  void PxMeshScale();
  void PxMeshScale([Ref] PxReal r);
  void PxMeshScale([Const, Ref] PxVec3 s, [Const, Ref] PxQuat r);
  boolean isIdentity();
  [Value] PxMeshScale getInverse();
  [Value] PxMat33 toMat33();
  boolean hasNegativeDeterminant();
  [Value] PxVec3 transform([Const, Ref] PxVec3 v);
  boolean isValidForTriangleMesh();
  boolean isValidForConvexMesh();

  // TODO: some constructors missing due to lack of function overloading
  // void PxMeshScale([Const, Ref] PxVec3 s)
};
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxTriangleMeshFlags {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::", NoDelete]
interface PxTriangleMesh {
  [Value] PxU32 getNbVertices();
  [Const] PxVec3 getVertices();
  [Value] PxU32 getNbTriangles();
  [Const] any getTriangles();
  [Value] PxTriangleMeshFlags getTriangleMeshFlags();
  [Const] PxU32 getTrianglesRemap();
  void release();
  [Value] PxMaterialTableIndex getTriangleMaterialIndex([Ref] PxTriangleID triangleIndex);
  [Value] PxBounds3 getLocalBounds();
  [Value] PxU32 getReferenceCount();
  void acquireReference();

  // TODO: PX_ENABLE_DYNAMIC_MESH_RTREE
  // PxVec3 getVerticesForModification();
  // PxBounds3 refitBVH();
};

PxConvexMesh implements PxBase;
/*************************************************************/
/*                        ENUMS                              */
/*************************************************************/

enum physx_PxGeometryType_Enum {
  "physx_PxGeometryType::eSPHERE",
  "physx_PxGeometryType::ePLANE",
  "physx_PxGeometryType::eCAPSULE",
  "physx_PxGeometryType::eBOX",
  "physx_PxGeometryType::eCONVEXMESH",
  "physx_PxGeometryType::eTRIANGLEMESH",
  "physx_PxGeometryType::eHEIGHTFIELD",
  "physx_PxGeometryType::eGEOMETRY_COUNT",
  "physx_PxGeometryType::eINVALID"
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxGeometry {
  physx_PxGeometryType_Enum getType();
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxHullPolygon
{
  void PxHullPolygon();
  [Value] attribute PxReal[] mPlane;
  [Value] attribute PxU16 mNbVerts;
  [Value] attribute PxU16 mIndexBase;
};

[Prefix="physx::", NoDelete]
interface PxConvexMesh {
  [Value] PxU32 getNbVertices();
  [Const] PxVec3 getVertices();
  [Const] PxU8 getIndexBuffer();
  [Value] PxU32 getNbPolygons();
  boolean getPolygonData([Ref] PxU32 index, [Ref] PxHullPolygon data);
  void release();
  [Value] PxU32 getReferenceCount();
  void acquireReference();
  void getMassInformation([Ref] PxReal mass, [Ref] PxMat33 localInertia, [Ref] PxVec3 localCenterOfMass);
  [Value] PxBounds3 getLocalBounds();
  [Const] DOMString getConcreteTypeName();
  boolean isGpuCompatible();
};

PxConvexMesh implements PxBase;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxGeometryHolder {
  void PxGeometryHolder();
  void PxGeometryHolder([Const, Ref] PxGeometry geometry);
  physx_PxGeometryType_Enum getType();
  [Ref] PxSphereGeometry sphere();
  [Ref] PxPlaneGeometry plane();
  [Ref] PxCapsuleGeometry capsule();
  [Ref] PxBoxGeometry box();
  [Ref] PxConvexMeshGeometry convexMesh();
  [Ref] PxTriangleMeshGeometry triangleMesh();
  [Ref] PxHeightFieldGeometry heightField();
  void storeAny([Const, Ref] PxGeometry geometry);

  // TODO: name of the function is a keyword in IDL...
  // [Ref] PxGeometry any();
  // [Const, Ref] PxGeometry any();

  // TODO: function overload problem: "Extended attributes differ on different overloads"
  // [Const, Ref] PxSphereGeometry sphere();
  // [Const, Ref] PxPlaneGeometry plane();
  // [Const, Ref] PxCapsuleGeometry capsule();
  // [Const, Ref] PxBoxGeometry box();
  // [Const, Ref] PxConvexMeshGeometry convexMesh();
  // [Const, Ref] PxTriangleMeshGeometry triangleMesh();
  // [Const, Ref] PxHeightFieldGeometry heightField();
};
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxCapsuleGeometry {
  [Value] attribute PxReal radius;
  [Value] attribute PxReal halfHeight;

  void PxCapsuleGeometry();
  void PxCapsuleGeometry([Ref] PxReal radius_, [Ref] PxReal halfHeight_);
  boolean isValid();
};

PxCapsuleGeometry implements PxGeometry;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxPadding3 {
  void PxPadding3();
};

[Prefix="physx::"]
interface PxConvexMeshGeometryFlags {
  void PxConvexMeshGeometryFlags();
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxConvexMeshGeometry {
  [Value] attribute PxMeshScale scale;
  attribute PxConvexMesh convexMesh;
  [Value] attribute PxConvexMeshGeometryFlags meshFlags;
  [Value] attribute PxPadding3 paddingFromFlags;

  void PxConvexMeshGeometry();
  void PxConvexMeshGeometry(PxConvexMesh mesh, [Const, Ref] PxMeshScale scaling, [Ref] PxConvexMeshGeometryFlags flags);
  boolean isValid();
};

PxCapsuleGeometry implements PxGeometry;
/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxSphereGeometry {
  [Value] attribute PxReal radius;

  void PxSphereGeometry();
  void PxSphereGeometry([Ref] PxReal ir);
  boolean isValid();
};

PxSphereGeometry implements PxGeometry;
/*************************************************************/
/*                      HELPER DEFS                          */
/*************************************************************/

[Prefix="physx::"]
interface PxMeshGeometryFlags {
};

/*************************************************************/
/*                         APIS                              */
/*************************************************************/

[Prefix="physx::"]
interface PxTriangleMeshGeometry {
  [Value] attribute PxMeshScale scale;
  [Value] attribute PxMeshGeometryFlags meshFlags;
  [Value] attribute PxPadding3 paddingFromFlags;
  attribute PxTriangleMesh triangleMesh;

  void PxTriangleMeshGeometry();
  void PxTriangleMeshGeometry(PxTriangleMesh mesh, [Const, Ref] PxMeshScale scaling, [Ref] PxMeshGeometryFlags flags);
  boolean isValid();
};

PxTriangleMeshGeometry implements PxGeometry;
/*************************************************************/
/*                         TODO                              */
/*************************************************************/

[NoDelete]
interface ITargetPlatform {
};
